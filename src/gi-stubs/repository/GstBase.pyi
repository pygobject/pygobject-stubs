import typing

from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gst

T = typing.TypeVar("T")

BASE_PARSE_FLAG_DRAINING: int = 2
BASE_PARSE_FLAG_LOST_SYNC: int = 1
BASE_TRANSFORM_SINK_NAME: str = "sink"
BASE_TRANSFORM_SRC_NAME: str = "src"
_namespace: str = "GstBase"
_version: str = "1.0"

def type_find_helper(src: Gst.Pad, size: int) -> typing.Optional[Gst.Caps]: ...
def type_find_helper_for_buffer(
    obj: typing.Optional[Gst.Object], buf: Gst.Buffer
) -> typing.Tuple[typing.Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_for_buffer_with_caps(
    obj: typing.Optional[Gst.Object], buf: Gst.Buffer, caps: Gst.Caps
) -> typing.Tuple[typing.Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_for_buffer_with_extension(
    obj: typing.Optional[Gst.Object],
    buf: Gst.Buffer,
    extension: typing.Optional[str] = None,
) -> typing.Tuple[typing.Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_for_data(
    obj: typing.Optional[Gst.Object], data: typing.Sequence[int]
) -> typing.Tuple[typing.Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_for_data_with_caps(
    obj: typing.Optional[Gst.Object], data: typing.Sequence[int], caps: Gst.Caps
) -> typing.Tuple[typing.Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_for_data_with_extension(
    obj: typing.Optional[Gst.Object],
    data: typing.Sequence[int],
    extension: typing.Optional[str] = None,
) -> typing.Tuple[typing.Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_for_extension(
    obj: typing.Optional[Gst.Object], extension: str
) -> typing.Optional[Gst.Caps]: ...
def type_find_helper_get_range(
    obj: Gst.Object,
    parent: typing.Optional[Gst.Object],
    func: typing.Callable[
        [Gst.Object, typing.Optional[Gst.Object], int, int],
        typing.Tuple[Gst.FlowReturn, Gst.Buffer],
    ],
    size: int,
    extension: typing.Optional[str] = None,
) -> typing.Tuple[typing.Optional[Gst.Caps], Gst.TypeFindProbability]: ...
def type_find_helper_get_range_full(
    obj: Gst.Object,
    parent: typing.Optional[Gst.Object],
    func: typing.Callable[
        [Gst.Object, typing.Optional[Gst.Object], int, int],
        typing.Tuple[Gst.FlowReturn, Gst.Buffer],
    ],
    size: int,
    extension: typing.Optional[str] = None,
) -> typing.Tuple[Gst.FlowReturn, Gst.Caps, Gst.TypeFindProbability]: ...
def type_find_list_factories_for_caps(
    obj: typing.Optional[Gst.Object], caps: Gst.Caps
) -> typing.Optional[list[Gst.TypeFindFactory]]: ...

class Adapter(GObject.Object):
    """
    :Constructors:

    ::

        Adapter(**properties)
        new() -> GstBase.Adapter

    Object GstAdapter

    Signals from GObject:
      notify (GParam)
    """

    def available(self) -> int: ...
    def available_fast(self) -> int: ...
    def clear(self) -> None: ...
    def copy(self, offset: int, size: int) -> GLib.Bytes: ...
    def distance_from_discont(self) -> int: ...
    def dts_at_discont(self) -> int: ...
    def flush(self, flush: int) -> None: ...
    def get_buffer(self, nbytes: int) -> typing.Optional[Gst.Buffer]: ...
    def get_buffer_fast(self, nbytes: int) -> typing.Optional[Gst.Buffer]: ...
    def get_buffer_list(self, nbytes: int) -> typing.Optional[Gst.BufferList]: ...
    def get_list(self, nbytes: int) -> typing.Optional[list[Gst.Buffer]]: ...
    def map(self) -> typing.Optional[bytes]: ...
    def masked_scan_uint32(
        self, mask: int, pattern: int, offset: int, size: int
    ) -> int: ...
    def masked_scan_uint32_peek(
        self, mask: int, pattern: int, offset: int, size: int
    ) -> typing.Tuple[int, int]: ...
    @classmethod
    def new(cls) -> Adapter: ...
    def offset_at_discont(self) -> int: ...
    def prev_dts(self) -> typing.Tuple[int, int]: ...
    def prev_dts_at_offset(self, offset: int) -> typing.Tuple[int, int]: ...
    def prev_offset(self) -> typing.Tuple[int, int]: ...
    def prev_pts(self) -> typing.Tuple[int, int]: ...
    def prev_pts_at_offset(self, offset: int) -> typing.Tuple[int, int]: ...
    def pts_at_discont(self) -> int: ...
    def push(self, buf: Gst.Buffer) -> None: ...
    def take(self) -> typing.Optional[bytes]: ...
    def take_buffer(self, nbytes: int) -> typing.Optional[Gst.Buffer]: ...
    def take_buffer_fast(self, nbytes: int) -> typing.Optional[Gst.Buffer]: ...
    def take_buffer_list(self, nbytes: int) -> typing.Optional[Gst.BufferList]: ...
    def take_list(self, nbytes: int) -> typing.Optional[list[Gst.Buffer]]: ...
    def unmap(self) -> None: ...

class AdapterClass(GObject.GPointer): ...

class Aggregator(Gst.Element):
    """
    :Constructors:

    ::

        Aggregator(**properties)

    Object GstAggregator

    Properties from GstAggregator:
      latency -> guint64: Buffer latency
        Additional latency in live mode to allow upstream to take longer to produce buffers for the current position (in nanoseconds)
      min-upstream-latency -> guint64: Buffer latency
        When sources with a higher latency are expected to be plugged in dynamically after the aggregator has started playing, this allows overriding the minimum latency reported by the initial source(s). This is only taken into account when larger than the actually reported minimum latency. (nanoseconds)
      start-time-selection -> GstAggregatorStartTimeSelection: Start Time Selection
        Decides which start time is output
      start-time -> guint64: Start Time
        Start time to use if start-time-selection=set
      emit-signals -> gboolean: Emit signals
        Send signals

    Signals from GstElement:
      pad-added (GstPad)
      pad-removed (GstPad)
      no-more-pads ()

    Signals from GstObject:
      deep-notify (GstObject, GParam)

    Properties from GstObject:
      name -> gchararray: Name
        The name of the object
      parent -> GstObject: Parent
        The parent of the object

    Signals from GObject:
      notify (GParam)
    """

    class Props:
        emit_signals: bool
        latency: int
        min_upstream_latency: int
        start_time: int
        start_time_selection: AggregatorStartTimeSelection
        name: typing.Optional[str]
        parent: typing.Optional[Gst.Object]

    props: Props = ...
    parent: Gst.Element = ...
    srcpad: Gst.Pad = ...
    priv: AggregatorPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        emit_signals: bool = ...,
        latency: int = ...,
        min_upstream_latency: int = ...,
        start_time: int = ...,
        start_time_selection: AggregatorStartTimeSelection = ...,
        name: typing.Optional[str] = ...,
        parent: Gst.Object = ...,
    ) -> None: ...
    def do_aggregate(self, timeout: bool) -> Gst.FlowReturn: ...
    def do_clip(self, aggregator_pad: AggregatorPad, buf: Gst.Buffer) -> Gst.Buffer: ...
    def do_decide_allocation(self, query: Gst.Query) -> bool: ...
    def do_finish_buffer(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_finish_buffer_list(self, bufferlist: Gst.BufferList) -> Gst.FlowReturn: ...
    def do_fixate_src_caps(self, caps: Gst.Caps) -> Gst.Caps: ...
    def do_flush(self) -> Gst.FlowReturn: ...
    def do_get_next_time(self) -> int: ...
    def do_negotiate(self) -> bool: ...
    def do_negotiated_src_caps(self, caps: Gst.Caps) -> bool: ...
    def do_peek_next_sample(
        self, aggregator_pad: AggregatorPad
    ) -> typing.Optional[Gst.Sample]: ...
    def do_propose_allocation(
        self, pad: AggregatorPad, decide_query: Gst.Query, query: Gst.Query
    ) -> bool: ...
    def do_sink_event(
        self, aggregator_pad: AggregatorPad, event: Gst.Event
    ) -> bool: ...
    def do_sink_event_pre_queue(
        self, aggregator_pad: AggregatorPad, event: Gst.Event
    ) -> Gst.FlowReturn: ...
    def do_sink_query(
        self, aggregator_pad: AggregatorPad, query: Gst.Query
    ) -> bool: ...
    def do_sink_query_pre_queue(
        self, aggregator_pad: AggregatorPad, query: Gst.Query
    ) -> bool: ...
    def do_src_activate(self, mode: Gst.PadMode, active: bool) -> bool: ...
    def do_src_event(self, event: Gst.Event) -> bool: ...
    def do_src_query(self, query: Gst.Query) -> bool: ...
    def do_start(self) -> bool: ...
    def do_stop(self) -> bool: ...
    def do_update_src_caps(
        self, caps: Gst.Caps
    ) -> typing.Tuple[Gst.FlowReturn, Gst.Caps]: ...
    def finish_buffer(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def finish_buffer_list(self, bufferlist: Gst.BufferList) -> Gst.FlowReturn: ...
    def get_allocator(self) -> typing.Tuple[Gst.Allocator, Gst.AllocationParams]: ...
    def get_buffer_pool(self) -> typing.Optional[Gst.BufferPool]: ...
    def get_force_live(self) -> bool: ...
    def get_ignore_inactive_pads(self) -> bool: ...
    def get_latency(self) -> int: ...
    def negotiate(self) -> bool: ...
    def peek_next_sample(self, pad: AggregatorPad) -> typing.Optional[Gst.Sample]: ...
    def selected_samples(
        self,
        pts: int,
        dts: int,
        duration: int,
        info: typing.Optional[Gst.Structure] = None,
    ) -> None: ...
    def set_force_live(self, force_live: bool) -> None: ...
    def set_ignore_inactive_pads(self, ignore: bool) -> None: ...
    def set_latency(self, min_latency: int, max_latency: int) -> None: ...
    def set_src_caps(self, caps: Gst.Caps) -> None: ...
    def simple_get_next_time(self) -> int: ...
    def update_segment(self, segment: Gst.Segment) -> None: ...

class AggregatorClass(GObject.GPointer):
    """
    :Constructors:

    ::

        AggregatorClass()
    """

    parent_class: Gst.ElementClass = ...
    flush: typing.Callable[[Aggregator], Gst.FlowReturn] = ...
    clip: typing.Callable[[Aggregator, AggregatorPad, Gst.Buffer], Gst.Buffer] = ...
    finish_buffer: typing.Callable[[Aggregator, Gst.Buffer], Gst.FlowReturn] = ...
    sink_event: typing.Callable[[Aggregator, AggregatorPad, Gst.Event], bool] = ...
    sink_query: typing.Callable[[Aggregator, AggregatorPad, Gst.Query], bool] = ...
    src_event: typing.Callable[[Aggregator, Gst.Event], bool] = ...
    src_query: typing.Callable[[Aggregator, Gst.Query], bool] = ...
    src_activate: typing.Callable[[Aggregator, Gst.PadMode, bool], bool] = ...
    aggregate: typing.Callable[[Aggregator, bool], Gst.FlowReturn] = ...
    stop: typing.Callable[[Aggregator], bool] = ...
    start: typing.Callable[[Aggregator], bool] = ...
    get_next_time: typing.Callable[[Aggregator], int] = ...
    create_new_pad: None = ...
    update_src_caps: typing.Callable[
        [Aggregator, Gst.Caps], typing.Tuple[Gst.FlowReturn, Gst.Caps]
    ] = ...
    fixate_src_caps: typing.Callable[[Aggregator, Gst.Caps], Gst.Caps] = ...
    negotiated_src_caps: typing.Callable[[Aggregator, Gst.Caps], bool] = ...
    decide_allocation: typing.Callable[[Aggregator, Gst.Query], bool] = ...
    propose_allocation: typing.Callable[
        [Aggregator, AggregatorPad, Gst.Query, Gst.Query], bool
    ] = ...
    negotiate: typing.Callable[[Aggregator], bool] = ...
    sink_event_pre_queue: typing.Callable[
        [Aggregator, AggregatorPad, Gst.Event], Gst.FlowReturn
    ] = ...
    sink_query_pre_queue: typing.Callable[
        [Aggregator, AggregatorPad, Gst.Query], bool
    ] = ...
    finish_buffer_list: typing.Callable[
        [Aggregator, Gst.BufferList], Gst.FlowReturn
    ] = ...
    peek_next_sample: typing.Callable[
        [Aggregator, AggregatorPad], typing.Optional[Gst.Sample]
    ] = ...
    _gst_reserved: list[None] = ...

class AggregatorPad(Gst.Pad):
    """
    :Constructors:

    ::

        AggregatorPad(**properties)

    Object GstAggregatorPad

    Properties from GstAggregatorPad:
      emit-signals -> gboolean: Emit signals
        Send signals to signal data consumption

    Signals from GstPad:
      linked (GstPad)
      unlinked (GstPad)

    Properties from GstPad:
      direction -> GstPadDirection: Direction
        The direction of the pad
      template -> GstPadTemplate: Template
        The GstPadTemplate of this pad
      offset -> gint64: Offset
        The running time offset of the pad

    Signals from GstObject:
      deep-notify (GstObject, GParam)

    Properties from GstObject:
      name -> gchararray: Name
        The name of the object
      parent -> GstObject: Parent
        The parent of the object

    Signals from GObject:
      notify (GParam)
    """

    class Props:
        emit_signals: bool
        caps: Gst.Caps
        direction: Gst.PadDirection
        offset: int
        template: Gst.PadTemplate
        name: typing.Optional[str]
        parent: typing.Optional[Gst.Object]

    props: Props = ...
    parent: Gst.Pad = ...
    segment: Gst.Segment = ...
    priv: AggregatorPadPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        emit_signals: bool = ...,
        direction: Gst.PadDirection = ...,
        offset: int = ...,
        template: Gst.PadTemplate = ...,
        name: typing.Optional[str] = ...,
        parent: Gst.Object = ...,
    ) -> None: ...
    def do_flush(self, aggregator: Aggregator) -> Gst.FlowReturn: ...
    def do_skip_buffer(self, aggregator: Aggregator, buffer: Gst.Buffer) -> bool: ...
    def drop_buffer(self) -> bool: ...
    def has_buffer(self) -> bool: ...
    def is_eos(self) -> bool: ...
    def is_inactive(self) -> bool: ...
    def peek_buffer(self) -> typing.Optional[Gst.Buffer]: ...
    def pop_buffer(self) -> typing.Optional[Gst.Buffer]: ...

class AggregatorPadClass(GObject.GPointer):
    """
    :Constructors:

    ::

        AggregatorPadClass()
    """

    parent_class: Gst.PadClass = ...
    flush: typing.Callable[[AggregatorPad, Aggregator], Gst.FlowReturn] = ...
    skip_buffer: typing.Callable[[AggregatorPad, Aggregator, Gst.Buffer], bool] = ...
    _gst_reserved: list[None] = ...

class AggregatorPadPrivate(GObject.GPointer): ...
class AggregatorPrivate(GObject.GPointer): ...

class BaseParse(Gst.Element):
    """
    :Constructors:

    ::

        BaseParse(**properties)

    Object GstBaseParse

    Properties from GstBaseParse:
      disable-passthrough -> gboolean: Disable passthrough
        Force processing (disables passthrough)

    Signals from GstElement:
      pad-added (GstPad)
      pad-removed (GstPad)
      no-more-pads ()

    Signals from GstObject:
      deep-notify (GstObject, GParam)

    Properties from GstObject:
      name -> gchararray: Name
        The name of the object
      parent -> GstObject: Parent
        The parent of the object

    Signals from GObject:
      notify (GParam)
    """

    class Props:
        disable_passthrough: bool
        name: typing.Optional[str]
        parent: typing.Optional[Gst.Object]

    props: Props = ...
    element: Gst.Element = ...
    sinkpad: Gst.Pad = ...
    srcpad: Gst.Pad = ...
    flags: int = ...
    segment: Gst.Segment = ...
    _gst_reserved: list[None] = ...
    priv: BaseParsePrivate = ...
    def __init__(
        self,
        disable_passthrough: bool = ...,
        name: typing.Optional[str] = ...,
        parent: Gst.Object = ...,
    ) -> None: ...
    def add_index_entry(self, offset: int, ts: int, key: bool, force: bool) -> bool: ...
    def convert_default(
        self, src_format: Gst.Format, src_value: int, dest_format: Gst.Format
    ) -> typing.Tuple[bool, int]: ...
    def do_convert(
        self,
        src_format: Gst.Format,
        src_value: int,
        dest_format: Gst.Format,
        dest_value: int,
    ) -> bool: ...
    def do_detect(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_get_sink_caps(self, filter: Gst.Caps) -> Gst.Caps: ...
    def do_handle_frame(
        self, frame: BaseParseFrame
    ) -> typing.Tuple[Gst.FlowReturn, int]: ...
    def do_pre_push_frame(self, frame: BaseParseFrame) -> Gst.FlowReturn: ...
    def do_set_sink_caps(self, caps: Gst.Caps) -> bool: ...
    def do_sink_event(self, event: Gst.Event) -> bool: ...
    def do_sink_query(self, query: Gst.Query) -> bool: ...
    def do_src_event(self, event: Gst.Event) -> bool: ...
    def do_src_query(self, query: Gst.Query) -> bool: ...
    def do_start(self) -> bool: ...
    def do_stop(self) -> bool: ...
    def drain(self) -> None: ...
    def finish_frame(self, frame: BaseParseFrame, size: int) -> Gst.FlowReturn: ...
    def merge_tags(
        self, tags: typing.Optional[Gst.TagList], mode: Gst.TagMergeMode
    ) -> None: ...
    def push_frame(self, frame: BaseParseFrame) -> Gst.FlowReturn: ...
    def set_average_bitrate(self, bitrate: int) -> None: ...
    def set_duration(self, fmt: Gst.Format, duration: int, interval: int) -> None: ...
    def set_frame_rate(
        self, fps_num: int, fps_den: int, lead_in: int, lead_out: int
    ) -> None: ...
    def set_has_timing_info(self, has_timing: bool) -> None: ...
    def set_infer_ts(self, infer_ts: bool) -> None: ...
    def set_latency(self, min_latency: int, max_latency: int) -> None: ...
    def set_min_frame_size(self, min_size: int) -> None: ...
    def set_passthrough(self, passthrough: bool) -> None: ...
    def set_pts_interpolation(self, pts_interpolate: bool) -> None: ...
    def set_syncable(self, syncable: bool) -> None: ...
    def set_ts_at_offset(self, offset: int) -> None: ...

class BaseParseClass(GObject.GPointer):
    """
    :Constructors:

    ::

        BaseParseClass()
    """

    parent_class: Gst.ElementClass = ...
    start: typing.Callable[[BaseParse], bool] = ...
    stop: typing.Callable[[BaseParse], bool] = ...
    set_sink_caps: typing.Callable[[BaseParse, Gst.Caps], bool] = ...
    handle_frame: typing.Callable[
        [BaseParse, BaseParseFrame], typing.Tuple[Gst.FlowReturn, int]
    ] = ...
    pre_push_frame: typing.Callable[[BaseParse, BaseParseFrame], Gst.FlowReturn] = ...
    convert: typing.Callable[[BaseParse, Gst.Format, int, Gst.Format, int], bool] = ...
    sink_event: typing.Callable[[BaseParse, Gst.Event], bool] = ...
    src_event: typing.Callable[[BaseParse, Gst.Event], bool] = ...
    get_sink_caps: typing.Callable[[BaseParse, Gst.Caps], Gst.Caps] = ...
    detect: typing.Callable[[BaseParse, Gst.Buffer], Gst.FlowReturn] = ...
    sink_query: typing.Callable[[BaseParse, Gst.Query], bool] = ...
    src_query: typing.Callable[[BaseParse, Gst.Query], bool] = ...
    _gst_reserved: list[None] = ...

class BaseParseFrame(GObject.GBoxed):
    """
    :Constructors:

    ::

        BaseParseFrame()
        new(buffer:Gst.Buffer, flags:GstBase.BaseParseFrameFlags, overhead:int) -> GstBase.BaseParseFrame
    """

    buffer: Gst.Buffer = ...
    out_buffer: Gst.Buffer = ...
    flags: int = ...
    offset: int = ...
    overhead: int = ...
    size: int = ...
    _gst_reserved_i: list[int] = ...
    _gst_reserved_p: list[None] = ...
    _private_flags: int = ...
    def copy(self) -> BaseParseFrame: ...
    def free(self) -> None: ...
    def init(self) -> None: ...
    @classmethod
    def new(
        cls, buffer: Gst.Buffer, flags: BaseParseFrameFlags, overhead: int
    ) -> BaseParseFrame: ...

class BaseParsePrivate(GObject.GPointer): ...

class BaseSink(Gst.Element):
    """
    :Constructors:

    ::

        BaseSink(**properties)

    Object GstBaseSink

    Properties from GstBaseSink:
      sync -> gboolean: Sync
        Sync on the clock
      max-lateness -> gint64: Max Lateness
        Maximum number of nanoseconds that a buffer can be late before it is dropped (-1 unlimited)
      qos -> gboolean: Qos
        Generate Quality-of-Service events upstream
      async -> gboolean: Async
        Go asynchronously to PAUSED
      ts-offset -> gint64: TS Offset
        Timestamp offset in nanoseconds
      enable-last-sample -> gboolean: Enable Last Buffer
        Enable the last-sample property
      blocksize -> guint: Block size
        Size in bytes to pull per buffer (0 = default)
      render-delay -> guint64: Render Delay
        Additional render delay of the sink in nanoseconds
      throttle-time -> guint64: Throttle time
        The time to keep between rendered buffers (0 = disabled)
      max-bitrate -> guint64: Max Bitrate
        The maximum bits per second to render (0 = disabled)
      processing-deadline -> guint64: Processing deadline
        Maximum processing time for a buffer in nanoseconds

    Signals from GstElement:
      pad-added (GstPad)
      pad-removed (GstPad)
      no-more-pads ()

    Signals from GstObject:
      deep-notify (GstObject, GParam)

    Properties from GstObject:
      name -> gchararray: Name
        The name of the object
      parent -> GstObject: Parent
        The parent of the object

    Signals from GObject:
      notify (GParam)
    """

    class Props:
        _async: bool
        blocksize: int
        enable_last_sample: bool
        last_sample: typing.Optional[Gst.Sample]
        max_bitrate: int
        max_lateness: int
        processing_deadline: int
        qos: bool
        render_delay: int
        stats: Gst.Structure
        sync: bool
        throttle_time: int
        ts_offset: int
        name: typing.Optional[str]
        parent: typing.Optional[Gst.Object]

    props: Props = ...
    element: Gst.Element = ...
    sinkpad: Gst.Pad = ...
    pad_mode: Gst.PadMode = ...
    offset: int = ...
    can_activate_pull: bool = ...
    can_activate_push: bool = ...
    preroll_lock: GLib.Mutex = ...
    preroll_cond: GLib.Cond = ...
    eos: bool = ...
    need_preroll: bool = ...
    have_preroll: bool = ...
    playing_async: bool = ...
    have_newsegment: bool = ...
    segment: Gst.Segment = ...
    clock_id: None = ...
    sync: bool = ...
    flushing: bool = ...
    running: bool = ...
    max_lateness: int = ...
    priv: BaseSinkPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        _async: bool = ...,
        blocksize: int = ...,
        enable_last_sample: bool = ...,
        max_bitrate: int = ...,
        max_lateness: int = ...,
        processing_deadline: int = ...,
        qos: bool = ...,
        render_delay: int = ...,
        sync: bool = ...,
        throttle_time: int = ...,
        ts_offset: int = ...,
        name: typing.Optional[str] = ...,
        parent: Gst.Object = ...,
    ) -> None: ...
    def do_activate_pull(self, active: bool) -> bool: ...
    def do_event(self, event: Gst.Event) -> bool: ...
    def do_fixate(self, caps: Gst.Caps) -> Gst.Caps: ...
    def do_get_caps(self, filter: typing.Optional[Gst.Caps] = None) -> Gst.Caps: ...
    def do_get_times(self, buffer: Gst.Buffer) -> typing.Tuple[int, int]: ...
    def do_prepare(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_prepare_list(self, buffer_list: Gst.BufferList) -> Gst.FlowReturn: ...
    def do_preroll(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_propose_allocation(self, query: Gst.Query) -> bool: ...
    def do_render(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_render_list(self, buffer_list: Gst.BufferList) -> Gst.FlowReturn: ...
    def do_set_caps(self, caps: Gst.Caps) -> bool: ...
    def do_start(self) -> bool: ...
    def do_stop(self) -> bool: ...
    def do_unlock(self) -> bool: ...
    def do_unlock_stop(self) -> bool: ...
    def do_wait_event(self, event: Gst.Event) -> Gst.FlowReturn: ...
    def get_blocksize(self) -> int: ...
    def get_drop_out_of_segment(self) -> bool: ...
    def get_last_sample(self) -> typing.Optional[Gst.Sample]: ...
    def get_latency(self) -> int: ...
    def get_max_bitrate(self) -> int: ...
    def get_max_lateness(self) -> int: ...
    def get_processing_deadline(self) -> int: ...
    def get_render_delay(self) -> int: ...
    def get_stats(self) -> Gst.Structure: ...
    def get_sync(self) -> bool: ...
    def get_throttle_time(self) -> int: ...
    def get_ts_offset(self) -> int: ...
    def is_async_enabled(self) -> bool: ...
    def is_last_sample_enabled(self) -> bool: ...
    def is_qos_enabled(self) -> bool: ...
    def query_latency(self) -> typing.Tuple[bool, bool, bool, int, int]: ...
    def set_async_enabled(self, enabled: bool) -> None: ...
    def set_blocksize(self, blocksize: int) -> None: ...
    def set_drop_out_of_segment(self, drop_out_of_segment: bool) -> None: ...
    def set_last_sample_enabled(self, enabled: bool) -> None: ...
    def set_max_bitrate(self, max_bitrate: int) -> None: ...
    def set_max_lateness(self, max_lateness: int) -> None: ...
    def set_processing_deadline(self, processing_deadline: int) -> None: ...
    def set_qos_enabled(self, enabled: bool) -> None: ...
    def set_render_delay(self, delay: int) -> None: ...
    def set_sync(self, sync: bool) -> None: ...
    def set_throttle_time(self, throttle: int) -> None: ...
    def set_ts_offset(self, offset: int) -> None: ...
    def wait(self, time: int) -> typing.Tuple[Gst.FlowReturn, int]: ...
    def wait_clock(self, time: int) -> typing.Tuple[Gst.ClockReturn, int]: ...
    def wait_preroll(self) -> Gst.FlowReturn: ...

class BaseSinkClass(GObject.GPointer):
    """
    :Constructors:

    ::

        BaseSinkClass()
    """

    parent_class: Gst.ElementClass = ...
    get_caps: typing.Callable[[BaseSink, typing.Optional[Gst.Caps]], Gst.Caps] = ...
    set_caps: typing.Callable[[BaseSink, Gst.Caps], bool] = ...
    fixate: typing.Callable[[BaseSink, Gst.Caps], Gst.Caps] = ...
    activate_pull: typing.Callable[[BaseSink, bool], bool] = ...
    get_times: typing.Callable[[BaseSink, Gst.Buffer], typing.Tuple[int, int]] = ...
    propose_allocation: typing.Callable[[BaseSink, Gst.Query], bool] = ...
    start: typing.Callable[[BaseSink], bool] = ...
    stop: typing.Callable[[BaseSink], bool] = ...
    unlock: typing.Callable[[BaseSink], bool] = ...
    unlock_stop: typing.Callable[[BaseSink], bool] = ...
    query: typing.Callable[[BaseSink, Gst.Query], bool] = ...
    event: typing.Callable[[BaseSink, Gst.Event], bool] = ...
    wait_event: typing.Callable[[BaseSink, Gst.Event], Gst.FlowReturn] = ...
    prepare: typing.Callable[[BaseSink, Gst.Buffer], Gst.FlowReturn] = ...
    prepare_list: typing.Callable[[BaseSink, Gst.BufferList], Gst.FlowReturn] = ...
    preroll: typing.Callable[[BaseSink, Gst.Buffer], Gst.FlowReturn] = ...
    render: typing.Callable[[BaseSink, Gst.Buffer], Gst.FlowReturn] = ...
    render_list: typing.Callable[[BaseSink, Gst.BufferList], Gst.FlowReturn] = ...
    _gst_reserved: list[None] = ...

class BaseSinkPrivate(GObject.GPointer): ...

class BaseSrc(Gst.Element):
    """
    :Constructors:

    ::

        BaseSrc(**properties)

    Object GstBaseSrc

    Properties from GstBaseSrc:
      blocksize -> guint: Block size
        Size in bytes to read per buffer (-1 = default)
      num-buffers -> gint: num-buffers
        Number of buffers to output before sending EOS (-1 = unlimited)
      typefind -> gboolean: Typefind
        Run typefind before negotiating (deprecated, non-functional)
      do-timestamp -> gboolean: Do timestamp
        Apply current stream time to buffers

    Signals from GstElement:
      pad-added (GstPad)
      pad-removed (GstPad)
      no-more-pads ()

    Signals from GstObject:
      deep-notify (GstObject, GParam)

    Properties from GstObject:
      name -> gchararray: Name
        The name of the object
      parent -> GstObject: Parent
        The parent of the object

    Signals from GObject:
      notify (GParam)
    """

    class Props:
        blocksize: int
        do_timestamp: bool
        num_buffers: int
        typefind: bool
        name: typing.Optional[str]
        parent: typing.Optional[Gst.Object]

    props: Props = ...
    element: Gst.Element = ...
    srcpad: Gst.Pad = ...
    live_lock: GLib.Mutex = ...
    live_cond: GLib.Cond = ...
    is_live: bool = ...
    live_running: bool = ...
    blocksize: int = ...
    can_activate_push: bool = ...
    random_access: bool = ...
    clock_id: None = ...
    segment: Gst.Segment = ...
    need_newsegment: bool = ...
    num_buffers: int = ...
    num_buffers_left: int = ...
    typefind: bool = ...
    running: bool = ...
    pending_seek: Gst.Event = ...
    priv: BaseSrcPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        blocksize: int = ...,
        do_timestamp: bool = ...,
        num_buffers: int = ...,
        typefind: bool = ...,
        name: typing.Optional[str] = ...,
        parent: Gst.Object = ...,
    ) -> None: ...
    def do_alloc(
        self, offset: int, size: int
    ) -> typing.Tuple[Gst.FlowReturn, Gst.Buffer]: ...
    def do_create(
        self, offset: int, size: int
    ) -> typing.Tuple[Gst.FlowReturn, Gst.Buffer]: ...
    def do_decide_allocation(self, query: Gst.Query) -> bool: ...
    def do_do_seek(self, segment: Gst.Segment) -> bool: ...
    def do_event(self, event: Gst.Event) -> bool: ...
    def do_fill(self, offset: int, size: int, buf: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_fixate(self, caps: Gst.Caps) -> Gst.Caps: ...
    def do_get_caps(self, filter: typing.Optional[Gst.Caps] = None) -> Gst.Caps: ...
    def do_get_size(self) -> typing.Tuple[bool, int]: ...
    def do_get_times(self, buffer: Gst.Buffer) -> typing.Tuple[int, int]: ...
    def do_is_seekable(self) -> bool: ...
    def do_negotiate(self) -> bool: ...
    def do_prepare_seek_segment(
        self, seek: Gst.Event, segment: Gst.Segment
    ) -> bool: ...
    def do_set_caps(self, caps: Gst.Caps) -> bool: ...
    def do_start(self) -> bool: ...
    def do_stop(self) -> bool: ...
    def do_unlock(self) -> bool: ...
    def do_unlock_stop(self) -> bool: ...
    def get_allocator(self) -> typing.Tuple[Gst.Allocator, Gst.AllocationParams]: ...
    def get_blocksize(self) -> int: ...
    def get_buffer_pool(self) -> typing.Optional[Gst.BufferPool]: ...
    def get_do_timestamp(self) -> bool: ...
    def is_async(self) -> bool: ...
    def negotiate(self) -> bool: ...
    def new_seamless_segment(self, start: int, stop: int, time: int) -> bool: ...
    def new_segment(self, segment: Gst.Segment) -> bool: ...
    def query_latency(self) -> typing.Tuple[bool, bool, int, int]: ...
    def set_async(self, _async: bool) -> None: ...
    def set_automatic_eos(self, automatic_eos: bool) -> None: ...
    def set_blocksize(self, blocksize: int) -> None: ...
    def set_caps(self, caps: Gst.Caps) -> bool: ...
    def set_do_timestamp(self, timestamp: bool) -> None: ...
    def set_dynamic_size(self, dynamic: bool) -> None: ...
    def set_format(self, format: Gst.Format) -> None: ...
    def set_live(self, live: bool) -> None: ...
    def start_complete(self, ret: Gst.FlowReturn) -> None: ...
    def start_wait(self) -> Gst.FlowReturn: ...
    def submit_buffer_list(self, buffer_list: Gst.BufferList) -> None: ...
    def wait_playing(self) -> Gst.FlowReturn: ...

class BaseSrcClass(GObject.GPointer):
    """
    :Constructors:

    ::

        BaseSrcClass()
    """

    parent_class: Gst.ElementClass = ...
    get_caps: typing.Callable[[BaseSrc, typing.Optional[Gst.Caps]], Gst.Caps] = ...
    negotiate: typing.Callable[[BaseSrc], bool] = ...
    fixate: typing.Callable[[BaseSrc, Gst.Caps], Gst.Caps] = ...
    set_caps: typing.Callable[[BaseSrc, Gst.Caps], bool] = ...
    decide_allocation: typing.Callable[[BaseSrc, Gst.Query], bool] = ...
    start: typing.Callable[[BaseSrc], bool] = ...
    stop: typing.Callable[[BaseSrc], bool] = ...
    get_times: typing.Callable[[BaseSrc, Gst.Buffer], typing.Tuple[int, int]] = ...
    get_size: typing.Callable[[BaseSrc], typing.Tuple[bool, int]] = ...
    is_seekable: typing.Callable[[BaseSrc], bool] = ...
    prepare_seek_segment: typing.Callable[[BaseSrc, Gst.Event, Gst.Segment], bool] = ...
    do_seek: typing.Callable[[BaseSrc, Gst.Segment], bool] = ...
    unlock: typing.Callable[[BaseSrc], bool] = ...
    unlock_stop: typing.Callable[[BaseSrc], bool] = ...
    query: typing.Callable[[BaseSrc, Gst.Query], bool] = ...
    event: typing.Callable[[BaseSrc, Gst.Event], bool] = ...
    create: typing.Callable[
        [BaseSrc, int, int], typing.Tuple[Gst.FlowReturn, Gst.Buffer]
    ] = ...
    alloc: typing.Callable[
        [BaseSrc, int, int], typing.Tuple[Gst.FlowReturn, Gst.Buffer]
    ] = ...
    fill: typing.Callable[[BaseSrc, int, int, Gst.Buffer], Gst.FlowReturn] = ...
    _gst_reserved: list[None] = ...

class BaseSrcPrivate(GObject.GPointer): ...

class BaseTransform(Gst.Element):
    """
    :Constructors:

    ::

        BaseTransform(**properties)

    Object GstBaseTransform

    Properties from GstBaseTransform:
      qos -> gboolean: QoS
        Handle Quality-of-Service events

    Signals from GstElement:
      pad-added (GstPad)
      pad-removed (GstPad)
      no-more-pads ()

    Signals from GstObject:
      deep-notify (GstObject, GParam)

    Properties from GstObject:
      name -> gchararray: Name
        The name of the object
      parent -> GstObject: Parent
        The parent of the object

    Signals from GObject:
      notify (GParam)
    """

    class Props:
        qos: bool
        name: typing.Optional[str]
        parent: typing.Optional[Gst.Object]

    props: Props = ...
    element: Gst.Element = ...
    sinkpad: Gst.Pad = ...
    srcpad: Gst.Pad = ...
    have_segment: bool = ...
    segment: Gst.Segment = ...
    queued_buf: Gst.Buffer = ...
    priv: BaseTransformPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        qos: bool = ...,
        name: typing.Optional[str] = ...,
        parent: Gst.Object = ...,
    ) -> None: ...
    def do_accept_caps(self, direction: Gst.PadDirection, caps: Gst.Caps) -> bool: ...
    def do_before_transform(self, buffer: Gst.Buffer) -> None: ...
    def do_copy_metadata(self, input: Gst.Buffer, outbuf: Gst.Buffer) -> bool: ...
    def do_decide_allocation(self, query: Gst.Query) -> bool: ...
    def do_filter_meta(
        self, query: Gst.Query, api: typing.Type[typing.Any], params: Gst.Structure
    ) -> bool: ...
    def do_fixate_caps(
        self, direction: Gst.PadDirection, caps: Gst.Caps, othercaps: Gst.Caps
    ) -> Gst.Caps: ...
    def do_generate_output(self) -> typing.Tuple[Gst.FlowReturn, Gst.Buffer]: ...
    def do_get_unit_size(self, caps: Gst.Caps) -> typing.Tuple[bool, int]: ...
    def do_prepare_output_buffer(
        self, input: Gst.Buffer
    ) -> typing.Tuple[Gst.FlowReturn, Gst.Buffer]: ...
    def do_propose_allocation(
        self, decide_query: Gst.Query, query: Gst.Query
    ) -> bool: ...
    def do_set_caps(self, incaps: Gst.Caps, outcaps: Gst.Caps) -> bool: ...
    def do_sink_event(self, event: Gst.Event) -> bool: ...
    def do_src_event(self, event: Gst.Event) -> bool: ...
    def do_start(self) -> bool: ...
    def do_stop(self) -> bool: ...
    def do_submit_input_buffer(
        self, is_discont: bool, input: Gst.Buffer
    ) -> Gst.FlowReturn: ...
    def do_transform(self, inbuf: Gst.Buffer, outbuf: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_transform_caps(
        self, direction: Gst.PadDirection, caps: Gst.Caps, filter: Gst.Caps
    ) -> Gst.Caps: ...
    def do_transform_ip(self, buf: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_transform_meta(
        self, outbuf: Gst.Buffer, meta: Gst.Meta, inbuf: Gst.Buffer
    ) -> bool: ...
    def do_transform_size(
        self,
        direction: Gst.PadDirection,
        caps: Gst.Caps,
        size: int,
        othercaps: Gst.Caps,
    ) -> typing.Tuple[bool, int]: ...
    def get_allocator(self) -> typing.Tuple[Gst.Allocator, Gst.AllocationParams]: ...
    def get_buffer_pool(self) -> typing.Optional[Gst.BufferPool]: ...
    def is_in_place(self) -> bool: ...
    def is_passthrough(self) -> bool: ...
    def is_qos_enabled(self) -> bool: ...
    def reconfigure(self) -> bool: ...
    def reconfigure_sink(self) -> None: ...
    def reconfigure_src(self) -> None: ...
    def set_gap_aware(self, gap_aware: bool) -> None: ...
    def set_in_place(self, in_place: bool) -> None: ...
    def set_passthrough(self, passthrough: bool) -> None: ...
    def set_prefer_passthrough(self, prefer_passthrough: bool) -> None: ...
    def set_qos_enabled(self, enabled: bool) -> None: ...
    def update_qos(self, proportion: float, diff: int, timestamp: int) -> None: ...
    def update_src_caps(self, updated_caps: Gst.Caps) -> bool: ...

class BaseTransformClass(GObject.GPointer):
    """
    :Constructors:

    ::

        BaseTransformClass()
    """

    parent_class: Gst.ElementClass = ...
    passthrough_on_same_caps: bool = ...
    transform_ip_on_passthrough: bool = ...
    transform_caps: typing.Callable[
        [BaseTransform, Gst.PadDirection, Gst.Caps, Gst.Caps], Gst.Caps
    ] = ...
    fixate_caps: typing.Callable[
        [BaseTransform, Gst.PadDirection, Gst.Caps, Gst.Caps], Gst.Caps
    ] = ...
    accept_caps: typing.Callable[[BaseTransform, Gst.PadDirection, Gst.Caps], bool] = (
        ...
    )
    set_caps: typing.Callable[[BaseTransform, Gst.Caps, Gst.Caps], bool] = ...
    query: typing.Callable[[BaseTransform, Gst.PadDirection, Gst.Query], bool] = ...
    decide_allocation: typing.Callable[[BaseTransform, Gst.Query], bool] = ...
    filter_meta: typing.Callable[
        [BaseTransform, Gst.Query, typing.Type[typing.Any], Gst.Structure], bool
    ] = ...
    propose_allocation: typing.Callable[[BaseTransform, Gst.Query, Gst.Query], bool] = (
        ...
    )
    transform_size: typing.Callable[
        [BaseTransform, Gst.PadDirection, Gst.Caps, int, Gst.Caps],
        typing.Tuple[bool, int],
    ] = ...
    get_unit_size: typing.Callable[
        [BaseTransform, Gst.Caps], typing.Tuple[bool, int]
    ] = ...
    start: typing.Callable[[BaseTransform], bool] = ...
    stop: typing.Callable[[BaseTransform], bool] = ...
    sink_event: typing.Callable[[BaseTransform, Gst.Event], bool] = ...
    src_event: typing.Callable[[BaseTransform, Gst.Event], bool] = ...
    prepare_output_buffer: typing.Callable[
        [BaseTransform, Gst.Buffer], typing.Tuple[Gst.FlowReturn, Gst.Buffer]
    ] = ...
    copy_metadata: typing.Callable[[BaseTransform, Gst.Buffer, Gst.Buffer], bool] = ...
    transform_meta: typing.Callable[
        [BaseTransform, Gst.Buffer, Gst.Meta, Gst.Buffer], bool
    ] = ...
    before_transform: typing.Callable[[BaseTransform, Gst.Buffer], None] = ...
    transform: typing.Callable[
        [BaseTransform, Gst.Buffer, Gst.Buffer], Gst.FlowReturn
    ] = ...
    transform_ip: typing.Callable[[BaseTransform, Gst.Buffer], Gst.FlowReturn] = ...
    submit_input_buffer: typing.Callable[
        [BaseTransform, bool, Gst.Buffer], Gst.FlowReturn
    ] = ...
    generate_output: typing.Callable[
        [BaseTransform], typing.Tuple[Gst.FlowReturn, Gst.Buffer]
    ] = ...
    _gst_reserved: list[None] = ...

class BaseTransformPrivate(GObject.GPointer): ...

class BitReader(GObject.GPointer):
    """
    :Constructors:

    ::

        BitReader()
    """

    data: bytes = ...
    size: int = ...
    byte: int = ...
    bit: int = ...
    _gst_reserved: list[None] = ...
    def free(self) -> None: ...
    def get_bits_uint16(self, nbits: int) -> typing.Tuple[bool, int]: ...
    def get_bits_uint32(self, nbits: int) -> typing.Tuple[bool, int]: ...
    def get_bits_uint64(self, nbits: int) -> typing.Tuple[bool, int]: ...
    def get_bits_uint8(self, nbits: int) -> typing.Tuple[bool, int]: ...
    def get_pos(self) -> int: ...
    def get_remaining(self) -> int: ...
    def get_size(self) -> int: ...
    def init(self, data: typing.Sequence[int]) -> None: ...
    def peek_bits_uint16(self, nbits: int) -> typing.Tuple[bool, int]: ...
    def peek_bits_uint32(self, nbits: int) -> typing.Tuple[bool, int]: ...
    def peek_bits_uint64(self, nbits: int) -> typing.Tuple[bool, int]: ...
    def peek_bits_uint8(self, nbits: int) -> typing.Tuple[bool, int]: ...
    def set_pos(self, pos: int) -> bool: ...
    def skip(self, nbits: int) -> bool: ...
    def skip_to_byte(self) -> bool: ...

class BitWriter(GObject.GPointer):
    """
    :Constructors:

    ::

        BitWriter()
    """

    data: int = ...
    bit_size: int = ...
    bit_capacity: int = ...
    auto_grow: bool = ...
    owned: bool = ...
    _gst_reserved: list[None] = ...
    def align_bytes(self, trailing_bit: int) -> bool: ...
    def free(self) -> None: ...
    def free_and_get_buffer(self) -> Gst.Buffer: ...
    def free_and_get_data(self) -> bytes: ...
    def get_data(self) -> bytes: ...
    def get_remaining(self) -> int: ...
    def get_size(self) -> int: ...
    def put_bits_uint16(self, value: int, nbits: int) -> bool: ...
    def put_bits_uint32(self, value: int, nbits: int) -> bool: ...
    def put_bits_uint64(self, value: int, nbits: int) -> bool: ...
    def put_bits_uint8(self, value: int, nbits: int) -> bool: ...
    def put_bytes(self, data: typing.Sequence[int], nbytes: int) -> bool: ...
    def reset(self) -> None: ...
    def reset_and_get_buffer(self) -> Gst.Buffer: ...
    def reset_and_get_data(self) -> bytes: ...
    def set_pos(self, pos: int) -> bool: ...

class ByteReader(GObject.GPointer):
    """
    :Constructors:

    ::

        ByteReader()
    """

    data: bytes = ...
    size: int = ...
    byte: int = ...
    _gst_reserved: list[None] = ...
    def dup_data(self) -> typing.Tuple[bool, bytes]: ...
    def dup_string_utf16(self) -> typing.Tuple[bool, list[int]]: ...
    def dup_string_utf32(self) -> typing.Tuple[bool, list[int]]: ...
    def dup_string_utf8(self) -> typing.Tuple[bool, list[str]]: ...
    def free(self) -> None: ...
    def get_data(self) -> typing.Tuple[bool, bytes]: ...
    def get_float32_be(self) -> typing.Tuple[bool, float]: ...
    def get_float32_le(self) -> typing.Tuple[bool, float]: ...
    def get_float64_be(self) -> typing.Tuple[bool, float]: ...
    def get_float64_le(self) -> typing.Tuple[bool, float]: ...
    def get_int16_be(self) -> typing.Tuple[bool, int]: ...
    def get_int16_le(self) -> typing.Tuple[bool, int]: ...
    def get_int24_be(self) -> typing.Tuple[bool, int]: ...
    def get_int24_le(self) -> typing.Tuple[bool, int]: ...
    def get_int32_be(self) -> typing.Tuple[bool, int]: ...
    def get_int32_le(self) -> typing.Tuple[bool, int]: ...
    def get_int64_be(self) -> typing.Tuple[bool, int]: ...
    def get_int64_le(self) -> typing.Tuple[bool, int]: ...
    def get_int8(self) -> typing.Tuple[bool, int]: ...
    def get_pos(self) -> int: ...
    def get_remaining(self) -> int: ...
    def get_size(self) -> int: ...
    def get_string_utf8(self) -> typing.Tuple[bool, list[str]]: ...
    def get_uint16_be(self) -> typing.Tuple[bool, int]: ...
    def get_uint16_le(self) -> typing.Tuple[bool, int]: ...
    def get_uint24_be(self) -> typing.Tuple[bool, int]: ...
    def get_uint24_le(self) -> typing.Tuple[bool, int]: ...
    def get_uint32_be(self) -> typing.Tuple[bool, int]: ...
    def get_uint32_le(self) -> typing.Tuple[bool, int]: ...
    def get_uint64_be(self) -> typing.Tuple[bool, int]: ...
    def get_uint64_le(self) -> typing.Tuple[bool, int]: ...
    def get_uint8(self) -> typing.Tuple[bool, int]: ...
    def init(self, data: typing.Sequence[int]) -> None: ...
    def masked_scan_uint32(
        self, mask: int, pattern: int, offset: int, size: int
    ) -> int: ...
    def masked_scan_uint32_peek(
        self, mask: int, pattern: int, offset: int, size: int
    ) -> typing.Tuple[int, int]: ...
    def peek_data(self) -> typing.Tuple[bool, bytes]: ...
    def peek_float32_be(self) -> typing.Tuple[bool, float]: ...
    def peek_float32_le(self) -> typing.Tuple[bool, float]: ...
    def peek_float64_be(self) -> typing.Tuple[bool, float]: ...
    def peek_float64_le(self) -> typing.Tuple[bool, float]: ...
    def peek_int16_be(self) -> typing.Tuple[bool, int]: ...
    def peek_int16_le(self) -> typing.Tuple[bool, int]: ...
    def peek_int24_be(self) -> typing.Tuple[bool, int]: ...
    def peek_int24_le(self) -> typing.Tuple[bool, int]: ...
    def peek_int32_be(self) -> typing.Tuple[bool, int]: ...
    def peek_int32_le(self) -> typing.Tuple[bool, int]: ...
    def peek_int64_be(self) -> typing.Tuple[bool, int]: ...
    def peek_int64_le(self) -> typing.Tuple[bool, int]: ...
    def peek_int8(self) -> typing.Tuple[bool, int]: ...
    def peek_string_utf8(self) -> typing.Tuple[bool, list[str]]: ...
    def peek_uint16_be(self) -> typing.Tuple[bool, int]: ...
    def peek_uint16_le(self) -> typing.Tuple[bool, int]: ...
    def peek_uint24_be(self) -> typing.Tuple[bool, int]: ...
    def peek_uint24_le(self) -> typing.Tuple[bool, int]: ...
    def peek_uint32_be(self) -> typing.Tuple[bool, int]: ...
    def peek_uint32_le(self) -> typing.Tuple[bool, int]: ...
    def peek_uint64_be(self) -> typing.Tuple[bool, int]: ...
    def peek_uint64_le(self) -> typing.Tuple[bool, int]: ...
    def peek_uint8(self) -> typing.Tuple[bool, int]: ...
    def set_pos(self, pos: int) -> bool: ...
    def skip(self, nbytes: int) -> bool: ...
    def skip_string_utf16(self) -> bool: ...
    def skip_string_utf32(self) -> bool: ...
    def skip_string_utf8(self) -> bool: ...

class ByteWriter(GObject.GPointer):
    """
    :Constructors:

    ::

        ByteWriter()
    """

    parent: ByteReader = ...
    alloc_size: int = ...
    fixed: bool = ...
    owned: bool = ...
    _gst_reserved: list[None] = ...
    def ensure_free_space(self, size: int) -> bool: ...
    def fill(self, value: int, size: int) -> bool: ...
    def free(self) -> None: ...
    def free_and_get_buffer(self) -> Gst.Buffer: ...
    def free_and_get_data(self) -> int: ...
    def get_remaining(self) -> int: ...
    def init(self) -> None: ...
    def init_with_data(self, data: typing.Sequence[int], initialized: bool) -> None: ...
    def init_with_size(self, size: int, fixed: bool) -> None: ...
    def put_buffer(self, buffer: Gst.Buffer, offset: int, size: int) -> bool: ...
    def put_data(self, data: typing.Sequence[int]) -> bool: ...
    def put_float32_be(self, val: float) -> bool: ...
    def put_float32_le(self, val: float) -> bool: ...
    def put_float64_be(self, val: float) -> bool: ...
    def put_float64_le(self, val: float) -> bool: ...
    def put_int16_be(self, val: int) -> bool: ...
    def put_int16_le(self, val: int) -> bool: ...
    def put_int24_be(self, val: int) -> bool: ...
    def put_int24_le(self, val: int) -> bool: ...
    def put_int32_be(self, val: int) -> bool: ...
    def put_int32_le(self, val: int) -> bool: ...
    def put_int64_be(self, val: int) -> bool: ...
    def put_int64_le(self, val: int) -> bool: ...
    def put_int8(self, val: int) -> bool: ...
    def put_string_utf16(self, data: typing.Sequence[int]) -> bool: ...
    def put_string_utf32(self, data: typing.Sequence[int]) -> bool: ...
    def put_string_utf8(self, data: str) -> bool: ...
    def put_uint16_be(self, val: int) -> bool: ...
    def put_uint16_le(self, val: int) -> bool: ...
    def put_uint24_be(self, val: int) -> bool: ...
    def put_uint24_le(self, val: int) -> bool: ...
    def put_uint32_be(self, val: int) -> bool: ...
    def put_uint32_le(self, val: int) -> bool: ...
    def put_uint64_be(self, val: int) -> bool: ...
    def put_uint64_le(self, val: int) -> bool: ...
    def put_uint8(self, val: int) -> bool: ...
    def reset(self) -> None: ...
    def reset_and_get_buffer(self) -> Gst.Buffer: ...
    def reset_and_get_data(self) -> bytes: ...

class CollectData(GObject.GPointer):
    """
    :Constructors:

    ::

        CollectData()
    """

    collect: CollectPads = ...
    pad: Gst.Pad = ...
    buffer: Gst.Buffer = ...
    pos: int = ...
    segment: Gst.Segment = ...
    state: CollectPadsStateFlags = ...
    priv: CollectDataPrivate = ...

class CollectDataPrivate(GObject.GPointer): ...

class CollectPads(Gst.Object):
    """
    :Constructors:

    ::

        CollectPads(**properties)
        new() -> GstBase.CollectPads

    Object GstCollectPads

    Signals from GstObject:
      deep-notify (GstObject, GParam)

    Properties from GstObject:
      name -> gchararray: Name
        The name of the object
      parent -> GstObject: Parent
        The parent of the object

    Signals from GObject:
      notify (GParam)
    """

    class Props:
        name: typing.Optional[str]
        parent: typing.Optional[Gst.Object]

    props: Props = ...
    object: Gst.Object = ...
    data: list[CollectData] = ...
    stream_lock: GLib.RecMutex = ...
    priv: CollectPadsPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self, name: typing.Optional[str] = ..., parent: Gst.Object = ...
    ) -> None: ...
    def add_pad(
        self,
        pad: Gst.Pad,
        size: int,
        destroy_notify: typing.Callable[[CollectData], None],
        lock: bool,
    ) -> typing.Optional[CollectData]: ...
    def available(self) -> int: ...
    def clip_running_time(
        self, cdata: CollectData, buf: Gst.Buffer, user_data: None
    ) -> typing.Tuple[Gst.FlowReturn, Gst.Buffer]: ...
    def event_default(
        self, data: CollectData, event: Gst.Event, discard: bool
    ) -> bool: ...
    def flush(self, data: CollectData, size: int) -> int: ...
    @classmethod
    def new(cls) -> CollectPads: ...
    def peek(self, data: CollectData) -> typing.Optional[Gst.Buffer]: ...
    def pop(self, data: CollectData) -> typing.Optional[Gst.Buffer]: ...
    def query_default(
        self, data: CollectData, query: Gst.Query, discard: bool
    ) -> bool: ...
    def read_buffer(
        self, data: CollectData, size: int
    ) -> typing.Optional[Gst.Buffer]: ...
    def remove_pad(self, pad: Gst.Pad) -> bool: ...
    def set_buffer_function(
        self, func: typing.Callable[..., Gst.FlowReturn], *user_data: typing.Any
    ) -> None: ...
    def set_clip_function(
        self,
        clipfunc: typing.Callable[..., typing.Tuple[Gst.FlowReturn, Gst.Buffer]],
        *user_data: typing.Any,
    ) -> None: ...
    def set_compare_function(
        self, func: typing.Callable[..., int], *user_data: typing.Any
    ) -> None: ...
    def set_event_function(
        self, func: typing.Callable[..., bool], *user_data: typing.Any
    ) -> None: ...
    def set_flush_function(
        self, func: typing.Callable[..., None], *user_data: typing.Any
    ) -> None: ...
    def set_flushing(self, flushing: bool) -> None: ...
    def set_function(
        self, func: typing.Callable[..., Gst.FlowReturn], *user_data: typing.Any
    ) -> None: ...
    def set_query_function(
        self, func: typing.Callable[..., bool], *user_data: typing.Any
    ) -> None: ...
    def set_waiting(self, data: CollectData, waiting: bool) -> None: ...
    def src_event_default(self, pad: Gst.Pad, event: Gst.Event) -> bool: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def take_buffer(
        self, data: CollectData, size: int
    ) -> typing.Optional[Gst.Buffer]: ...

class CollectPadsClass(GObject.GPointer):
    """
    :Constructors:

    ::

        CollectPadsClass()
    """

    parent_class: Gst.ObjectClass = ...
    _gst_reserved: list[None] = ...

class CollectPadsPrivate(GObject.GPointer): ...

class DataQueue(GObject.Object):
    """
    :Constructors:

    ::

        DataQueue(**properties)

    Object GstDataQueue

    Signals from GstDataQueue:
      empty ()
      full ()

    Properties from GstDataQueue:
      current-level-visible -> guint: Current level (visible items)
        Current number of visible items in the queue
      current-level-bytes -> guint: Current level (kB)
        Current amount of data in the queue (bytes)
      current-level-time -> guint64: Current level (ns)
        Current amount of data in the queue (in ns)

    Signals from GObject:
      notify (GParam)
    """

    class Props:
        current_level_bytes: int
        current_level_time: int
        current_level_visible: int

    props: Props = ...
    object: GObject.Object = ...
    priv: DataQueuePrivate = ...
    _gst_reserved: list[None] = ...
    def do_empty(self) -> None: ...
    def do_full(self) -> None: ...

class DataQueueClass(GObject.GPointer):
    """
    :Constructors:

    ::

        DataQueueClass()
    """

    parent_class: GObject.ObjectClass = ...
    empty: typing.Callable[[DataQueue], None] = ...
    full: typing.Callable[[DataQueue], None] = ...
    _gst_reserved: list[None] = ...

class DataQueuePrivate(GObject.GPointer): ...

class FlowCombiner(GObject.GBoxed):
    """
    :Constructors:

    ::

        new() -> GstBase.FlowCombiner
    """

    def add_pad(self, pad: Gst.Pad) -> None: ...
    def clear(self) -> None: ...
    def free(self) -> None: ...
    @classmethod
    def new(cls) -> FlowCombiner: ...
    def ref(self) -> FlowCombiner: ...
    def remove_pad(self, pad: Gst.Pad) -> None: ...
    def reset(self) -> None: ...
    def unref(self) -> None: ...
    def update_flow(self, fret: Gst.FlowReturn) -> Gst.FlowReturn: ...
    def update_pad_flow(self, pad: Gst.Pad, fret: Gst.FlowReturn) -> Gst.FlowReturn: ...

class PushSrc(BaseSrc):
    """
    :Constructors:

    ::

        PushSrc(**properties)

    Object GstPushSrc

    Properties from GstBaseSrc:
      blocksize -> guint: Block size
        Size in bytes to read per buffer (-1 = default)
      num-buffers -> gint: num-buffers
        Number of buffers to output before sending EOS (-1 = unlimited)
      typefind -> gboolean: Typefind
        Run typefind before negotiating (deprecated, non-functional)
      do-timestamp -> gboolean: Do timestamp
        Apply current stream time to buffers

    Signals from GstElement:
      pad-added (GstPad)
      pad-removed (GstPad)
      no-more-pads ()

    Signals from GstObject:
      deep-notify (GstObject, GParam)

    Properties from GstObject:
      name -> gchararray: Name
        The name of the object
      parent -> GstObject: Parent
        The parent of the object

    Signals from GObject:
      notify (GParam)
    """

    class Props:
        blocksize: int
        do_timestamp: bool
        num_buffers: int
        typefind: bool
        name: typing.Optional[str]
        parent: typing.Optional[Gst.Object]

    props: Props = ...
    parent: BaseSrc = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        blocksize: int = ...,
        do_timestamp: bool = ...,
        num_buffers: int = ...,
        typefind: bool = ...,
        name: typing.Optional[str] = ...,
        parent: Gst.Object = ...,
    ) -> None: ...

class PushSrcClass(GObject.GPointer):
    """
    :Constructors:

    ::

        PushSrcClass()
    """

    parent_class: BaseSrcClass = ...
    create: typing.Callable[[PushSrc], typing.Tuple[Gst.FlowReturn, Gst.Buffer]] = ...
    alloc: typing.Callable[[PushSrc], typing.Tuple[Gst.FlowReturn, Gst.Buffer]] = ...
    fill: typing.Callable[[PushSrc, Gst.Buffer], Gst.FlowReturn] = ...
    _gst_reserved: list[None] = ...

class TypeFindData(GObject.GPointer): ...

class BaseParseFrameFlags(GObject.GFlags):
    CLIP = 4
    DROP = 8
    NEW_FRAME = 1
    NONE = 0
    NO_FRAME = 2
    QUEUE = 16

class BaseSrcFlags(GObject.GFlags):
    LAST = 1048576
    STARTED = 32768
    STARTING = 16384

class CollectPadsStateFlags(GObject.GFlags):
    EOS = 1
    FLUSHING = 2
    LOCKED = 16
    NEW_SEGMENT = 4
    WAITING = 8

class AggregatorStartTimeSelection(GObject.GEnum):
    FIRST = 1
    SET = 2
    ZERO = 0
