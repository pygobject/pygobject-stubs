import typing

import enum

from gi.repository import GLib
from typing_extensions import Self

T = typing.TypeVar("T")

G_MAXDOUBLE: float = 1.7976931348623157e308
G_MAXFLOAT: float = 3.4028234663852886e38
G_MAXINT: int = 2147483647
G_MAXINT16: int = 32767
G_MAXINT32: int = 2147483647
G_MAXINT64: int = 9223372036854775807
G_MAXINT8: int = 127
G_MAXLONG: int = 9223372036854775807
G_MAXOFFSET: int = 9223372036854775807
G_MAXSHORT: int = 32767
G_MAXSIZE: int = 18446744073709551615
G_MAXSSIZE: int = 9223372036854775807
G_MAXUINT: int = 4294967295
G_MAXUINT16: int = 65535
G_MAXUINT32: int = 4294967295
G_MAXUINT64: int = 18446744073709551615
G_MAXUINT8: int = 255
G_MAXULONG: int = 18446744073709551615
G_MAXUSHORT: int = 65535
G_MINDOUBLE: float = 2.2250738585072014e-308
G_MINFLOAT: float = 1.1754943508222875e-38
G_MININT: int = -2147483648
G_MININT16: int = -32768
G_MININT32: int = -2147483648
G_MININT64: int = -9223372036854775808
G_MININT8: int = -128
G_MINLONG: int = -9223372036854775808
G_MINOFFSET: int = -9223372036854775808
G_MINSHORT: int = -32768
G_MINSSIZE: int = -9223372036854775808
IO_ERR: int = 8
IO_FLAG_APPEND: int = 1
IO_FLAG_GET_MASK: int = 31
IO_FLAG_IS_READABLE: int = 4
IO_FLAG_IS_SEEKABLE: int = 16
IO_FLAG_IS_WRITEABLE: int = 8
IO_FLAG_MASK: int = 31
IO_FLAG_NONBLOCK: int = 2
IO_FLAG_SET_MASK: int = 3
IO_HUP: int = 16
IO_IN: int = 1
IO_NVAL: int = 32
IO_OUT: int = 4
IO_PRI: int = 2
IO_STATUS_AGAIN: int = 3
IO_STATUS_EOF: int = 2
IO_STATUS_ERROR: int = 0
IO_STATUS_NORMAL: int = 1
OPTION_ERROR_BAD_VALUE: int = 1
OPTION_ERROR_FAILED: int = 2
OPTION_ERROR_UNKNOWN_OPTION: int = 0
OPTION_FLAG_FILENAME: int = 16
OPTION_FLAG_HIDDEN: int = 1
OPTION_FLAG_IN_MAIN: int = 2
OPTION_FLAG_NOALIAS: int = 64
OPTION_FLAG_NO_ARG: int = 8
OPTION_FLAG_OPTIONAL_ARG: int = 32
OPTION_FLAG_REVERSE: int = 4
OPTION_REMAINING: str = ""
PARAM_CONSTRUCT: int = 4
PARAM_CONSTRUCT_ONLY: int = 8
PARAM_LAX_VALIDATION: int = 16
PARAM_MASK: int = 255
PARAM_READABLE: int = 1
PARAM_READWRITE: int = 3
PARAM_STATIC_STRINGS: int = 224
PARAM_USER_SHIFT: int = 8
PARAM_WRITABLE: int = 2
PRIORITY_DEFAULT: int = 0
PRIORITY_DEFAULT_IDLE: int = 200
PRIORITY_HIGH: int = -100
PRIORITY_HIGH_IDLE: int = 100
PRIORITY_LOW: int = 300
SIGNAL_ACTION: int = 32
SIGNAL_DETAILED: int = 16
SIGNAL_FLAGS_MASK: int = 511
SIGNAL_MATCH_MASK: int = 63
SIGNAL_NO_HOOKS: int = 64
SIGNAL_NO_RECURSE: int = 8
SIGNAL_RUN_CLEANUP: int = 4
SIGNAL_RUN_FIRST: int = 1
SIGNAL_RUN_LAST: int = 2
SPAWN_CHILD_INHERITS_STDIN: int = 32
SPAWN_DO_NOT_REAP_CHILD: int = 2
SPAWN_FILE_AND_ARGV_ZERO: int = 64
SPAWN_LEAVE_DESCRIPTORS_OPEN: int = 1
SPAWN_SEARCH_PATH: int = 4
SPAWN_STDERR_TO_DEV_NULL: int = 16
SPAWN_STDOUT_TO_DEV_NULL: int = 8
TYPE_BOOLEAN = ...  # FIXME Constant
TYPE_BOXED = ...  # FIXME Constant
TYPE_CHAR = ...  # FIXME Constant
TYPE_DOUBLE = ...  # FIXME Constant
TYPE_ENUM = ...  # FIXME Constant
TYPE_FLAGS = ...  # FIXME Constant
TYPE_FLAG_RESERVED_ID_BIT: int = 1
TYPE_FLOAT = ...  # FIXME Constant
TYPE_FUNDAMENTAL_MAX: int = 1020
TYPE_FUNDAMENTAL_SHIFT: int = 2
TYPE_GSTRING = ...  # FIXME Constant
TYPE_GTYPE = ...  # FIXME Constant
TYPE_INT = ...  # FIXME Constant
TYPE_INT64 = ...  # FIXME Constant
TYPE_INTERFACE = ...  # FIXME Constant
TYPE_INVALID = ...  # FIXME Constant
TYPE_LONG = ...  # FIXME Constant
TYPE_NONE = ...  # FIXME Constant
TYPE_OBJECT = ...  # FIXME Constant
TYPE_PARAM = ...  # FIXME Constant
TYPE_POINTER = ...  # FIXME Constant
TYPE_PYOBJECT = ...  # FIXME Constant
TYPE_RESERVED_BSE_FIRST: int = 32
TYPE_RESERVED_BSE_LAST: int = 48
TYPE_RESERVED_GLIB_FIRST: int = 22
TYPE_RESERVED_GLIB_LAST: int = 31
TYPE_RESERVED_USER_FIRST: int = 49
TYPE_STRING = ...  # FIXME Constant
TYPE_STRV = ...  # FIXME Constant
TYPE_UCHAR = ...  # FIXME Constant
TYPE_UINT = ...  # FIXME Constant
TYPE_UINT64 = ...  # FIXME Constant
TYPE_ULONG = ...  # FIXME Constant
TYPE_UNICHAR = ...  # FIXME Constant
TYPE_VALUE = ...  # FIXME Constant
TYPE_VARIANT = ...  # FIXME Constant
VALUE_COLLECT_FORMAT_MAX_LENGTH: int = 8
VALUE_INTERNED_STRING: int = 268435456
VALUE_NOCOPY_CONTENTS: int = 134217728
_lock = ...  # FIXME Constant
_namespace: str = "GObject"
_overrides_module = ...  # FIXME Constant
_version: str = "2.0"
features = ...  # FIXME Constant
glib_version = ...  # FIXME Constant
pygobject_version = ...  # FIXME Constant

# override
def add_emission_hook(*args, **kwargs): ...
def boxed_copy(boxed_type: typing.Type[typing.Any], src_boxed: None) -> None: ...
def boxed_free(boxed_type: typing.Type[typing.Any], boxed: None) -> None: ...
def boxed_type_register_static(
    name: str,
    boxed_copy: typing.Callable[[None], None],
    boxed_free: typing.Callable[[None], None],
) -> typing.Type[typing.Any]: ...
def cclosure_marshal_BOOLEAN__BOXED_BOXED(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_BOOLEAN__FLAGS(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_STRING__OBJECT_POINTER(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__BOOLEAN(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__BOXED(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__CHAR(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__DOUBLE(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__ENUM(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__FLAGS(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__FLOAT(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__INT(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__LONG(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__OBJECT(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__PARAM(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__POINTER(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__STRING(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__UCHAR(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__UINT(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__UINT_POINTER(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__ULONG(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__VARIANT(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_VOID__VOID(
    closure: typing.Callable[..., typing.Any],
    return_value: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def cclosure_marshal_generic(
    closure: typing.Callable[..., typing.Any],
    return_gvalue: typing.Any,
    n_param_values: int,
    param_values: typing.Any,
    invocation_hint: None,
    marshal_data: None,
) -> None: ...
def child_watch_add(*args, **kwargs): ...  # FIXME Function
def clear_signal_handler(handler_id_ptr: int, instance: Object) -> None: ...
def enum_complete_type_info(
    g_enum_type: typing.Type[typing.Any], const_values: EnumValue
) -> TypeInfo: ...
def enum_get_value(enum_class: EnumClass, value: int) -> typing.Optional[EnumValue]: ...
def enum_get_value_by_name(
    enum_class: EnumClass, name: str
) -> typing.Optional[EnumValue]: ...
def enum_get_value_by_nick(
    enum_class: EnumClass, nick: str
) -> typing.Optional[EnumValue]: ...
def enum_register_static(
    name: str, const_static_values: typing.Sequence[EnumValue]
) -> typing.Type[typing.Any]: ...
def enum_to_string(g_enum_type: typing.Type[typing.Any], value: int) -> str: ...
def filename_display_basename(filename: str) -> str: ...
def filename_display_name(filename: str) -> str: ...
def filename_from_utf8(utf8string, len=-1): ...  # FIXME Function
def flags_complete_type_info(
    g_flags_type: typing.Type[typing.Any], const_values: FlagsValue
) -> TypeInfo: ...
def flags_get_first_value(
    flags_class: FlagsClass, value: int
) -> typing.Optional[FlagsValue]: ...
def flags_get_value_by_name(
    flags_class: FlagsClass, name: str
) -> typing.Optional[FlagsValue]: ...
def flags_get_value_by_nick(
    flags_class: FlagsClass, nick: str
) -> typing.Optional[FlagsValue]: ...
def flags_register_static(
    name: str, const_static_values: typing.Sequence[FlagsValue]
) -> typing.Type[typing.Any]: ...
def flags_to_string(flags_type: typing.Type[typing.Any], value: int) -> str: ...
def get_application_name() -> typing.Optional[str]: ...
def get_current_time(): ...  # FIXME Function
def get_prgname() -> typing.Optional[str]: ...
def gtype_get_type() -> typing.Type[typing.Any]: ...
def idle_add(function, *user_data, priority=200): ...  # FIXME Function
def io_add_watch(*args, **kwargs): ...  # FIXME Function
def list_properties(*args, **kwargs): ...  # FIXME Function
def main_context_default() -> GLib.MainContext: ...
def main_depth() -> int: ...
def markup_escape_text(text, length=-1): ...  # FIXME Function
def new(*args, **kwargs): ...  # FIXME Function
def param_spec_boolean(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    default_value: bool,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_boxed(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    boxed_type: typing.Type[typing.Any],
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_char(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    minimum: int,
    maximum: int,
    default_value: int,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_double(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    minimum: float,
    maximum: float,
    default_value: float,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_enum(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    enum_type: typing.Type[typing.Any],
    default_value: int,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_flags(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    flags_type: typing.Type[typing.Any],
    default_value: int,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_float(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    minimum: float,
    maximum: float,
    default_value: float,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_gtype(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    is_a_type: typing.Type[typing.Any],
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_int(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    minimum: int,
    maximum: int,
    default_value: int,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_int64(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    minimum: int,
    maximum: int,
    default_value: int,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_long(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    minimum: int,
    maximum: int,
    default_value: int,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_object(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    object_type: typing.Type[typing.Any],
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_param(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    param_type: typing.Type[typing.Any],
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_pointer(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_string(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    default_value: typing.Optional[str],
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_uchar(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    minimum: int,
    maximum: int,
    default_value: int,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_uint(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    minimum: int,
    maximum: int,
    default_value: int,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_uint64(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    minimum: int,
    maximum: int,
    default_value: int,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_ulong(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    minimum: int,
    maximum: int,
    default_value: int,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_unichar(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    default_value: str,
    flags: ParamFlags,
) -> ParamSpec: ...
def param_spec_variant(
    name: str,
    nick: typing.Optional[str],
    blurb: typing.Optional[str],
    type: GLib.VariantType,
    default_value: typing.Optional[GLib.Variant],
    flags: ParamFlags,
) -> ParamSpec: ...
def param_type_register_static(
    name: str, pspec_info: ParamSpecTypeInfo
) -> typing.Type[typing.Any]: ...
def param_value_convert(
    pspec: ParamSpec,
    src_value: typing.Any,
    dest_value: typing.Any,
    strict_validation: bool,
) -> bool: ...
def param_value_defaults(pspec: ParamSpec, value: typing.Any) -> bool: ...
def param_value_is_valid(pspec: ParamSpec, value: typing.Any) -> bool: ...
def param_value_set_default(pspec: ParamSpec, value: typing.Any) -> None: ...
def param_value_validate(pspec: ParamSpec, value: typing.Any) -> bool: ...
def param_values_cmp(
    pspec: ParamSpec, value1: typing.Any, value2: typing.Any
) -> int: ...
def pointer_type_register_static(name: str) -> typing.Type[typing.Any]: ...
def remove_emission_hook(obj, detailed_signal, hook_id): ...  # FIXME Function
def set_application_name(application_name: str) -> None: ...
def set_prgname(prgname: str) -> None: ...
def signal_accumulator_first_wins(
    ihint, return_accu, handler_return, user_data=None
): ...  # FIXME Function
def signal_accumulator_true_handled(
    ihint, return_accu, handler_return, user_data=None
): ...  # FIXME Function
def signal_add_emission_hook(
    signal_id: int,
    detail: int,
    hook_func: typing.Callable[..., bool],
    *hook_data: typing.Any,
) -> int: ...
def signal_chain_from_overridden(
    instance_and_params: typing.Sequence[typing.Any], return_value: typing.Any
) -> None: ...
def signal_connect_closure(
    instance: Object,
    detailed_signal: str,
    closure: typing.Callable[..., typing.Any],
    after: bool,
) -> int: ...
def signal_connect_closure_by_id(
    instance: Object,
    signal_id: int,
    detail: int,
    closure: typing.Callable[..., typing.Any],
    after: bool,
) -> int: ...
def signal_emitv(
    instance_and_params: typing.Sequence[typing.Any], signal_id: int, detail: int
) -> typing.Any: ...
def signal_get_invocation_hint(
    instance: Object,
) -> typing.Optional[SignalInvocationHint]: ...
def signal_handler_block(obj, handler_id): ...  # FIXME Function
def signal_handler_disconnect(instance: Object, handler_id: int) -> None: ...

# override
def signal_handler_find(
    instance: Object,
    mask: SignalMatchType,
    signal_id: int,
    detail: int,
    _closure: typing.Optional[typing.Callable[..., typing.Any]],
    func: None,
    data: None,
    *closure: typing.Any,
) -> int: ...
def signal_handler_is_connected(instance: Object, handler_id: int) -> bool: ...
def signal_handler_unblock(instance: Object, handler_id: int) -> None: ...

# override
def signal_handlers_block_matched(
    instance: Object,
    mask: SignalMatchType,
    signal_id: int,
    detail: int,
    _closure: typing.Optional[typing.Callable[..., typing.Any]],
    func: None,
    data: None,
    *closure: typing.Any,
) -> int: ...
def signal_handlers_destroy(instance: Object) -> None: ...

# override
def signal_handlers_disconnect_matched(
    instance: Object,
    mask: SignalMatchType,
    signal_id: int,
    detail: int,
    _closure: typing.Optional[typing.Callable[..., typing.Any]],
    func: None,
    data: None,
    *closure: typing.Any,
) -> int: ...

# override
def signal_handlers_unblock_matched(
    instance: Object,
    mask: SignalMatchType,
    signal_id: int,
    detail: int,
    _closure: typing.Optional[typing.Callable[..., typing.Any]],
    func: None,
    data: None,
    *closure: typing.Any,
) -> int: ...
def signal_has_handler_pending(
    instance: Object, signal_id: int, detail: int, may_be_blocked: bool
) -> bool: ...
def signal_is_valid_name(name: str) -> bool: ...
def signal_list_ids(type_): ...  # FIXME Function
def signal_list_names(type_): ...  # FIXME Function
def signal_lookup(name, type_): ...  # FIXME Function
def signal_name(signal_id: int) -> typing.Optional[str]: ...
def signal_new(*args, **kwargs): ...  # FIXME Function
def signal_override_class_closure(
    signal_id: int,
    instance_type: typing.Type[typing.Any],
    class_closure: typing.Callable[..., typing.Any],
) -> None: ...
def signal_override_class_handler(
    signal_name: str,
    instance_type: typing.Type[typing.Any],
    class_handler: typing.Callable[[], None],
) -> None: ...
def signal_parse_name(detailed_signal, itype, force_detail_quark): ...  # FIXME Function
def signal_query(id_or_name, type_=None): ...  # FIXME Function
def signal_remove_emission_hook(signal_id: int, hook_id: int) -> None: ...
def signal_stop_emission(instance: Object, signal_id: int, detail: int) -> None: ...
def signal_stop_emission_by_name(instance: Object, detailed_signal: str) -> None: ...
def signal_type_cclosure_new(
    itype: typing.Type[typing.Any], struct_offset: int
) -> typing.Callable[..., typing.Any]: ...
def source_remove(tag: int) -> bool: ...
def source_set_closure(
    source: GLib.Source, closure: typing.Callable[..., typing.Any]
) -> None: ...
def source_set_dummy_callback(source: GLib.Source) -> None: ...
def spawn_async(*args, **kwargs): ...  # FIXME Function
def strdup_value_contents(value: typing.Any) -> str: ...
def threads_init(): ...  # FIXME Function
def timeout_add(interval, function, *user_data, priority=0): ...  # FIXME Function
def timeout_add_seconds(
    interval, function, *user_data, priority=0
): ...  # FIXME Function
def type_add_class_private(
    class_type: typing.Type[typing.Any], private_size: int
) -> None: ...
def type_add_instance_private(
    class_type: typing.Type[typing.Any], private_size: int
) -> int: ...
def type_add_interface_dynamic(
    instance_type: typing.Type[typing.Any],
    interface_type: typing.Type[typing.Any],
    plugin: TypePlugin,
) -> None: ...
def type_add_interface_static(
    instance_type: typing.Type[typing.Any],
    interface_type: typing.Type[typing.Any],
    info: InterfaceInfo,
) -> None: ...
def type_check_class_is_a(
    g_class: TypeClass, is_a_type: typing.Type[typing.Any]
) -> bool: ...
def type_check_instance(instance: TypeInstance) -> bool: ...
def type_check_instance_is_a(
    instance: TypeInstance, iface_type: typing.Type[typing.Any]
) -> bool: ...
def type_check_instance_is_fundamentally_a(
    instance: TypeInstance, fundamental_type: typing.Type[typing.Any]
) -> bool: ...
def type_check_is_value_type(type: typing.Type[typing.Any]) -> bool: ...
def type_check_value(value: typing.Any) -> bool: ...
def type_check_value_holds(
    value: typing.Any, type: typing.Type[typing.Any]
) -> bool: ...
def type_children(type: typing.Type[typing.Any]) -> list[typing.Type[typing.Any]]: ...
def type_class_adjust_private_offset(
    g_class: None, private_size_or_offset: int
) -> None: ...
def type_class_get(type: typing.Type[typing.Any]) -> TypeClass: ...
def type_class_peek(type: typing.Type[typing.Any]) -> typing.Optional[TypeClass]: ...
def type_class_peek_static(
    type: typing.Type[typing.Any],
) -> typing.Optional[TypeClass]: ...
def type_class_ref(type: typing.Type[typing.Any]) -> TypeClass: ...
def type_default_interface_get(g_type: typing.Type[typing.Any]) -> TypeInterface: ...
def type_default_interface_peek(g_type: typing.Type[typing.Any]) -> TypeInterface: ...
def type_default_interface_ref(g_type: typing.Type[typing.Any]) -> TypeInterface: ...
def type_default_interface_unref(g_iface: TypeInterface) -> None: ...
def type_depth(type: typing.Type[typing.Any]) -> int: ...
def type_ensure(type: typing.Type[typing.Any]) -> None: ...
def type_free_instance(instance: TypeInstance) -> None: ...
def type_from_name(name): ...  # FIXME Function
def type_fundamental(type_id: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
def type_fundamental_next() -> typing.Type[typing.Any]: ...
def type_get_instance_count(type: typing.Type[typing.Any]) -> int: ...
def type_get_plugin(type: typing.Type[typing.Any]) -> TypePlugin: ...
def type_get_qdata(type: typing.Type[typing.Any], quark: int) -> None: ...
def type_get_type_registration_serial() -> int: ...
def type_init() -> None: ...
def type_init_with_debug_flags(debug_flags: TypeDebugFlags) -> None: ...
def type_interface_add_prerequisite(
    interface_type: typing.Type[typing.Any], prerequisite_type: typing.Type[typing.Any]
) -> None: ...
def type_interface_get_plugin(
    instance_type: typing.Type[typing.Any], interface_type: typing.Type[typing.Any]
) -> TypePlugin: ...
def type_interface_instantiatable_prerequisite(
    interface_type: typing.Type[typing.Any],
) -> typing.Type[typing.Any]: ...
def type_interface_peek(
    instance_class: TypeClass, iface_type: typing.Type[typing.Any]
) -> typing.Optional[TypeInterface]: ...
def type_interface_prerequisites(
    interface_type: typing.Type[typing.Any],
) -> list[typing.Type[typing.Any]]: ...
def type_interfaces(type: typing.Type[typing.Any]) -> list[typing.Type[typing.Any]]: ...
def type_is_a(
    type: typing.Type[typing.Any], is_a_type: typing.Type[typing.Any]
) -> bool: ...
def type_name(type: typing.Type[typing.Any]) -> typing.Optional[str]: ...
def type_name_from_class(g_class: TypeClass) -> str: ...
def type_name_from_instance(instance: TypeInstance) -> str: ...
def type_next_base(
    leaf_type: typing.Type[typing.Any], root_type: typing.Type[typing.Any]
) -> typing.Type[typing.Any]: ...
def type_parent(type_): ...  # FIXME Function
def type_qname(type: typing.Type[typing.Any]) -> int: ...
def type_query(type: typing.Type[typing.Any]) -> TypeQuery: ...
def type_register(*args, **kwargs): ...  # FIXME Function
def type_register_dynamic(
    parent_type: typing.Type[typing.Any],
    type_name: str,
    plugin: TypePlugin,
    flags: TypeFlags,
) -> typing.Type[typing.Any]: ...
def type_register_fundamental(
    type_id: typing.Type[typing.Any],
    type_name: str,
    info: TypeInfo,
    finfo: TypeFundamentalInfo,
    flags: TypeFlags,
) -> typing.Type[typing.Any]: ...
def type_register_static(
    parent_type: typing.Type[typing.Any],
    type_name: str,
    info: TypeInfo,
    flags: TypeFlags,
) -> typing.Type[typing.Any]: ...
def type_set_qdata(type: typing.Type[typing.Any], quark: int, data: None) -> None: ...
def type_test_flags(type: typing.Type[typing.Any], flags: int) -> bool: ...
def uri_list_extract_uris(uri_list: str) -> list[str]: ...
def value_type_compatible(
    src_type: typing.Type[typing.Any], dest_type: typing.Type[typing.Any]
) -> bool: ...
def value_type_transformable(
    src_type: typing.Type[typing.Any], dest_type: typing.Type[typing.Any]
) -> bool: ...
def variant_get_gtype() -> typing.Type[typing.Any]: ...

# override
class _HandlerBlockManager:
    def __init__(self, obj, handler_id: int) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...

class Array(GBoxed): ...

class Binding(Object):
    """
    :Constructors:

    ::

        Binding(**properties)

    Object GBinding

    Properties from GBinding:
      source -> GObject: source
      target -> GObject: target
      source-property -> gchararray: source-property
      target-property -> gchararray: target-property
      flags -> GBindingFlags: flags

    Signals from GObject:
      notify (GParam)
    """
    class Props(Object.Props):
        flags: BindingFlags
        source: typing.Optional[Object]
        source_property: str
        target: typing.Optional[Object]
        target_property: str

    props: Props = ...
    # override
    def __init__(
        self,
        flags: BindingFlags = ...,
        source: Object = ...,
        source_property: str = ...,
        target: Object = ...,
        target_property: str = ...,
    ) -> None: ...
    def dup_source(self) -> typing.Optional[Object]: ...
    def dup_target(self) -> typing.Optional[Object]: ...
    def get_flags(self) -> BindingFlags: ...
    def get_source(self) -> typing.Optional[Object]: ...
    def get_source_property(self) -> str: ...
    def get_target(self) -> typing.Optional[Object]: ...
    def get_target_property(self) -> str: ...
    # override
    def unbind(self) -> None: ...

class BindingGroup(Object):
    """
    :Constructors:

    ::

        BindingGroup(**properties)
        new() -> GObject.BindingGroup

    Object GBindingGroup

    Properties from GBindingGroup:
      source -> GObject: source

    Signals from GObject:
      notify (GParam)
    """
    class Props(Object.Props):
        source: typing.Optional[Object]

    props: Props = ...
    def __init__(self, source: typing.Optional[Object] = ...) -> None: ...
    def bind(
        self,
        source_property: str,
        target: Object,
        target_property: str,
        flags: BindingFlags,
    ) -> None: ...
    def bind_full(
        self,
        source_property: str,
        target: Object,
        target_property: str,
        flags: BindingFlags,
        transform_to: typing.Optional[typing.Callable[..., typing.Any]] = None,
        transform_from: typing.Optional[typing.Callable[..., typing.Any]] = None,
    ) -> None: ...
    def dup_source(self) -> typing.Optional[Object]: ...
    @classmethod
    def new(cls) -> BindingGroup: ...
    def set_source(self, source: typing.Optional[Object] = None) -> None: ...

class BookmarkFile(GBoxed): ...
class ByteArray(GBoxed): ...
class Bytes(GBoxed): ...

class CClosure(GPointer):
    """
    :Constructors:

    ::

        CClosure()
    """

    closure: typing.Callable[..., typing.Any] = ...
    callback: None = ...
    @staticmethod
    def marshal_BOOLEAN__BOXED_BOXED(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_BOOLEAN__FLAGS(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_STRING__OBJECT_POINTER(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__BOOLEAN(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__BOXED(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__CHAR(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__DOUBLE(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__ENUM(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__FLAGS(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__FLOAT(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__INT(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__LONG(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__OBJECT(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__PARAM(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__POINTER(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__STRING(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__UCHAR(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__UINT(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__UINT_POINTER(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__ULONG(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__VARIANT(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_VOID__VOID(
        closure: typing.Callable[..., typing.Any],
        return_value: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...
    @staticmethod
    def marshal_generic(
        closure: typing.Callable[..., typing.Any],
        return_gvalue: typing.Any,
        n_param_values: int,
        param_values: typing.Any,
        invocation_hint: None,
        marshal_data: None,
    ) -> None: ...

class Checksum(GBoxed): ...

class Closure(GBoxed):
    """
    :Constructors:

    ::

        Closure()
        new_object(sizeof_closure:int, object:GObject.Object) -> GObject.Closure
        new_simple(sizeof_closure:int, data=None) -> GObject.Closure
    """

    ref_count: int = ...
    meta_marshal_nouse: int = ...
    n_guards: int = ...
    n_fnotifiers: int = ...
    n_inotifiers: int = ...
    in_inotify: int = ...
    floating: int = ...
    derivative_flag: int = ...
    in_marshal: int = ...
    is_invalid: int = ...
    marshal: typing.Callable[
        [typing.Callable[..., typing.Any], typing.Any, int, typing.Any, None, None],
        None,
    ] = ...
    data: None = ...
    notifiers: ClosureNotifyData = ...
    def invalidate(self) -> None: ...
    def invoke(
        self, param_values: typing.Sequence[typing.Any], invocation_hint: None
    ) -> typing.Any: ...
    @classmethod
    def new_object(cls, sizeof_closure: int, object: Object) -> Closure: ...
    @classmethod
    def new_simple(cls, sizeof_closure: int, data: None) -> Closure: ...
    def ref(self) -> typing.Callable[..., typing.Any]: ...
    def sink(self) -> None: ...
    def unref(self) -> None: ...

class ClosureNotifyData(GPointer):
    """
    :Constructors:

    ::

        ClosureNotifyData()
    """

    data: None = ...
    notify: typing.Callable[[None, typing.Callable[..., typing.Any]], None] = ...

class Date(GBoxed): ...
class DateTime(GBoxed): ...
class Dir(GBoxed): ...

class EnumClass(GPointer):
    """
    :Constructors:

    ::

        EnumClass()
    """

    g_type_class: TypeClass = ...
    minimum: int = ...
    maximum: int = ...
    n_values: int = ...
    values: EnumValue = ...

class EnumValue(GPointer):
    """
    :Constructors:

    ::

        EnumValue()
    """

    value: int = ...
    value_name: str = ...
    value_nick: str = ...

class Error(GBoxed):
    """
    :Constructors:

    ::

        Error()
        new_literal(domain:int, code:int, message:str) -> error
    """

    domain: int = ...
    code: int = ...
    message: str = ...
    def copy(self) -> GLib.Error: ...
    @staticmethod
    def domain_register(
        error_type_name: str,
        error_type_private_size: int,
        error_type_init: typing.Callable[[GLib.Error], None],
        error_type_copy: typing.Callable[[GLib.Error, GLib.Error], None],
        error_type_clear: typing.Callable[[GLib.Error], None],
    ) -> int: ...
    @staticmethod
    def domain_register_static(
        error_type_name: str,
        error_type_private_size: int,
        error_type_init: typing.Callable[[GLib.Error], None],
        error_type_copy: typing.Callable[[GLib.Error, GLib.Error], None],
        error_type_clear: typing.Callable[[GLib.Error], None],
    ) -> int: ...
    def free(self) -> None: ...
    def matches(self, domain: int, code: int) -> bool: ...
    @classmethod
    def new_literal(cls, domain: int, code: int, message: str) -> Error: ...

class FlagsClass(GPointer):
    """
    :Constructors:

    ::

        FlagsClass()
    """

    g_type_class: TypeClass = ...
    mask: int = ...
    n_values: int = ...
    values: FlagsValue = ...

class FlagsValue(GPointer):
    """
    :Constructors:

    ::

        FlagsValue()
    """

    value: int = ...
    value_name: str = ...
    value_nick: str = ...

class Float: ...

class GBoxed:
    def copy(self, /): ...  # FIXME Function

class GError:
    def copy(self): ...  # FIXME Function
    def matches(self, domain, code): ...  # FIXME Function
    def new_literal(domain, message, code): ...  # FIXME Function

# override
class GInterface(typing.Protocol):
    g_type_instance: TypeInstance = ...
    ref_count: int = ...
    qdata: GLib.Data = ...
    props = ...

    def bind_property(
        self,
        source_property: str,
        target: Object,
        target_property: str,
        flags: BindingFlags = BindingFlags.DEFAULT,
        transform_to: typing.Optional[typing.Callable[..., typing.Any]] = None,
        transform_from: typing.Optional[typing.Callable[..., typing.Any]] = None,
        user_data: typing.Optional[typing.Any] = None,
    ) -> Binding: ...
    def bind_property_full(self, *args, **kargs): ...
    def chain(self, *args, **kwargs): ...
    def compat_control(self, *args, **kargs): ...
    def connect(
        self,
        detailed_signal: str | Signal,
        handler: typing.Callable[..., typing.Any],
        *args: typing.Any,
    ) -> int: ...
    def connect_after(
        self,
        detailed_signal: str | Signal,
        handler: typing.Callable[..., typing.Any],
        *args: typing.Any,
    ) -> int: ...
    def connect_data(self, detailed_signal, handler, *data, **kwargs): ...
    def connect_object(self, *args, **kwargs): ...
    def connect_object_after(self, *args, **kwargs): ...
    def disconnect(self, id: int) -> None: ...
    def disconnect_by_func(self, *args, **kwargs): ...
    def emit(self, signal_name: str | Signal, *args: typing.Any) -> None: ...
    def emit_stop_by_name(self, detailed_signal): ...
    def find_property(self, property_name: str) -> ParamSpec: ...
    def force_floating(self, *args, **kargs): ...
    def freeze_notify(self) -> typing.ContextManager[None]: ...
    def get_data(self, *args, **kargs): ...
    def get_properties(self, *args, **kwargs): ...
    def get_property(self, property_name: str) -> typing.Any: ...
    def get_qdata(self, *args, **kargs): ...
    def getv(
        self,
        n_properties: int,
        names: typing.Sequence[str],
        values: typing.Sequence[typing.Any],
    ) -> None: ...
    def handler_block(self, handler_id: int) -> _HandlerBlockManager: ...
    def handler_block_by_func(self, *args, **kwargs): ...
    def handler_disconnect(self, *args, **kwargs): ...
    def handler_is_connected(self, id: int) -> bool: ...
    def handler_unblock(self, *args, **kwargs): ...
    def handler_unblock_by_func(self, *args, **kwargs): ...
    def install_properties(
        self, n_pspecs: int, pspecs: typing.Sequence[ParamSpec]
    ) -> None: ...
    def install_property(self, property_id: int, pspec: ParamSpec) -> None: ...
    def interface_find_property(self, *args, **kargs): ...
    def interface_install_property(self, *args, **kargs): ...
    def interface_list_properties(self, *args, **kargs): ...
    def is_floating(self) -> bool: ...
    def list_properties(self) -> list[ParamSpec]: ...
    @classmethod
    def newv(
        cls,
        object_type: typing.Type[typing.Any],
        n_parameters: int,
        parameters: typing.Sequence[Parameter],
    ) -> Object: ...
    def notify(self, property_name: str) -> None: ...
    def notify_by_pspec(self, *args, **kargs): ...
    def override_property(self, property_id: int, name: str) -> None: ...
    def ref(self, *args, **kargs): ...
    def ref_sink(self, *args, **kargs): ...
    def replace_data(self, *args, **kargs): ...
    def replace_qdata(self, *args, **kargs): ...
    def run_dispose(self) -> None: ...
    def set_data(self, *args, **kargs): ...
    def set_properties(self, *args, **kwargs): ...
    def set_property(self, property_name: str, value: object) -> None: ...
    def steal_data(self, *args, **kargs): ...
    def steal_qdata(self, *args, **kargs): ...
    def stop_emission(self, detailed_signal): ...
    def stop_emission_by_name(self, detailed_signal: str) -> None: ...
    def thaw_notify(self) -> None: ...
    def unref(self, *args, **kargs): ...
    def watch_closure(self, *args, **kargs): ...
    def weak_ref(
        self, callback: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> None: ...

# override
class GObject(Object): ...

class GObjectWeakRef:
    """
    A GObject weak reference
    """
    def unref(self, /): ...  # FIXME Function

class GParamSpec:
    """
    :Constructors:

    ::

        ParamSpec(**properties)
    """

    g_type_instance: TypeInstance = ...
    name: str = ...
    flags: ParamFlags = ...
    value_type: typing.Type[typing.Any] = ...
    owner_type: typing.Type[typing.Any] = ...
    _nick: str = ...
    _blurb: str = ...
    qdata: GLib.Data = ...
    ref_count: int = ...
    param_id: int = ...
    def blurb(fget): ...  # FIXME Function
    def do_finalize(self) -> None: ...
    def do_get_property(self, pspec): ...  # FIXME Function
    def do_set_property(self, pspec, value): ...  # FIXME Function
    def do_value_is_valid(self, value: typing.Any) -> bool: ...
    def do_value_set_default(self, value: typing.Any) -> None: ...
    def do_value_validate(self, value: typing.Any) -> bool: ...
    def do_values_cmp(self, value1: typing.Any, value2: typing.Any) -> int: ...
    def get_blurb(self) -> typing.Optional[str]: ...
    def get_default_value(self) -> typing.Any: ...
    def get_name(self) -> str: ...
    def get_name_quark(self) -> int: ...
    def get_nick(self) -> str: ...
    def get_qdata(self, quark: int) -> None: ...
    def get_redirect_target(self) -> typing.Optional[ParamSpec]: ...
    @staticmethod
    def is_valid_name(name: str) -> bool: ...
    def nick(fget): ...  # FIXME Function
    def set_qdata(self, quark: int, data: None) -> None: ...
    def sink(self) -> None: ...
    def steal_qdata(self, quark: int) -> None: ...

class GPointer: ...

class GType:
    children = ...  # FIXME Constant
    depth = ...  # FIXME Constant
    fundamental = ...  # FIXME Constant
    interfaces = ...  # FIXME Constant
    name = ...  # FIXME Constant
    parent = ...  # FIXME Constant
    pytype = ...  # FIXME Constant

    def from_name(self, *args, **kwargs): ...  # FIXME Function
    def has_value_table(self, /): ...  # FIXME Function
    def is_a(self, *args, **kwargs): ...  # FIXME Function
    def is_abstract(self, /): ...  # FIXME Function
    def is_classed(self, /): ...  # FIXME Function
    def is_deep_derivable(self, /): ...  # FIXME Function
    def is_derivable(self, /): ...  # FIXME Function
    def is_instantiatable(self, /): ...  # FIXME Function
    def is_interface(self, /): ...  # FIXME Function
    def is_value_abstract(self, /): ...  # FIXME Function
    def is_value_type(self, /): ...  # FIXME Function

class HashTable(GBoxed): ...
class Hmac(GBoxed): ...

class IOChannel(GBoxed):
    """
    :Constructors:

    ::

        IOChannel()
        new_file(filename:str, mode:str) -> GLib.IOChannel
        unix_new(fd:int) -> GLib.IOChannel
    """

    ref_count: int = ...
    funcs: GLib.IOFuncs = ...
    encoding: str = ...
    read_cd: None = ...
    write_cd: None = ...
    line_term: str = ...
    line_term_len: int = ...
    buf_size: int = ...
    read_buf: GLib.String = ...
    encoded_read_buf: GLib.String = ...
    write_buf: GLib.String = ...
    partial_write_buf: list[int] = ...
    use_buffer: int = ...
    do_encode: int = ...
    close_on_unref: int = ...
    is_readable: int = ...
    is_writeable: int = ...
    is_seekable: int = ...
    reserved1: None = ...
    reserved2: None = ...
    _whence_map = ...  # FIXME Constant

    def add_watch(
        self, condition, callback, *user_data, priority=0
    ): ...  # FIXME Function
    def close(self) -> None: ...
    @staticmethod
    def error_from_errno(en: int) -> GLib.IOChannelError: ...
    @staticmethod
    def error_quark() -> int: ...
    def flush(self) -> GLib.IOStatus: ...
    def get_buffer_condition(self) -> GLib.IOCondition: ...
    def get_buffer_size(self) -> int: ...
    def get_buffered(self) -> bool: ...
    def get_close_on_unref(self) -> bool: ...
    def get_encoding(self) -> str: ...
    def get_flags(self) -> GLib.IOFlags: ...
    def get_line_term(self) -> typing.Tuple[str, int]: ...
    def init(self) -> None: ...
    @classmethod
    def new_file(cls, filename: str, mode: str) -> IOChannel: ...
    def read(self, max_count=-1): ...  # FIXME Function
    def read_chars(self, max_count=-1): ...  # FIXME Function
    def read_line(self) -> typing.Tuple[GLib.IOStatus, str, int, int]: ...
    def read_line_string(
        self, buffer: GLib.String, terminator_pos: typing.Optional[int] = None
    ) -> GLib.IOStatus: ...
    def read_to_end(self) -> typing.Tuple[GLib.IOStatus, bytes]: ...
    def read_unichar(self) -> typing.Tuple[GLib.IOStatus, str]: ...
    def readline(self, size_hint=-1): ...  # FIXME Function
    def readlines(self, size_hint=-1): ...  # FIXME Function
    def ref(self) -> GLib.IOChannel: ...
    def seek(self, offset, whence=0): ...  # FIXME Function
    def seek_position(self, offset: int, type: GLib.SeekType) -> GLib.IOStatus: ...
    def set_buffer_size(self, size: int) -> None: ...
    def set_buffered(self, buffered: bool) -> None: ...
    def set_close_on_unref(self, do_close: bool) -> None: ...
    def set_encoding(self, encoding: typing.Optional[str] = None) -> GLib.IOStatus: ...
    def set_flags(self, flags: GLib.IOFlags) -> GLib.IOStatus: ...
    def set_line_term(self, line_term: typing.Optional[str], length: int) -> None: ...
    def shutdown(self, flush: bool) -> GLib.IOStatus: ...
    def unix_get_fd(self) -> int: ...
    @classmethod
    def unix_new(cls, fd: int) -> IOChannel: ...
    def unref(self) -> None: ...
    def write(self, buf, buflen=-1): ...  # FIXME Function
    def write_chars(
        self, buf: typing.Sequence[int], count: int
    ) -> typing.Tuple[GLib.IOStatus, int]: ...
    def write_unichar(self, thechar: str) -> GLib.IOStatus: ...
    def writelines(self, lines): ...  # FIXME Function

class Idle(GBoxed):
    """
    :Constructors:

    ::

        Source()
        new(source_funcs:GLib.SourceFuncs, struct_size:int) -> GLib.Source
    """

    callback_data: None = ...
    callback_funcs: GLib.SourceCallbackFuncs = ...
    source_funcs: GLib.SourceFuncs = ...
    ref_count: int = ...
    context: GLib.MainContext = ...
    priority: int = ...
    flags: int = ...
    source_id: int = ...
    poll_fds: list[None] = ...
    prev: GLib.Source = ...
    next: GLib.Source = ...
    name: str = ...
    priv: GLib.SourcePrivate = ...
    can_recurse = ...  # FIXME Constant

    def add_child_source(self, child_source: GLib.Source) -> None: ...
    def add_poll(self, fd: GLib.PollFD) -> None: ...
    def add_unix_fd(self, fd: int, events: GLib.IOCondition) -> None: ...
    def attach(self, context: typing.Optional[GLib.MainContext] = None) -> int: ...
    def destroy(self) -> None: ...
    def finalize(self): ...  # FIXME Function
    def get_can_recurse(self) -> bool: ...
    def get_context(self) -> typing.Optional[GLib.MainContext]: ...
    def get_current_time(self): ...  # FIXME Function
    def get_id(self) -> int: ...
    def get_name(self) -> typing.Optional[str]: ...
    def get_priority(self) -> int: ...
    def get_ready_time(self) -> int: ...
    def get_time(self) -> int: ...
    def is_destroyed(self) -> bool: ...
    def modify_unix_fd(self, tag: None, new_events: GLib.IOCondition) -> None: ...
    @classmethod
    def new(cls, source_funcs: GLib.SourceFuncs, struct_size: int) -> Source: ...
    def query_unix_fd(self, tag: None) -> GLib.IOCondition: ...
    def ref(self) -> GLib.Source: ...
    @staticmethod
    def remove(tag: int) -> bool: ...
    @staticmethod
    def remove_by_funcs_user_data(funcs: GLib.SourceFuncs, user_data: None) -> bool: ...
    @staticmethod
    def remove_by_user_data(user_data: None) -> bool: ...
    def remove_child_source(self, child_source: GLib.Source) -> None: ...
    def remove_poll(self, fd: GLib.PollFD) -> None: ...
    def remove_unix_fd(self, tag: None) -> None: ...
    def set_callback(self, fn, user_data=None): ...  # FIXME Function
    def set_callback_indirect(
        self, callback_data: None, callback_funcs: GLib.SourceCallbackFuncs
    ) -> None: ...
    def set_can_recurse(self, can_recurse: bool) -> None: ...
    def set_funcs(self, funcs: GLib.SourceFuncs) -> None: ...
    def set_name(self, name: str) -> None: ...
    @staticmethod
    def set_name_by_id(tag: int, name: str) -> None: ...
    def set_priority(self, priority: int) -> None: ...
    def set_ready_time(self, ready_time: int) -> None: ...
    def set_static_name(self, name: str) -> None: ...
    def unref(self) -> None: ...

class InitiallyUnowned(Object):
    """
    :Constructors:

    ::

        InitiallyUnowned(**properties)

    Object GInitiallyUnowned

    Signals from GObject:
      notify (GParam)
    """

    g_type_instance: TypeInstance = ...
    ref_count: int = ...
    qdata: GLib.Data = ...

class InitiallyUnownedClass(GPointer):
    """
    :Constructors:

    ::

        InitiallyUnownedClass()
    """

    g_type_class: TypeClass = ...
    construct_properties: list[None] = ...
    constructor: None = ...
    set_property: typing.Callable[[Object, int, typing.Any, ParamSpec], None] = ...
    get_property: typing.Callable[[Object, int, typing.Any, ParamSpec], None] = ...
    dispose: typing.Callable[[Object], None] = ...
    finalize: typing.Callable[[Object], None] = ...
    dispatch_properties_changed: typing.Callable[[Object, int, ParamSpec], None] = ...
    notify: typing.Callable[[Object, ParamSpec], None] = ...
    constructed: typing.Callable[[Object], None] = ...
    flags: int = ...
    n_construct_properties: int = ...
    pspecs: None = ...
    n_pspecs: int = ...
    pdummy: list[None] = ...

class InterfaceInfo(GPointer):
    """
    :Constructors:

    ::

        InterfaceInfo()
    """

    interface_init: typing.Callable[[TypeInterface, None], None] = ...
    interface_finalize: typing.Callable[[TypeInterface, None], None] = ...
    interface_data: None = ...

class KeyFile(GBoxed): ...

class MainContext(GBoxed):
    """
    :Constructors:

    ::

        new() -> GLib.MainContext
        new_with_flags(flags:GLib.MainContextFlags) -> GLib.MainContext
    """
    def acquire(self) -> bool: ...
    def add_poll(self, fd: GLib.PollFD, priority: int) -> None: ...
    def check(self, max_priority: int, fds: typing.Sequence[GLib.PollFD]) -> bool: ...
    @staticmethod
    def default() -> GLib.MainContext: ...
    def dispatch(self) -> None: ...
    def find_source_by_funcs_user_data(
        self, funcs: GLib.SourceFuncs, user_data: None
    ) -> GLib.Source: ...
    def find_source_by_id(self, source_id: int) -> GLib.Source: ...
    def find_source_by_user_data(self, user_data: None) -> GLib.Source: ...
    @staticmethod
    def get_thread_default() -> typing.Optional[GLib.MainContext]: ...
    def invoke_full(
        self, priority: int, function: typing.Callable[..., bool], *data: typing.Any
    ) -> None: ...
    def is_owner(self) -> bool: ...
    def iteration(self, may_block=True): ...  # FIXME Function
    @classmethod
    def new(cls) -> MainContext: ...
    @classmethod
    def new_with_flags(cls, flags: GLib.MainContextFlags) -> MainContext: ...
    def pending(self) -> bool: ...
    def pop_thread_default(self) -> None: ...
    def prepare(self) -> typing.Tuple[bool, int]: ...
    def push_thread_default(self) -> None: ...
    def pusher_new(self) -> None: ...
    # override
    def query(
        self, max_priority: int
    ) -> typing.Tuple[int, list[GLib.PollFD]]: ...  # FIXME Function
    def ref(self) -> GLib.MainContext: ...
    @staticmethod
    def ref_thread_default() -> GLib.MainContext: ...
    def release(self) -> None: ...
    def remove_poll(self, fd: GLib.PollFD) -> None: ...
    def unref(self) -> None: ...
    def wait(self, cond: GLib.Cond, mutex: GLib.Mutex) -> bool: ...
    def wakeup(self) -> None: ...

class MainLoop(GBoxed):
    """
    :Constructors:

    ::

        new(context:GLib.MainContext=None, is_running:bool) -> GLib.MainLoop
    """
    def get_context(self) -> GLib.MainContext: ...
    def is_running(self) -> bool: ...
    @classmethod
    def new(
        cls, context: typing.Optional[GLib.MainContext], is_running: bool
    ) -> MainLoop: ...
    def quit(self) -> None: ...
    def ref(self) -> GLib.MainLoop: ...
    def run(self): ...  # FIXME Function
    def unref(self) -> None: ...

class MappedFile(GBoxed): ...
class MarkupParseContext(GBoxed): ...
class MatchInfo(GBoxed): ...

# override
class Object:
    """
    :Constructors:

    ::

        Object(**properties)
        newv(object_type:GType, parameters:list) -> GObject.Object

    Object GObject

    Signals from GObject:
      notify (GParam)
    """

    class Props: ...
    props: Props = ...
    g_type_instance: TypeInstance = ...
    ref_count: int = ...
    qdata: GLib.Data = ...

    def __init__(self, **kwargs: typing.Any) -> None: ...
    def bind_property(
        self,
        source_property: str,
        target: Object,
        target_property: str,
        flags: BindingFlags = BindingFlags.DEFAULT,
        transform_to: typing.Optional[typing.Callable[..., typing.Any]] = None,
        transform_from: typing.Optional[typing.Callable[..., typing.Any]] = None,
        user_data: typing.Optional[typing.Any] = None,
    ) -> Binding: ...
    def bind_property_full(self, *args, **kargs): ...
    def chain(self, *args, **kwargs): ...
    def compat_control(self, *args, **kargs): ...
    def connect(
        self,
        detailed_signal: str | Signal,
        handler: typing.Callable[..., typing.Any],
        *args: typing.Any,
    ) -> int: ...
    def connect_after(
        self,
        detailed_signal: str | Signal,
        handler: typing.Callable[..., typing.Any],
        *args: typing.Any,
    ) -> int: ...
    def connect_data(self, detailed_signal, handler, *data, **kwargs): ...
    def connect_object(self, *args, **kwargs): ...
    def connect_object_after(self, *args, **kwargs): ...
    def disconnect(self, id: int) -> None: ...
    def disconnect_by_func(self, handler: typing.Callable[..., typing.Any]) -> None: ...
    def emit(self, signal_name: str | Signal, *args: typing.Any) -> typing.Any: ...
    def emit_stop_by_name(self, detailed_signal): ...
    def find_property(self, property_name: str) -> ParamSpec: ...
    def force_floating(self, *args, **kargs): ...
    def freeze_notify(self) -> typing.ContextManager[None]: ...
    def get_data(self, *args, **kargs): ...
    def get_properties(self, *args, **kwargs): ...
    def get_property(self, property_name: str) -> typing.Any: ...
    def get_qdata(self, *args, **kargs): ...
    def getv(
        self, names: typing.Sequence[str], values: typing.Sequence[typing.Any]
    ) -> None: ...
    def handler_block(self, handler_id: int) -> _HandlerBlockManager: ...
    def handler_block_by_func(self, *args, **kwargs): ...
    def handler_disconnect(*args, **kwargs): ...
    def handler_is_connected(self, id: int) -> bool: ...
    def handler_unblock(*args, **kwargs): ...
    def handler_unblock_by_func(self, *args, **kwargs): ...
    def install_properties(self, pspecs: typing.Sequence[ParamSpec]) -> None: ...
    def install_property(self, property_id: int, pspec: ParamSpec) -> None: ...
    def interface_find_property(self, *args, **kargs): ...
    def interface_install_property(self, *args, **kargs): ...
    def interface_list_properties(self, *args, **kargs): ...
    def is_floating(self) -> bool: ...
    def list_properties(self) -> list[ParamSpec]: ...
    @classmethod
    def newv(
        cls, object_type: typing.Type[Any], parameters: typing.Sequence[Parameter]
    ) -> Object: ...
    def notify(self, property_name: str) -> None: ...
    def notify_by_pspec(self, *args, **kargs): ...
    def override_property(self, property_id: int, name: str) -> None: ...
    def ref(self, *args, **kargs): ...
    def ref_sink(self, *args, **kargs): ...
    def replace_data(self, *args, **kargs): ...
    def replace_qdata(self, *args, **kargs): ...
    def run_dispose(self) -> None: ...
    def set_data(self, *args, **kargs): ...
    def set_properties(self, *args, **kwargs): ...
    def set_property(self, property_name: str, value: object) -> None: ...
    def steal_data(self, *args, **kargs): ...
    def steal_qdata(self, *args, **kargs): ...
    def stop_emission(self, detailed_signal): ...
    def stop_emission_by_name(self, detailed_signal: str) -> None: ...
    def thaw_notify(self) -> None: ...
    def unref(self, *args, **kargs): ...
    def watch_closure(self, *args, **kargs): ...
    def weak_ref(
        self, callback: typing.Callable[..., typing.Any], *args: typing.Any
    ) -> None: ...

class ObjectClass(GPointer):
    """
    :Constructors:

    ::

        ObjectClass()
    """

    g_type_class: TypeClass = ...
    construct_properties: list[None] = ...
    constructor: None = ...
    set_property: typing.Callable[[Object, int, typing.Any, ParamSpec], None] = ...
    get_property: typing.Callable[[Object, int, typing.Any, ParamSpec], None] = ...
    dispose: typing.Callable[[Object], None] = ...
    finalize: typing.Callable[[Object], None] = ...
    dispatch_properties_changed: typing.Callable[[Object, int, ParamSpec], None] = ...
    notify: typing.Callable[[Object, ParamSpec], None] = ...
    constructed: typing.Callable[[Object], None] = ...
    flags: int = ...
    n_construct_properties: int = ...
    pspecs: None = ...
    n_pspecs: int = ...
    pdummy: list[None] = ...
    def find_property(self, property_name: str) -> ParamSpec: ...
    def install_properties(self, pspecs: typing.Sequence[ParamSpec]) -> None: ...
    def install_property(self, property_id: int, pspec: ParamSpec) -> None: ...
    def list_properties(self) -> list[ParamSpec]: ...
    def override_property(self, property_id: int, name: str) -> None: ...

class ObjectConstructParam(GPointer):
    """
    :Constructors:

    ::

        ObjectConstructParam()
    """

    pspec: ParamSpec = ...
    value: typing.Any = ...

class OptionContext:
    def add_group(self, *args, **kwargs): ...  # FIXME Function
    def get_help_enabled(self, /): ...  # FIXME Function
    def get_ignore_unknown_options(self, /): ...  # FIXME Function
    def get_main_group(self, /): ...  # FIXME Function
    def parse(self, *args, **kwargs): ...  # FIXME Function
    def set_help_enabled(self, *args, **kwargs): ...  # FIXME Function
    def set_ignore_unknown_options(self, *args, **kwargs): ...  # FIXME Function
    def set_main_group(self, *args, **kwargs): ...  # FIXME Function

class OptionGroup:
    def add_entries(self, *args, **kwargs): ...  # FIXME Function
    def set_translation_domain(self, *args, **kwargs): ...  # FIXME Function

class ParamSpec:
    """
    :Constructors:

    ::

        ParamSpec(**properties)
    """

    g_type_instance: TypeInstance = ...
    name: str = ...
    flags: ParamFlags = ...
    value_type: typing.Type[typing.Any] = ...
    owner_type: typing.Type[typing.Any] = ...
    _nick: str = ...
    _blurb: str = ...
    qdata: GLib.Data = ...
    ref_count: int = ...
    param_id: int = ...
    def blurb(fget): ...  # FIXME Function
    def do_finalize(self) -> None: ...
    def do_get_property(self, pspec): ...  # FIXME Function
    def do_set_property(self, pspec, value): ...  # FIXME Function
    def do_value_is_valid(self, value: typing.Any) -> bool: ...
    def do_value_set_default(self, value: typing.Any) -> None: ...
    def do_value_validate(self, value: typing.Any) -> bool: ...
    def do_values_cmp(self, value1: typing.Any, value2: typing.Any) -> int: ...
    def get_blurb(self) -> typing.Optional[str]: ...
    def get_default_value(self) -> typing.Any: ...
    def get_name(self) -> str: ...
    def get_name_quark(self) -> int: ...
    def get_nick(self) -> str: ...
    def get_qdata(self, quark: int) -> None: ...
    def get_redirect_target(self) -> typing.Optional[ParamSpec]: ...
    @staticmethod
    def is_valid_name(name: str) -> bool: ...
    def nick(fget): ...  # FIXME Function
    def set_qdata(self, quark: int, data: None) -> None: ...
    def sink(self) -> None: ...
    def steal_qdata(self, quark: int) -> None: ...

class ParamSpecBoolean(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecBoolean(**properties)
    """

    parent_instance: ParamSpec = ...
    default_value: bool = ...

class ParamSpecBoxed(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecBoxed(**properties)
    """

    parent_instance: ParamSpec = ...

class ParamSpecChar(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecChar(**properties)
    """

    parent_instance: ParamSpec = ...
    minimum: int = ...
    maximum: int = ...
    default_value: int = ...

class ParamSpecClass(GPointer):
    """
    :Constructors:

    ::

        ParamSpecClass()
    """

    g_type_class: TypeClass = ...
    value_type: typing.Type[typing.Any] = ...
    finalize: typing.Callable[[ParamSpec], None] = ...
    value_set_default: typing.Callable[[ParamSpec, typing.Any], None] = ...
    value_validate: typing.Callable[[ParamSpec, typing.Any], bool] = ...
    values_cmp: typing.Callable[[ParamSpec, typing.Any, typing.Any], int] = ...
    value_is_valid: typing.Callable[[ParamSpec, typing.Any], bool] = ...
    dummy: list[None] = ...

class ParamSpecDouble(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecDouble(**properties)
    """

    parent_instance: ParamSpec = ...
    minimum: float = ...
    maximum: float = ...
    default_value: float = ...
    epsilon: float = ...

class ParamSpecEnum(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecEnum(**properties)
    """

    parent_instance: ParamSpec = ...
    enum_class: EnumClass = ...
    default_value: int = ...
    def enum_class(fget): ...  # FIXME Function

class ParamSpecFlags(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecFlags(**properties)
    """

    parent_instance: ParamSpec = ...
    flags_class: FlagsClass = ...
    default_value: int = ...
    def flags_class(fget): ...  # FIXME Function

class ParamSpecFloat(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecFloat(**properties)
    """

    parent_instance: ParamSpec = ...
    minimum: float = ...
    maximum: float = ...
    default_value: float = ...
    epsilon: float = ...

class ParamSpecGType(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecGType(**properties)
    """

    parent_instance: ParamSpec = ...
    is_a_type: typing.Type[typing.Any] = ...

class ParamSpecInt(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecInt(**properties)
    """

    parent_instance: ParamSpec = ...
    minimum: int = ...
    maximum: int = ...
    default_value: int = ...

class ParamSpecInt64(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecInt64(**properties)
    """

    parent_instance: ParamSpec = ...
    minimum: int = ...
    maximum: int = ...
    default_value: int = ...

class ParamSpecLong(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecLong(**properties)
    """

    parent_instance: ParamSpec = ...
    minimum: int = ...
    maximum: int = ...
    default_value: int = ...

class ParamSpecObject(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecObject(**properties)
    """

    parent_instance: ParamSpec = ...

class ParamSpecOverride(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecOverride(**properties)
    """

    parent_instance: ParamSpec = ...
    overridden: ParamSpec = ...

class ParamSpecParam(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecParam(**properties)
    """

    parent_instance: ParamSpec = ...

class ParamSpecPointer(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecPointer(**properties)
    """

    parent_instance: ParamSpec = ...

class ParamSpecPool(GPointer):
    def free(self) -> None: ...
    def insert(self, pspec: ParamSpec, owner_type: typing.Type[typing.Any]) -> None: ...
    def list(self, owner_type: typing.Type[typing.Any]) -> list[ParamSpec]: ...
    def list_owned(self, owner_type: typing.Type[typing.Any]) -> list[ParamSpec]: ...
    def lookup(
        self, param_name: str, owner_type: typing.Type[typing.Any], walk_ancestors: bool
    ) -> typing.Optional[ParamSpec]: ...
    def remove(self, pspec: ParamSpec) -> None: ...

class ParamSpecString(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecString(**properties)
    """

    parent_instance: ParamSpec = ...
    default_value: str = ...
    cset_first: str = ...
    cset_nth: str = ...
    substitutor: int = ...
    null_fold_if_empty: int = ...
    ensure_non_null: int = ...

class ParamSpecTypeInfo(GPointer):
    """
    :Constructors:

    ::

        ParamSpecTypeInfo()
    """

    instance_size: int = ...
    n_preallocs: int = ...
    instance_init: typing.Callable[[ParamSpec], None] = ...
    value_type: typing.Type[typing.Any] = ...
    finalize: typing.Callable[[ParamSpec], None] = ...
    value_set_default: typing.Callable[[ParamSpec, typing.Any], None] = ...
    value_validate: typing.Callable[[ParamSpec, typing.Any], bool] = ...
    values_cmp: typing.Callable[[ParamSpec, typing.Any, typing.Any], int] = ...

class ParamSpecUChar(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecUChar(**properties)
    """

    parent_instance: ParamSpec = ...
    minimum: int = ...
    maximum: int = ...
    default_value: int = ...

class ParamSpecUInt(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecUInt(**properties)
    """

    parent_instance: ParamSpec = ...
    minimum: int = ...
    maximum: int = ...
    default_value: int = ...

class ParamSpecUInt64(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecUInt64(**properties)
    """

    parent_instance: ParamSpec = ...
    minimum: int = ...
    maximum: int = ...
    default_value: int = ...

class ParamSpecULong(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecULong(**properties)
    """

    parent_instance: ParamSpec = ...
    minimum: int = ...
    maximum: int = ...
    default_value: int = ...

class ParamSpecUnichar(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecUnichar(**properties)
    """

    parent_instance: ParamSpec = ...
    default_value: str = ...

class ParamSpecValueArray(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecValueArray(**properties)
    """

    parent_instance: ParamSpec = ...
    element_spec: ParamSpec = ...
    fixed_n_elements: int = ...

class ParamSpecVariant(ParamSpec):
    """
    :Constructors:

    ::

        ParamSpecVariant(**properties)
    """

    parent_instance: ParamSpec = ...
    type: GLib.VariantType = ...
    default_value: GLib.Variant = ...
    padding: list[None] = ...

class Parameter(GPointer):
    """
    :Constructors:

    ::

        Parameter()
    """

    name: str = ...
    value: typing.Any = ...

class PatternSpec(GBoxed): ...

class Pid:
    denominator = ...  # FIXME Constant
    imag = ...  # FIXME Constant
    numerator = ...  # FIXME Constant
    real = ...  # FIXME Constant

    def as_integer_ratio(self, /): ...  # FIXME Function
    def bit_count(self, /): ...  # FIXME Function
    def bit_length(self, /): ...  # FIXME Function
    def close(self, /): ...  # FIXME Function
    def conjugate(self, /): ...  # FIXME Function
    def from_bytes(bytes, byteorder="big", *, signed=False): ...  # FIXME Function
    def is_integer(self, /): ...  # FIXME Function
    def to_bytes(
        self, /, length=1, byteorder="big", *, signed=False
    ): ...  # FIXME Function

class PollFD(GBoxed):
    """
    :Constructors:

    ::

        PollFD()
    """

    fd: int = ...
    events: int = ...
    revents: int = ...

# override
class Property:
    def __init__(
        self,
        getter: typing.Optional[typing.Callable[[typing.Any], typing.Any]] = None,
        setter: typing.Optional[typing.Callable[[typing.Any, typing.Any], None]] = None,
        type: typing.Type[typing.Any] | None = None,
        default: typing.Any = None,
        nick: str = "",
        blurb: str = "",
        flags: int = PARAM_READWRITE,
        minimum: typing.Any = None,
        maximum: typing.Any = None,
    ) -> None: ...
    def __call__(self, fget: typing.Callable[[typing.Any], typing.Any]) -> Property: ...
    def __get__(self, instance: Object, klass: typing.Any) -> typing.Any: ...
    def __set__(self, instance: Object, value: typing.Any) -> None: ...
    def get_pspec_args(self): ...
    def getter(self, fget: typing.Callable[[typing.Any], typing.Any]) -> Property: ...
    def setter(
        self, fset: typing.Callable[[typing.Any, typing.Any], None]
    ) -> Property: ...

class PtrArray(GBoxed): ...
class Rand(GBoxed): ...
class Regex(GBoxed): ...

# override
class Signal(str):
    def __new__(cls, name: typing.Any = "", *args, **kargs): ...
    def __init__(
        self,
        name: typing.Any = "",
        func: typing.Optional[typing.Callable] = None,
        flags: int = SIGNAL_RUN_FIRST,
        return_type: typing.Optional[typing.Type[typing.Any]] = None,
        arg_types: typing.Optional[typing.Sequence[typing.Type[typing.Any]]] = None,
        doc: str = "",
        accumulator: typing.Optional[typing.Callable] = None,
        accu_data: typing.Any = None,
    ): ...
    def __call__(self, obj: typing.Any, *args, **kargs): ...
    def __get__(
        self, instance: typing.Optional[Object], owner: typing.Optional[Object] = None
    ) -> BoundSignal: ...
    def copy(self, newName: typing.Optional[str] = None): ...
    def get_signal_args(self): ...

    class BoundSignal(str):
        def __new__(cls, name: str, *args, **kargs): ...
        def __init__(self, signal: Signal, gobj: Object): ...
        def __call__(self, *args, **kargs): ...
        def connect(self, callback: typing.Callable, *args, **kargs) -> int: ...
        def connect_detailed(
            self, callback: typing.Callable, detail: str, *args, **kargs
        ) -> int: ...
        def disconnect(self, handler_id: int): ...
        def emit(self, *args, **kargs): ...

class SignalGroup(Object):
    """
    :Constructors:

    ::

        SignalGroup(**properties)
        new(target_type:GType) -> GObject.SignalGroup

    Object GSignalGroup

    Signals from GSignalGroup:
      bind (GObject)
      unbind ()

    Properties from GSignalGroup:
      target -> GObject: target
      target-type -> GType: target-type

    Signals from GObject:
      notify (GParam)
    """
    class Props(Object.Props):
        target: typing.Optional[Object]
        target_type: typing.Type[typing.Any]

    props: Props = ...
    def __init__(
        self,
        target: typing.Optional[Object] = ...,
        target_type: typing.Type[typing.Any] = ...,
    ) -> None: ...
    def block(self) -> None: ...
    def connect_closure(
        self,
        detailed_signal: str,
        closure: typing.Callable[..., typing.Any],
        after: bool,
    ) -> None: ...
    def connect_data(
        self,
        detailed_signal: str,
        c_handler: typing.Callable[..., None],
        flags: ConnectFlags,
        *data: typing.Any,
    ) -> None: ...
    def connect_swapped(
        self,
        detailed_signal: str,
        c_handler: typing.Callable[..., None],
        *data: typing.Any,
    ) -> None: ...
    def dup_target(self) -> typing.Optional[Object]: ...
    @classmethod
    def new(cls, target_type: typing.Type[typing.Any]) -> SignalGroup: ...
    def set_target(self, target: typing.Optional[Object] = None) -> None: ...
    def unblock(self) -> None: ...

class SignalInvocationHint(GPointer):
    """
    :Constructors:

    ::

        SignalInvocationHint()
    """

    signal_id: int = ...
    detail: int = ...
    run_type: SignalFlags = ...

# override
class SignalOverride(Signal):
    def get_signal_args(self) -> typing.Literal["override"]: ...

class SignalQuery(GPointer):
    """
    :Constructors:

    ::

        SignalQuery()
    """

    signal_id: int = ...
    signal_name: str = ...
    itype: typing.Type[typing.Any] = ...
    signal_flags: SignalFlags = ...
    return_type: typing.Type[typing.Any] = ...
    n_params: int = ...
    param_types: list[typing.Type[typing.Any]] = ...

class Source(GBoxed):
    """
    :Constructors:

    ::

        Source()
        new(source_funcs:GLib.SourceFuncs, struct_size:int) -> GLib.Source
    """

    callback_data: None = ...
    callback_funcs: GLib.SourceCallbackFuncs = ...
    source_funcs: GLib.SourceFuncs = ...
    ref_count: int = ...
    context: GLib.MainContext = ...
    priority: int = ...
    flags: int = ...
    source_id: int = ...
    poll_fds: list[None] = ...
    prev: GLib.Source = ...
    next: GLib.Source = ...
    name: str = ...
    priv: GLib.SourcePrivate = ...
    can_recurse = ...  # FIXME Constant

    def add_child_source(self, child_source: GLib.Source) -> None: ...
    def add_poll(self, fd: GLib.PollFD) -> None: ...
    def add_unix_fd(self, fd: int, events: GLib.IOCondition) -> None: ...
    def attach(self, context: typing.Optional[GLib.MainContext] = None) -> int: ...
    def destroy(self) -> None: ...
    def finalize(self): ...  # FIXME Function
    def get_can_recurse(self) -> bool: ...
    def get_context(self) -> typing.Optional[GLib.MainContext]: ...
    def get_current_time(self): ...  # FIXME Function
    def get_id(self) -> int: ...
    def get_name(self) -> typing.Optional[str]: ...
    def get_priority(self) -> int: ...
    def get_ready_time(self) -> int: ...
    def get_time(self) -> int: ...
    def is_destroyed(self) -> bool: ...
    def modify_unix_fd(self, tag: None, new_events: GLib.IOCondition) -> None: ...
    @classmethod
    def new(cls, source_funcs: GLib.SourceFuncs, struct_size: int) -> Source: ...
    def query_unix_fd(self, tag: None) -> GLib.IOCondition: ...
    def ref(self) -> GLib.Source: ...
    @staticmethod
    def remove(tag: int) -> bool: ...
    @staticmethod
    def remove_by_funcs_user_data(funcs: GLib.SourceFuncs, user_data: None) -> bool: ...
    @staticmethod
    def remove_by_user_data(user_data: None) -> bool: ...
    def remove_child_source(self, child_source: GLib.Source) -> None: ...
    def remove_poll(self, fd: GLib.PollFD) -> None: ...
    def remove_unix_fd(self, tag: None) -> None: ...
    def set_callback(self, fn, user_data=None): ...  # FIXME Function
    def set_callback_indirect(
        self, callback_data: None, callback_funcs: GLib.SourceCallbackFuncs
    ) -> None: ...
    def set_can_recurse(self, can_recurse: bool) -> None: ...
    def set_funcs(self, funcs: GLib.SourceFuncs) -> None: ...
    def set_name(self, name: str) -> None: ...
    @staticmethod
    def set_name_by_id(tag: int, name: str) -> None: ...
    def set_priority(self, priority: int) -> None: ...
    def set_ready_time(self, ready_time: int) -> None: ...
    def set_static_name(self, name: str) -> None: ...
    def unref(self) -> None: ...

class String(GBoxed): ...
class Strv(GBoxed): ...
class StrvBuilder(GBoxed): ...
class Thread(GBoxed): ...
class TimeZone(GBoxed): ...

class Timeout(GBoxed):
    """
    :Constructors:

    ::

        Source()
        new(source_funcs:GLib.SourceFuncs, struct_size:int) -> GLib.Source
    """

    callback_data: None = ...
    callback_funcs: GLib.SourceCallbackFuncs = ...
    source_funcs: GLib.SourceFuncs = ...
    ref_count: int = ...
    context: GLib.MainContext = ...
    priority: int = ...
    flags: int = ...
    source_id: int = ...
    poll_fds: list[None] = ...
    prev: GLib.Source = ...
    next: GLib.Source = ...
    name: str = ...
    priv: GLib.SourcePrivate = ...
    can_recurse = ...  # FIXME Constant

    def add_child_source(self, child_source: GLib.Source) -> None: ...
    def add_poll(self, fd: GLib.PollFD) -> None: ...
    def add_unix_fd(self, fd: int, events: GLib.IOCondition) -> None: ...
    def attach(self, context: typing.Optional[GLib.MainContext] = None) -> int: ...
    def destroy(self) -> None: ...
    def finalize(self): ...  # FIXME Function
    def get_can_recurse(self) -> bool: ...
    def get_context(self) -> typing.Optional[GLib.MainContext]: ...
    def get_current_time(self): ...  # FIXME Function
    def get_id(self) -> int: ...
    def get_name(self) -> typing.Optional[str]: ...
    def get_priority(self) -> int: ...
    def get_ready_time(self) -> int: ...
    def get_time(self) -> int: ...
    def is_destroyed(self) -> bool: ...
    def modify_unix_fd(self, tag: None, new_events: GLib.IOCondition) -> None: ...
    @classmethod
    def new(cls, source_funcs: GLib.SourceFuncs, struct_size: int) -> Source: ...
    def query_unix_fd(self, tag: None) -> GLib.IOCondition: ...
    def ref(self) -> GLib.Source: ...
    @staticmethod
    def remove(tag: int) -> bool: ...
    @staticmethod
    def remove_by_funcs_user_data(funcs: GLib.SourceFuncs, user_data: None) -> bool: ...
    @staticmethod
    def remove_by_user_data(user_data: None) -> bool: ...
    def remove_child_source(self, child_source: GLib.Source) -> None: ...
    def remove_poll(self, fd: GLib.PollFD) -> None: ...
    def remove_unix_fd(self, tag: None) -> None: ...
    def set_callback(self, fn, user_data=None): ...  # FIXME Function
    def set_callback_indirect(
        self, callback_data: None, callback_funcs: GLib.SourceCallbackFuncs
    ) -> None: ...
    def set_can_recurse(self, can_recurse: bool) -> None: ...
    def set_funcs(self, funcs: GLib.SourceFuncs) -> None: ...
    def set_name(self, name: str) -> None: ...
    @staticmethod
    def set_name_by_id(tag: int, name: str) -> None: ...
    def set_priority(self, priority: int) -> None: ...
    def set_ready_time(self, ready_time: int) -> None: ...
    def set_static_name(self, name: str) -> None: ...
    def unref(self) -> None: ...

class Tree(GBoxed): ...

class TypeCValue(GPointer):
    v_double = ...  # FIXME Constant
    v_int = ...  # FIXME Constant
    v_int64 = ...  # FIXME Constant
    v_long = ...  # FIXME Constant
    v_pointer = ...  # FIXME Constant

class TypeClass(GPointer):
    """
    :Constructors:

    ::

        TypeClass()
    """

    g_type: typing.Type[typing.Any] = ...
    def add_private(self, private_size: int) -> None: ...
    @staticmethod
    def adjust_private_offset(g_class: None, private_size_or_offset: int) -> None: ...
    @staticmethod
    def get(type: typing.Type[typing.Any]) -> TypeClass: ...
    def get_private(self, private_type: typing.Type[typing.Any]) -> None: ...
    @staticmethod
    def peek(type: typing.Type[typing.Any]) -> typing.Optional[TypeClass]: ...
    def peek_parent(self) -> TypeClass: ...
    @staticmethod
    def peek_static(type: typing.Type[typing.Any]) -> typing.Optional[TypeClass]: ...
    @staticmethod
    def ref(type: typing.Type[typing.Any]) -> TypeClass: ...
    def unref(self) -> None: ...

class TypeFundamentalInfo(GPointer):
    """
    :Constructors:

    ::

        TypeFundamentalInfo()
    """

    type_flags: TypeFundamentalFlags = ...

class TypeInfo(GPointer):
    """
    :Constructors:

    ::

        TypeInfo()
    """

    class_size: int = ...
    base_init: typing.Callable[[TypeClass], None] = ...
    base_finalize: typing.Callable[[TypeClass], None] = ...
    class_init: typing.Callable[[TypeClass, None], None] = ...
    class_finalize: typing.Callable[[TypeClass, None], None] = ...
    class_data: None = ...
    instance_size: int = ...
    n_preallocs: int = ...
    instance_init: typing.Callable[[TypeInstance, TypeClass], None] = ...
    value_table: TypeValueTable = ...

class TypeInstance(GPointer):
    """
    :Constructors:

    ::

        TypeInstance()
    """

    g_class: TypeClass = ...
    def get_private(self, private_type: typing.Type[typing.Any]) -> None: ...

class TypeInterface(GPointer):
    """
    :Constructors:

    ::

        TypeInterface()
    """

    g_type: typing.Type[typing.Any] = ...
    g_instance_type: typing.Type[typing.Any] = ...
    @staticmethod
    def add_prerequisite(
        interface_type: typing.Type[typing.Any],
        prerequisite_type: typing.Type[typing.Any],
    ) -> None: ...
    @staticmethod
    def get_plugin(
        instance_type: typing.Type[typing.Any], interface_type: typing.Type[typing.Any]
    ) -> TypePlugin: ...
    @staticmethod
    def instantiatable_prerequisite(
        interface_type: typing.Type[typing.Any],
    ) -> typing.Type[typing.Any]: ...
    @staticmethod
    def peek(
        instance_class: TypeClass, iface_type: typing.Type[typing.Any]
    ) -> typing.Optional[TypeInterface]: ...
    def peek_parent(self) -> typing.Optional[TypeInterface]: ...
    @staticmethod
    def prerequisites(
        interface_type: typing.Type[typing.Any],
    ) -> list[typing.Type[typing.Any]]: ...

# override
class TypeModule(TypePlugin):
    parent_instance: Object = ...
    use_count: int = ...
    type_infos: list[None] = ...
    interface_infos: list[None] = ...
    name: str = ...

    def add_interface(
        self,
        instance_type: typing.Type[typing.Any],
        interface_type: typing.Type[typing.Any],
        interface_info: InterfaceInfo,
    ) -> None: ...
    def do_load(self) -> bool: ...
    def do_unload(self) -> None: ...
    def register_enum(
        self, name: str, const_static_values: EnumValue
    ) -> typing.Type[typing.Any]: ...
    def register_flags(
        self, name: str, const_static_values: FlagsValue
    ) -> typing.Type[typing.Any]: ...
    def register_type(
        self,
        parent_type: typing.Type[typing.Any],
        type_name: str,
        type_info: TypeInfo,
        flags: TypeFlags,
    ) -> typing.Type[typing.Any]: ...
    def set_name(self, name: str) -> None: ...
    def unuse(self) -> None: ...
    def use(self) -> bool: ...

class TypeModuleClass(GPointer):
    """
    :Constructors:

    ::

        TypeModuleClass()
    """

    parent_class: ObjectClass = ...
    load: typing.Callable[[TypeModule], bool] = ...
    unload: typing.Callable[[TypeModule], None] = ...
    reserved1: typing.Callable[[], None] = ...
    reserved2: typing.Callable[[], None] = ...
    reserved3: typing.Callable[[], None] = ...
    reserved4: typing.Callable[[], None] = ...

class TypePlugin(Object):
    """
    Interface GTypePlugin
    """
    def complete_interface_info(
        self,
        instance_type: typing.Type[typing.Any],
        interface_type: typing.Type[typing.Any],
        info: InterfaceInfo,
    ) -> None: ...
    def complete_type_info(
        self,
        g_type: typing.Type[typing.Any],
        info: TypeInfo,
        value_table: TypeValueTable,
    ) -> None: ...
    def unuse(self) -> None: ...
    def use(self) -> None: ...

class TypePluginClass(GPointer):
    """
    :Constructors:

    ::

        TypePluginClass()
    """

    base_iface: TypeInterface = ...
    use_plugin: typing.Callable[[TypePlugin], None] = ...
    unuse_plugin: typing.Callable[[TypePlugin], None] = ...
    complete_type_info: typing.Callable[
        [TypePlugin, typing.Type[typing.Any], TypeInfo, TypeValueTable], None
    ] = ...
    complete_interface_info: typing.Callable[
        [TypePlugin, typing.Type[typing.Any], typing.Type[typing.Any], InterfaceInfo],
        None,
    ] = ...

class TypeQuery(GPointer):
    """
    :Constructors:

    ::

        TypeQuery()
    """

    type: typing.Type[typing.Any] = ...
    type_name: str = ...
    class_size: int = ...
    instance_size: int = ...

class TypeValueTable(GPointer):
    """
    :Constructors:

    ::

        TypeValueTable()
    """

    value_init: typing.Callable[[typing.Any], None] = ...
    value_free: typing.Callable[[typing.Any], None] = ...
    value_copy: typing.Callable[[typing.Any], typing.Any] = ...
    value_peek_pointer: typing.Callable[[typing.Any], None] = ...
    collect_format: str = ...
    collect_value: typing.Callable[
        [typing.Any, typing.Sequence[TypeCValue], int], typing.Optional[str]
    ] = ...
    lcopy_format: str = ...
    lcopy_value: typing.Callable[
        [typing.Any, typing.Sequence[TypeCValue], int], typing.Optional[str]
    ] = ...

class Uri(GBoxed): ...

class Value(GBoxed):
    """
    :Constructors:

    ::

        Value()
    """

    g_type: typing.Type[typing.Any] = ...
    data: list[_Value__data__union] = ...
    _Value__g_type = ...  # FIXME Constant

    def copy(self, dest_value: typing.Any) -> None: ...
    def dup_object(self) -> typing.Optional[Object]: ...
    def dup_string(self) -> typing.Optional[str]: ...
    def dup_variant(self) -> typing.Optional[GLib.Variant]: ...
    def fits_pointer(self) -> bool: ...
    def get_boolean(self) -> bool: ...
    def get_boxed(self): ...  # FIXME Function
    def get_char(self) -> int: ...
    def get_double(self) -> float: ...
    def get_enum(self) -> int: ...
    def get_flags(self) -> int: ...
    def get_float(self) -> float: ...
    def get_gtype(self) -> typing.Type[typing.Any]: ...
    def get_int(self) -> int: ...
    def get_int64(self) -> int: ...
    def get_long(self) -> int: ...
    def get_object(self) -> typing.Optional[Object]: ...
    def get_param(self) -> ParamSpec: ...
    def get_pointer(self) -> None: ...
    def get_schar(self) -> int: ...
    def get_string(self) -> typing.Optional[str]: ...
    def get_uchar(self) -> int: ...
    def get_uint(self) -> int: ...
    def get_uint64(self) -> int: ...
    def get_ulong(self) -> int: ...
    def get_value(self): ...  # FIXME Function
    def get_variant(self) -> typing.Optional[GLib.Variant]: ...
    # override
    def init(self, g_type: typing.Any) -> typing.Any: ...
    def init_from_instance(self, instance: TypeInstance) -> None: ...
    def peek_pointer(self) -> None: ...
    def reset(self) -> typing.Any: ...
    def set_boolean(self, v_boolean: bool) -> None: ...
    def set_boxed(self, boxed): ...  # FIXME Function
    def set_boxed_take_ownership(self, v_boxed: None) -> None: ...
    def set_char(self, v_char: int) -> None: ...
    def set_double(self, v_double: float) -> None: ...
    def set_enum(self, v_enum: int) -> None: ...
    def set_flags(self, v_flags: int) -> None: ...
    def set_float(self, v_float: float) -> None: ...
    def set_gtype(self, v_gtype: typing.Type[typing.Any]) -> None: ...
    def set_instance(self, instance: None) -> None: ...
    def set_int(self, v_int: int) -> None: ...
    def set_int64(self, v_int64: int) -> None: ...
    def set_interned_string(self, v_string: typing.Optional[str] = None) -> None: ...
    def set_long(self, v_long: int) -> None: ...
    def set_object(self, v_object: typing.Optional[Object] = None) -> None: ...
    def set_param(self, param: typing.Optional[ParamSpec] = None) -> None: ...
    def set_pointer(self, v_pointer: None) -> None: ...
    def set_schar(self, v_char: int) -> None: ...
    def set_static_boxed(self, v_boxed: None) -> None: ...
    def set_static_string(self, v_string: typing.Optional[str] = None) -> None: ...
    def set_string(self, v_string: typing.Optional[str] = None) -> None: ...
    def set_string_take_ownership(
        self, v_string: typing.Optional[str] = None
    ) -> None: ...
    def set_uchar(self, v_uchar: int) -> None: ...
    def set_uint(self, v_uint: int) -> None: ...
    def set_uint64(self, v_uint64: int) -> None: ...
    def set_ulong(self, v_ulong: int) -> None: ...
    def set_value(self, py_value): ...  # FIXME Function
    def set_variant(self, variant: typing.Optional[GLib.Variant] = None) -> None: ...
    def steal_string(self) -> typing.Optional[str]: ...
    def take_boxed(self, v_boxed: None) -> None: ...
    def take_string(self, v_string: typing.Optional[str] = None) -> None: ...
    def take_variant(self, variant: typing.Optional[GLib.Variant] = None) -> None: ...
    def transform(self, dest_value: typing.Any) -> bool: ...
    @staticmethod
    def type_compatible(
        src_type: typing.Type[typing.Any], dest_type: typing.Type[typing.Any]
    ) -> bool: ...
    @staticmethod
    def type_transformable(
        src_type: typing.Type[typing.Any], dest_type: typing.Type[typing.Any]
    ) -> bool: ...
    def unset(self) -> None: ...

class ValueArray(GBoxed):
    """
    :Constructors:

    ::

        ValueArray()
        new(n_prealloced:int) -> GObject.ValueArray
    """

    n_values: int = ...
    values: typing.Any = ...
    n_prealloced: int = ...
    def append(self, value: typing.Optional[typing.Any] = None) -> ValueArray: ...
    def copy(self) -> ValueArray: ...
    def get_nth(self, index_: int) -> typing.Any: ...
    def insert(
        self, index_: int, value: typing.Optional[typing.Any] = None
    ) -> ValueArray: ...
    @classmethod
    def new(cls, n_prealloced: int) -> ValueArray: ...
    def prepend(self, value: typing.Optional[typing.Any] = None) -> ValueArray: ...
    def remove(self, index_: int) -> ValueArray: ...
    def sort(
        self, compare_func: typing.Callable[..., int], *user_data: typing.Any
    ) -> ValueArray: ...

class VariantBuilder(GBoxed): ...
class VariantDict(GBoxed): ...
class VariantType(GBoxed): ...

class Warning:
    args = ...  # FIXME Constant

    def add_note(self, object, /): ...  # FIXME Function
    def with_traceback(self, object, /): ...  # FIXME Function

class WeakRef(GPointer): ...

class _Value__data__union(GPointer):
    v_double = ...  # FIXME Constant
    v_float = ...  # FIXME Constant
    v_int = ...  # FIXME Constant
    v_int64 = ...  # FIXME Constant
    v_long = ...  # FIXME Constant
    v_pointer = ...  # FIXME Constant
    v_uint = ...  # FIXME Constant
    v_uint64 = ...  # FIXME Constant
    v_ulong = ...  # FIXME Constant

class property:
    """
    Creates a new Property which when used in conjunction with
    GObject subclass will create a Python property accessor for the
    GObject ParamSpec.

    :param callable getter:
        getter to get the value of the property
    :param callable setter:
        setter to set the value of the property
    :param type type:
        type of property
    :param default:
        default value, must match the property type.
    :param str nick:
        short description
    :param str blurb:
        long description
    :param GObject.ParamFlags flags:
        parameter flags
    :keyword minimum:
        minimum allowed value (int, float, long only)
    :keyword maximum:
        maximum allowed value (int, float, long only)

    .. code-block:: python

        class MyObject(GObject.Object):
            prop = GObject.Property(type=str)


        obj = MyObject()
        obj.prop = "value"

        obj.prop  # now is 'value'

    The API is similar to the builtin :py:func:`property`:

    .. code-block:: python

        class AnotherObject(GObject.Object):
            value = 0

            @GObject.Property
            def prop(self):
                "Read only property."
                return 1

            @GObject.Property(type=int)
            def propInt(self):
                "Read-write integer property."
                return self.value

            @propInt.setter
            def propInt(self, value):
                self.value = value
    """

    _default_lookup = ...  # FIXME Constant
    _max_value_lookup = ...  # FIXME Constant
    _min_value_lookup = ...  # FIXME Constant
    _type_from_pytype_lookup = ...  # FIXME Constant

    def get_pspec_args(self): ...  # FIXME Function
    def getter(self, fget): ...  # FIXME Function
    def setter(self, fset): ...  # FIXME Function

class BindingFlags(GFlags):
    BIDIRECTIONAL = 1
    DEFAULT = 0
    INVERT_BOOLEAN = 4
    SYNC_CREATE = 2

class ConnectFlags(GFlags):
    AFTER = 1
    DEFAULT = 0
    SWAPPED = 2

# override
class GFlags(enum.IntFlag):
    __gtype__: GType
    first_value_name: str
    first_value_nick: str
    value_names: list[str]
    value_nicks: list[str]

    def __new__(cls: typing.Type[T], value: int | T) -> T: ...
    def __or__(self: T, other: int | T) -> T: ...
    def __and__(self: T, other: int | T) -> T: ...
    def __xor__(self: T, other: int | T) -> T: ...
    def __ror__(self: T, n: int | T) -> T: ...
    def __rand__(self: T, n: int | T) -> T: ...
    def __rxor__(self: T, n: int | T) -> T: ...

class IOCondition(GFlags):
    ERR = 8
    HUP = 16
    IN = 1
    NVAL = 32
    OUT = 4
    PRI = 2

class ParamFlags(GFlags):
    CONSTRUCT = 4
    CONSTRUCT_ONLY = 8
    DEPRECATED = 2147483648
    EXPLICIT_NOTIFY = 1073741824
    LAX_VALIDATION = 16
    PRIVATE = 32
    READABLE = 1
    READWRITE = 3
    STATIC_BLURB = 128
    STATIC_NAME = 32
    STATIC_NICK = 64
    WRITABLE = 2

class SignalFlags(GFlags):
    ACCUMULATOR_FIRST_RUN = 131072
    ACTION = 32
    DEPRECATED = 256
    DETAILED = 16
    MUST_COLLECT = 128
    NO_HOOKS = 64
    NO_RECURSE = 8
    RUN_CLEANUP = 4
    RUN_FIRST = 1
    RUN_LAST = 2

class SignalMatchType(GFlags):
    CLOSURE = 4
    DATA = 16
    DETAIL = 2
    FUNC = 8
    ID = 1
    UNBLOCKED = 32

class TypeDebugFlags(GFlags):
    INSTANCE_COUNT = 4
    MASK = 7
    NONE = 0
    OBJECTS = 1
    SIGNALS = 2

class TypeFlags(GFlags):
    ABSTRACT = 16
    DEPRECATED = 128
    FINAL = 64
    NONE = 0
    VALUE_ABSTRACT = 32

class TypeFundamentalFlags(GFlags):
    CLASSED = 1
    DEEP_DERIVABLE = 8
    DERIVABLE = 4
    INSTANTIATABLE = 2

# override
class GEnum(enum.IntEnum):
    __gtype__: GType
    value_name: str
    value_nick: str
