import typing

from gi.repository import Gio
from gi.repository import GLib
from gi.repository import GObject
from typing_extensions import Self

T = typing.TypeVar("T")

DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME: str = "gio-desktop-app-info-lookup"

def is_mount_path_system_internal(mount_path: str) -> bool: ...
def is_system_device_path(device_path: str) -> bool: ...
def is_system_fs_type(fs_type: str) -> bool: ...
def mount_at(mount_path: str) -> typing.Tuple[typing.Optional[MountEntry], int]: ...
def mount_compare(mount1: MountEntry, mount2: MountEntry) -> int: ...
def mount_copy(mount_entry: MountEntry) -> MountEntry: ...
def mount_entries_changed_since(time: int) -> bool: ...
def mount_entries_get() -> typing.Tuple[list[MountEntry], int]: ...
def mount_entries_get_from_file(
    table_path: str,
) -> typing.Tuple[typing.Optional[list[MountEntry]], int]: ...
def mount_entry_at(
    mount_path: str,
) -> typing.Tuple[typing.Optional[MountEntry], int]: ...
def mount_entry_for(
    file_path: str,
) -> typing.Tuple[typing.Optional[MountEntry], int]: ...
def mount_for(file_path: str) -> typing.Tuple[typing.Optional[MountEntry], int]: ...
def mount_free(mount_entry: MountEntry) -> None: ...
def mount_get_device_path(mount_entry: MountEntry) -> str: ...
def mount_get_fs_type(mount_entry: MountEntry) -> str: ...
def mount_get_mount_path(mount_entry: MountEntry) -> str: ...
def mount_get_options(mount_entry: MountEntry) -> typing.Optional[str]: ...
def mount_get_root_path(mount_entry: MountEntry) -> typing.Optional[str]: ...
def mount_guess_can_eject(mount_entry: MountEntry) -> bool: ...
def mount_guess_icon(mount_entry: MountEntry) -> Gio.Icon: ...
def mount_guess_name(mount_entry: MountEntry) -> str: ...
def mount_guess_should_display(mount_entry: MountEntry) -> bool: ...
def mount_guess_symbolic_icon(mount_entry: MountEntry) -> Gio.Icon: ...
def mount_is_readonly(mount_entry: MountEntry) -> bool: ...
def mount_is_system_internal(mount_entry: MountEntry) -> bool: ...
def mount_point_at(
    mount_path: str,
) -> typing.Tuple[typing.Optional[MountPoint], int]: ...
def mount_points_changed_since(time: int) -> bool: ...
def mount_points_get() -> typing.Tuple[list[MountPoint], int]: ...
def mount_points_get_from_file(
    table_path: str,
) -> typing.Tuple[typing.Optional[list[MountPoint]], int]: ...
def mounts_changed_since(time: int) -> bool: ...
def mounts_get() -> typing.Tuple[list[MountEntry], int]: ...
def mounts_get_from_file(
    table_path: str,
) -> typing.Tuple[typing.Optional[list[MountEntry]], int]: ...

class DesktopAppInfo(GObject.Object, Gio.AppInfo):
    """
    :Constructors:

    ::

        DesktopAppInfo(**properties)
        new(desktop_id:str) -> GioUnix.DesktopAppInfo or None
        new_from_filename(filename:str) -> GioUnix.DesktopAppInfo or None
        new_from_keyfile(key_file:GLib.KeyFile) -> GioUnix.DesktopAppInfo or None

    Object GDesktopAppInfo

    Properties from GDesktopAppInfo:
      filename -> gchararray: filename

    Signals from GObject:
      notify (GParam)
    """
    class Props(GObject.Object.Props):
        filename: typing.Optional[str]

    props: Props = ...
    def __init__(self, filename: str = ...) -> None: ...
    def get_action_name(self, action_name: str) -> str: ...
    def get_boolean(self, key: str) -> bool: ...
    def get_categories(self) -> typing.Optional[str]: ...
    def get_filename(self) -> typing.Optional[str]: ...
    def get_generic_name(self) -> typing.Optional[str]: ...
    @staticmethod
    def get_implementations(interface: str) -> list[DesktopAppInfo]: ...
    def get_is_hidden(self) -> bool: ...
    def get_keywords(self) -> list[str]: ...
    def get_locale_string(self, key: str) -> typing.Optional[str]: ...
    def get_nodisplay(self) -> bool: ...
    def get_show_in(self, desktop_env: typing.Optional[str] = None) -> bool: ...
    def get_startup_wm_class(self) -> typing.Optional[str]: ...
    def get_string(self, key: str) -> typing.Optional[str]: ...
    def get_string_list(self, key: str) -> list[str]: ...
    def has_key(self, key: str) -> bool: ...
    def launch_action(
        self,
        action_name: str,
        launch_context: typing.Optional[Gio.AppLaunchContext] = None,
    ) -> None: ...
    def launch_uris_as_manager(
        self,
        uris: list[str],
        launch_context: typing.Optional[Gio.AppLaunchContext],
        spawn_flags: GLib.SpawnFlags,
        user_setup: typing.Optional[typing.Callable[..., None]] = None,
        pid_callback: typing.Optional[typing.Callable[..., None]] = None,
        *pid_callback_data: typing.Any,
    ) -> bool: ...
    def launch_uris_as_manager_with_fds(
        self,
        uris: list[str],
        launch_context: typing.Optional[Gio.AppLaunchContext],
        spawn_flags: GLib.SpawnFlags,
        user_setup: typing.Optional[typing.Callable[..., None]],
        pid_callback: typing.Optional[typing.Callable[..., None]],
        stdin_fd: int,
        stdout_fd: int,
        stderr_fd: int,
        *pid_callback_data: typing.Any,
    ) -> bool: ...
    def list_actions(self) -> list[str]: ...
    @classmethod
    def new(cls, desktop_id: str) -> typing.Optional[DesktopAppInfo]: ...
    @classmethod
    def new_from_filename(cls, filename: str) -> typing.Optional[DesktopAppInfo]: ...
    @classmethod
    def new_from_keyfile(
        cls, key_file: GLib.KeyFile
    ) -> typing.Optional[DesktopAppInfo]: ...
    @staticmethod
    def search(search_string: str) -> list[typing.Sequence[str]]: ...
    @staticmethod
    def set_desktop_env(desktop_env: str) -> None: ...

class DesktopAppInfoClass(GObject.GPointer):
    """
    :Constructors:

    ::

        DesktopAppInfoClass()
    """

    parent_class: GObject.ObjectClass = ...

class DesktopAppInfoLookup(GObject.GInterface):
    """
    Interface GDesktopAppInfoLookup

    Signals from GObject:
      notify (GParam)
    """
    def get_default_for_uri_scheme(
        self, uri_scheme: str
    ) -> typing.Optional[Gio.AppInfo]: ...

class DesktopAppInfoLookupIface(GObject.GPointer):
    """
    :Constructors:

    ::

        DesktopAppInfoLookupIface()
    """

    g_iface: GObject.TypeInterface = ...
    get_default_for_uri_scheme: typing.Callable[
        [DesktopAppInfoLookup, str], typing.Optional[Gio.AppInfo]
    ] = ...

class FDMessage(Gio.SocketControlMessage):
    """
    :Constructors:

    ::

        FDMessage(**properties)
        new() -> Gio.SocketControlMessage
        new_with_fd_list(fd_list:Gio.UnixFDList) -> Gio.SocketControlMessage

    Object GUnixFDMessage

    Properties from GUnixFDMessage:
      fd-list -> GUnixFDList: fd-list

    Signals from GObject:
      notify (GParam)
    """
    class Props(Gio.SocketControlMessage.Props):
        fd_list: Gio.UnixFDList

    props: Props = ...
    parent_instance: Gio.SocketControlMessage = ...
    priv: FDMessagePrivate = ...
    def __init__(self, fd_list: Gio.UnixFDList = ...) -> None: ...
    def append_fd(self, fd: int) -> bool: ...
    def get_fd_list(self) -> Gio.UnixFDList: ...
    @classmethod
    def new(cls) -> FDMessage: ...
    @classmethod
    def new_with_fd_list(cls, fd_list: Gio.UnixFDList) -> FDMessage: ...
    def steal_fds(self) -> list[int]: ...

class FDMessageClass(GObject.GPointer):
    """
    :Constructors:

    ::

        FDMessageClass()
    """

    parent_class: Gio.SocketControlMessageClass = ...

class FDMessagePrivate(GObject.GPointer): ...

class FileDescriptorBased(GObject.GInterface):
    """
    Interface GFileDescriptorBased

    Signals from GObject:
      notify (GParam)
    """
    def get_fd(self) -> int: ...

class FileDescriptorBasedIface(GObject.GPointer):
    """
    :Constructors:

    ::

        FileDescriptorBasedIface()
    """

    g_iface: GObject.TypeInterface = ...
    get_fd: typing.Callable[[FileDescriptorBased], int] = ...

class InputStream(Gio.InputStream, Gio.PollableInputStream, FileDescriptorBased):
    """
    :Constructors:

    ::

        InputStream(**properties)
        new(fd:int, close_fd:bool) -> Gio.InputStream

    Object GUnixInputStream

    Properties from GUnixInputStream:
      fd -> gint: fd
      close-fd -> gboolean: close-fd

    Signals from GObject:
      notify (GParam)
    """
    class Props(Gio.InputStream.Props):
        close_fd: bool
        fd: int

    props: Props = ...
    parent_instance: Gio.InputStream = ...
    priv: InputStreamPrivate = ...
    def __init__(self, close_fd: bool = ..., fd: int = ...) -> None: ...
    def get_close_fd(self) -> bool: ...
    def get_fd(self) -> int: ...
    @classmethod
    def new(cls, fd: int, close_fd: bool) -> InputStream: ...
    def set_close_fd(self, close_fd: bool) -> None: ...

class InputStreamClass(GObject.GPointer):
    """
    :Constructors:

    ::

        InputStreamClass()
    """

    parent_class: Gio.InputStreamClass = ...

class InputStreamPrivate(GObject.GPointer): ...

class MountEntry(GObject.GBoxed):
    @staticmethod
    def at(mount_path: str) -> typing.Tuple[typing.Optional[MountEntry], int]: ...
    def compare(self, mount2: MountEntry) -> int: ...
    def copy(self) -> MountEntry: ...
    @staticmethod
    def for_(file_path: str) -> typing.Tuple[typing.Optional[MountEntry], int]: ...
    def free(self) -> None: ...
    def get_device_path(self) -> str: ...
    def get_fs_type(self) -> str: ...
    def get_mount_path(self) -> str: ...
    def get_options(self) -> typing.Optional[str]: ...
    def get_root_path(self) -> typing.Optional[str]: ...
    def guess_can_eject(self) -> bool: ...
    def guess_icon(self) -> Gio.Icon: ...
    def guess_name(self) -> str: ...
    def guess_should_display(self) -> bool: ...
    def guess_symbolic_icon(self) -> Gio.Icon: ...
    def is_readonly(self) -> bool: ...
    def is_system_internal(self) -> bool: ...

class MountMonitor(GObject.Object):
    """
    :Constructors:

    ::

        MountMonitor(**properties)
        new() -> GioUnix.MountMonitor

    Object GUnixMountMonitor

    Signals from GUnixMountMonitor:
      mounts-changed ()
      mountpoints-changed ()

    Signals from GObject:
      notify (GParam)
    """
    @staticmethod
    def get() -> MountMonitor: ...
    @classmethod
    def new(cls) -> MountMonitor: ...
    def set_rate_limit(self, limit_msec: int) -> None: ...

class MountMonitorClass(GObject.GPointer): ...

class MountPoint(GObject.GBoxed):
    @staticmethod
    def at(mount_path: str) -> typing.Tuple[typing.Optional[MountPoint], int]: ...
    def compare(self, mount2: MountPoint) -> int: ...
    def copy(self) -> MountPoint: ...
    def free(self) -> None: ...
    def get_device_path(self) -> str: ...
    def get_fs_type(self) -> str: ...
    def get_mount_path(self) -> str: ...
    def get_options(self) -> typing.Optional[str]: ...
    def guess_can_eject(self) -> bool: ...
    def guess_icon(self) -> Gio.Icon: ...
    def guess_name(self) -> str: ...
    def guess_symbolic_icon(self) -> Gio.Icon: ...
    def is_loopback(self) -> bool: ...
    def is_readonly(self) -> bool: ...
    def is_user_mountable(self) -> bool: ...

class OutputStream(Gio.OutputStream, Gio.PollableOutputStream, FileDescriptorBased):
    """
    :Constructors:

    ::

        OutputStream(**properties)
        new(fd:int, close_fd:bool) -> Gio.OutputStream

    Object GUnixOutputStream

    Properties from GUnixOutputStream:
      fd -> gint: fd
      close-fd -> gboolean: close-fd

    Signals from GObject:
      notify (GParam)
    """
    class Props(Gio.OutputStream.Props):
        close_fd: bool
        fd: int

    props: Props = ...
    parent_instance: Gio.OutputStream = ...
    priv: OutputStreamPrivate = ...
    def __init__(self, close_fd: bool = ..., fd: int = ...) -> None: ...
    def get_close_fd(self) -> bool: ...
    def get_fd(self) -> int: ...
    @classmethod
    def new(cls, fd: int, close_fd: bool) -> OutputStream: ...
    def set_close_fd(self, close_fd: bool) -> None: ...

class OutputStreamClass(GObject.GPointer):
    """
    :Constructors:

    ::

        OutputStreamClass()
    """

    parent_class: Gio.OutputStreamClass = ...

class OutputStreamPrivate(GObject.GPointer): ...
