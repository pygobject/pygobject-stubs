import typing

from gi.repository import GObject

ALLOCATOR_LIST: int = 1
ALLOCATOR_NODE: int = 3
ALLOCATOR_SLIST: int = 2
ALLOC_AND_FREE: int = 2
ALLOC_ONLY: int = 1
ANALYZER_ANALYZING: int = 1
ASCII_DTOSTR_BUF_SIZE: int = 39
ATOMIC_REF_COUNT_INIT: int = 1
BIG_ENDIAN: int = 4321
CSET_A_2_Z: str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
CSET_DIGITS: str = "0123456789"
CSET_a_2_z: str = "abcdefghijklmnopqrstuvwxyz"
C_STD_VERSION: int = 199000
DATALIST_FLAGS_MASK: int = 3
DATE_BAD_DAY: int = 0
DATE_BAD_JULIAN: int = 0
DATE_BAD_YEAR: int = 0
DIR_SEPARATOR: int = 47
DIR_SEPARATOR_S: str = "/"
E: float = 2.718282
GINT16_FORMAT: str = "hi"
GINT16_MODIFIER: str = "h"
GINT32_FORMAT: str = "i"
GINT32_MODIFIER: str = ""
GINT64_FORMAT: str = "li"
GINT64_MODIFIER: str = "l"
GINTPTR_FORMAT: str = "li"
GINTPTR_MODIFIER: str = "l"
GNUC_FUNCTION: str = ""
GNUC_PRETTY_FUNCTION: str = ""
GSIZE_FORMAT: str = "lu"
GSIZE_MODIFIER: str = "l"
GSSIZE_FORMAT: str = "li"
GSSIZE_MODIFIER: str = "l"
GUINT16_FORMAT: str = "hu"
GUINT32_FORMAT: str = "u"
GUINT64_FORMAT: str = "lu"
GUINTPTR_FORMAT: str = "lu"
HAVE_GINT64: int = 1
HAVE_GNUC_VARARGS: int = 1
HAVE_GNUC_VISIBILITY: int = 1
HAVE_GROWING_STACK: int = 0
HAVE_ISO_VARARGS: int = 1
HOOK_FLAG_USER_SHIFT: int = 4
IEEE754_DOUBLE_BIAS: int = 1023
IEEE754_FLOAT_BIAS: int = 127
IO_ERR: int = 8
IO_FLAG_APPEND: int = 1
IO_FLAG_GET_MASK: int = 31
IO_FLAG_IS_READABLE: int = 4
IO_FLAG_IS_SEEKABLE: int = 16
IO_FLAG_IS_WRITEABLE: int = 8
IO_FLAG_MASK: int = 31
IO_FLAG_NONBLOCK: int = 2
IO_FLAG_SET_MASK: int = 3
IO_HUP: int = 16
IO_IN: int = 1
IO_NVAL: int = 32
IO_OUT: int = 4
IO_PRI: int = 2
IO_STATUS_AGAIN: int = 3
IO_STATUS_EOF: int = 2
IO_STATUS_ERROR: int = 0
IO_STATUS_NORMAL: int = 1
KEY_FILE_DESKTOP_GROUP: str = "Desktop Entry"
KEY_FILE_DESKTOP_KEY_ACTIONS: str = "Actions"
KEY_FILE_DESKTOP_KEY_CATEGORIES: str = "Categories"
KEY_FILE_DESKTOP_KEY_COMMENT: str = "Comment"
KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: str = "DBusActivatable"
KEY_FILE_DESKTOP_KEY_EXEC: str = "Exec"
KEY_FILE_DESKTOP_KEY_GENERIC_NAME: str = "GenericName"
KEY_FILE_DESKTOP_KEY_HIDDEN: str = "Hidden"
KEY_FILE_DESKTOP_KEY_ICON: str = "Icon"
KEY_FILE_DESKTOP_KEY_MIME_TYPE: str = "MimeType"
KEY_FILE_DESKTOP_KEY_NAME: str = "Name"
KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: str = "NotShowIn"
KEY_FILE_DESKTOP_KEY_NO_DISPLAY: str = "NoDisplay"
KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: str = "OnlyShowIn"
KEY_FILE_DESKTOP_KEY_PATH: str = "Path"
KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: str = "StartupNotify"
KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: str = "StartupWMClass"
KEY_FILE_DESKTOP_KEY_TERMINAL: str = "Terminal"
KEY_FILE_DESKTOP_KEY_TRY_EXEC: str = "TryExec"
KEY_FILE_DESKTOP_KEY_TYPE: str = "Type"
KEY_FILE_DESKTOP_KEY_URL: str = "URL"
KEY_FILE_DESKTOP_KEY_VERSION: str = "Version"
KEY_FILE_DESKTOP_TYPE_APPLICATION: str = "Application"
KEY_FILE_DESKTOP_TYPE_DIRECTORY: str = "Directory"
KEY_FILE_DESKTOP_TYPE_LINK: str = "Link"
LITTLE_ENDIAN: int = 1234
LN10: float = 2.302585
LN2: float = 0.693147
LOG_2_BASE_10: float = 0.30103
LOG_DOMAIN: int = 0
LOG_FATAL_MASK: int = 5
LOG_LEVEL_USER_SHIFT: int = 8
MAJOR_VERSION: int = 2
MAXDOUBLE: float = 1.7976931348623157e308
MAXFLOAT: float = 3.4028234663852886e38
MAXINT: int = 2147483647
MAXINT16: int = 32767
MAXINT32: int = 2147483647
MAXINT64: int = 9223372036854775807
MAXINT8: int = 127
MAXLONG: int = 9223372036854775807
MAXOFFSET: int = 9223372036854775807
MAXSHORT: int = 32767
MAXSIZE: int = 18446744073709551615
MAXSSIZE: int = 9223372036854775807
MAXUINT: int = 4294967295
MAXUINT16: int = 65535
MAXUINT32: int = 4294967295
MAXUINT64: int = 18446744073709551615
MAXUINT8: int = 255
MAXULONG: int = 18446744073709551615
MAXUSHORT: int = 65535
MICRO_VERSION: int = 5
MINDOUBLE: float = 2.2250738585072014e-308
MINFLOAT: float = 1.1754943508222875e-38
MININT: int = -2147483648
MININT16: int = -32768
MININT32: int = -2147483648
MININT64: int = -9223372036854775808
MININT8: int = -128
MINLONG: int = -9223372036854775808
MINOFFSET: int = -9223372036854775808
MINOR_VERSION: int = 80
MINSHORT: int = -32768
MINSSIZE: int = -9223372036854775808
MODULE_SUFFIX: str = "so"
OPTION_ERROR_BAD_VALUE: int = 1
OPTION_ERROR_FAILED: int = 2
OPTION_ERROR_UNKNOWN_OPTION: int = 0
OPTION_FLAG_FILENAME: int = 16
OPTION_FLAG_HIDDEN: int = 1
OPTION_FLAG_IN_MAIN: int = 2
OPTION_FLAG_NOALIAS: int = 64
OPTION_FLAG_NO_ARG: int = 8
OPTION_FLAG_OPTIONAL_ARG: int = 32
OPTION_FLAG_REVERSE: int = 4
OPTION_REMAINING: str = ""
PDP_ENDIAN: int = 3412
PI: float = 3.141593
PID_FORMAT: str = "i"
PI_2: float = 1.570796
PI_4: float = 0.785398
POLLFD_FORMAT: str = "%d"
PRIORITY_DEFAULT: int = 0
PRIORITY_DEFAULT_IDLE: int = 200
PRIORITY_HIGH: int = -100
PRIORITY_HIGH_IDLE: int = 100
PRIORITY_LOW: int = 300
REF_COUNT_INIT: int = -1
SEARCHPATH_SEPARATOR: int = 58
SEARCHPATH_SEPARATOR_S: str = ":"
SIZEOF_LONG: int = 8
SIZEOF_SIZE_T: int = 8
SIZEOF_SSIZE_T: int = 8
SIZEOF_VOID_P: int = 8
SOURCE_CONTINUE: bool = True
SOURCE_REMOVE: bool = False
SPAWN_CHILD_INHERITS_STDIN: int = 32
SPAWN_DO_NOT_REAP_CHILD: int = 2
SPAWN_FILE_AND_ARGV_ZERO: int = 64
SPAWN_LEAVE_DESCRIPTORS_OPEN: int = 1
SPAWN_SEARCH_PATH: int = 4
SPAWN_STDERR_TO_DEV_NULL: int = 16
SPAWN_STDOUT_TO_DEV_NULL: int = 8
SQRT2: float = 1.414214
STR_DELIMITERS: str = "_-|> <."
SYSDEF_AF_INET: int = 2
SYSDEF_AF_INET6: int = 10
SYSDEF_AF_UNIX: int = 1
SYSDEF_MSG_DONTROUTE: int = 4
SYSDEF_MSG_OOB: int = 1
SYSDEF_MSG_PEEK: int = 2
TEST_OPTION_ISOLATE_DIRS: str = "isolate_dirs"
TIME_SPAN_DAY: int = 86400000000
TIME_SPAN_HOUR: int = 3600000000
TIME_SPAN_MILLISECOND: int = 1000
TIME_SPAN_MINUTE: int = 60000000
TIME_SPAN_SECOND: int = 1000000
UNICHAR_MAX_DECOMPOSITION_LENGTH: int = 18
URI_RESERVED_CHARS_GENERIC_DELIMITERS: str = ":/?#[]@"
URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: str = "!$&'()*+,;="
USEC_PER_SEC: int = 1000000
USER_DIRECTORY_DESKTOP: int = 0
USER_DIRECTORY_DOCUMENTS: int = 1
USER_DIRECTORY_DOWNLOAD: int = 2
USER_DIRECTORY_MUSIC: int = 3
USER_DIRECTORY_PICTURES: int = 4
USER_DIRECTORY_PUBLIC_SHARE: int = 5
USER_DIRECTORY_TEMPLATES: int = 6
USER_DIRECTORY_VIDEOS: int = 7
VA_COPY_AS_ARRAY: int = 1
VERSION_MIN_REQUIRED: int = 2
WIN32_MSG_HANDLE: int = 19981206
_introspection_module = ...  # FIXME Constant
_lock = ...  # FIXME Constant
_namespace: str = "GLib"
_overrides_module = ...  # FIXME Constant
_version: str = "2.0"
glib_version = ...  # FIXME Constant
macro__has_attribute___noreturn__: int = 0
option = ...  # FIXME Constant
pyglib_version = ...  # FIXME Constant

def access(filename: str, mode: int) -> int: ...
def aligned_alloc(n_blocks: int, n_block_bytes: int, alignment: int) -> None: ...
def aligned_alloc0(n_blocks: int, n_block_bytes: int, alignment: int) -> None: ...
def aligned_free(mem: None) -> None: ...
def aligned_free_sized(mem: None, alignment: int, size: int) -> None: ...
def ascii_digit_value(c: int) -> int: ...
def ascii_dtostr(buffer: str, buf_len: int, d: float) -> str: ...
def ascii_formatd(buffer: str, buf_len: int, format: str, d: float) -> str: ...
def ascii_strcasecmp(s1: str, s2: str) -> int: ...
def ascii_strdown(str: str, len: int) -> str: ...
def ascii_string_to_signed(
    str: str, base: int, min: int, max: int
) -> typing.Tuple[bool, int]: ...
def ascii_string_to_unsigned(
    str: str, base: int, min: int, max: int
) -> typing.Tuple[bool, int]: ...
def ascii_strncasecmp(s1: str, s2: str, n: int) -> int: ...
def ascii_strtod(nptr: str) -> typing.Tuple[float, str]: ...
def ascii_strtoll(nptr: str, base: int) -> typing.Tuple[int, str]: ...
def ascii_strtoull(nptr: str, base: int) -> typing.Tuple[int, str]: ...
def ascii_strup(str: str, len: int) -> str: ...
def ascii_tolower(c: int) -> int: ...
def ascii_toupper(c: int) -> int: ...
def ascii_xdigit_value(c: int) -> int: ...
def assert_warning(
    log_domain: str, file: str, line: int, pretty_function: str, expression: str
) -> None: ...
def assertion_message(
    domain: str, file: str, line: int, func: str, message: str
) -> None: ...
def assertion_message_cmpint(
    domain: str,
    file: str,
    line: int,
    func: str,
    expr: str,
    arg1: int,
    cmp: str,
    arg2: int,
    numtype: int,
) -> None: ...
def assertion_message_cmpstr(
    domain: str,
    file: str,
    line: int,
    func: str,
    expr: str,
    arg1: str,
    cmp: str,
    arg2: str,
) -> None: ...
def assertion_message_cmpstrv(
    domain: str,
    file: str,
    line: int,
    func: str,
    expr: str,
    arg1: str,
    arg2: str,
    first_wrong_idx: int,
) -> None: ...
def assertion_message_error(
    domain: str,
    file: str,
    line: int,
    func: str,
    expr: str,
    error: Error,
    error_domain: int,
    error_code: int,
) -> None: ...
def atexit(func: typing.Callable[[], None]) -> None: ...
def atomic_int_add(atomic: int, val: int) -> int: ...
def atomic_int_and(atomic: int, val: int) -> int: ...
def atomic_int_compare_and_exchange(atomic: int, oldval: int, newval: int) -> bool: ...
def atomic_int_compare_and_exchange_full(
    atomic: int, oldval: int, newval: int
) -> typing.Tuple[bool, int]: ...
def atomic_int_dec_and_test(atomic: int) -> bool: ...
def atomic_int_exchange(atomic: int, newval: int) -> int: ...
def atomic_int_exchange_and_add(atomic: int, val: int) -> int: ...
def atomic_int_get(atomic: int) -> int: ...
def atomic_int_inc(atomic: int) -> None: ...
def atomic_int_or(atomic: int, val: int) -> int: ...
def atomic_int_set(atomic: int, newval: int) -> None: ...
def atomic_int_xor(atomic: int, val: int) -> int: ...
def atomic_pointer_add(atomic: None, val: int) -> int: ...
def atomic_pointer_and(atomic: None, val: int) -> int: ...
def atomic_pointer_compare_and_exchange(
    atomic: None, oldval: None, newval: None
) -> bool: ...
def atomic_pointer_compare_and_exchange_full(
    atomic: None, oldval: None, newval: None
) -> typing.Tuple[bool, None]: ...
def atomic_pointer_exchange(atomic: None, newval: None) -> None: ...
def atomic_pointer_get(atomic: None) -> None: ...
def atomic_pointer_or(atomic: None, val: int) -> int: ...
def atomic_pointer_set(atomic: None, newval: None) -> None: ...
def atomic_pointer_xor(atomic: None, val: int) -> int: ...
def atomic_rc_box_acquire(mem_block: None) -> None: ...
def atomic_rc_box_alloc(block_size: int) -> None: ...
def atomic_rc_box_alloc0(block_size: int) -> None: ...
def atomic_rc_box_dup(block_size: int, mem_block: None) -> None: ...
def atomic_rc_box_get_size(mem_block: None) -> int: ...
def atomic_rc_box_release(mem_block: None) -> None: ...
def atomic_rc_box_release_full(
    mem_block: None, clear_func: typing.Callable[[None], None]
) -> None: ...
def atomic_ref_count_compare(arc: int, val: int) -> bool: ...
def atomic_ref_count_dec(arc: int) -> bool: ...
def atomic_ref_count_inc(arc: int) -> None: ...
def atomic_ref_count_init(arc: int) -> None: ...
def base64_decode(text: str) -> bytes: ...
def base64_decode_inplace() -> typing.Tuple[int, bytes]: ...
def base64_encode(data: typing.Optional[typing.Sequence[int]] = None) -> str: ...
def base64_encode_close(break_lines: bool) -> typing.Tuple[int, bytes, int, int]: ...
def base64_encode_step(
    in_: typing.Sequence[int], break_lines: bool
) -> typing.Tuple[int, bytes, int, int]: ...
def basename(file_name: str) -> str: ...
def bit_lock(address: int, lock_bit: int) -> None: ...
def bit_nth_lsf(mask: int, nth_bit: int) -> int: ...
def bit_nth_msf(mask: int, nth_bit: int) -> int: ...
def bit_storage(number: int) -> int: ...
def bit_trylock(address: int, lock_bit: int) -> bool: ...
def bit_unlock(address: int, lock_bit: int) -> None: ...
def blow_chunks() -> None: ...
def bookmark_file_error_quark() -> int: ...
def build_filenamev(args: typing.Sequence[str]) -> str: ...
def build_pathv(separator: str, args: typing.Sequence[str]) -> str: ...
def byte_array_append(array: typing.Sequence[int], data: int, len: int) -> bytes: ...
def byte_array_free(array: typing.Sequence[int], free_segment: bool) -> int: ...
def byte_array_free_to_bytes(array: typing.Sequence[int]) -> Bytes: ...
def byte_array_new() -> bytes: ...
def byte_array_new_take(data: typing.Sequence[int]) -> bytes: ...
def byte_array_prepend(array: typing.Sequence[int], data: int, len: int) -> bytes: ...
def byte_array_ref(array: typing.Sequence[int]) -> bytes: ...
def byte_array_remove_index(array: typing.Sequence[int], index_: int) -> bytes: ...
def byte_array_remove_index_fast(array: typing.Sequence[int], index_: int) -> bytes: ...
def byte_array_remove_range(
    array: typing.Sequence[int], index_: int, length: int
) -> bytes: ...
def byte_array_set_size(array: typing.Sequence[int], length: int) -> bytes: ...
def byte_array_sized_new(reserved_size: int) -> bytes: ...
def byte_array_sort(
    array: typing.Sequence[int], compare_func: typing.Callable[[None, None], int]
) -> None: ...
def byte_array_sort_with_data(
    array: typing.Sequence[int],
    compare_func: typing.Callable[..., int],
    *user_data: typing.Any,
) -> None: ...
def byte_array_steal(array: typing.Sequence[int]) -> typing.Tuple[int, int]: ...
def byte_array_unref(array: typing.Sequence[int]) -> None: ...
def canonicalize_filename(
    filename: str, relative_to: typing.Optional[str] = None
) -> str: ...
def chdir(path: str) -> int: ...
def check_version(
    required_major: int, required_minor: int, required_micro: int
) -> typing.Optional[str]: ...
def checksum_type_get_length(checksum_type: ChecksumType) -> int: ...
def child_watch_add(*args, **kwargs): ...  # FIXME Function
def child_watch_source_new(pid: int) -> Source: ...
def chmod(filename: str, mode: int) -> int: ...
def clear_error() -> None: ...
def close(fd: int) -> bool: ...
def closefrom(lowfd: int) -> int: ...
def compute_checksum_for_bytes(
    checksum_type: ChecksumType, data: Bytes
) -> typing.Optional[str]: ...
def compute_checksum_for_data(
    checksum_type: ChecksumType, data: typing.Sequence[int]
) -> typing.Optional[str]: ...
def compute_checksum_for_string(
    checksum_type: ChecksumType, str: str, length: int
) -> typing.Optional[str]: ...
def compute_hmac_for_bytes(
    digest_type: ChecksumType, key: Bytes, data: Bytes
) -> str: ...
def compute_hmac_for_data(
    digest_type: ChecksumType, key: typing.Sequence[int], data: typing.Sequence[int]
) -> str: ...
def compute_hmac_for_string(
    digest_type: ChecksumType, key: typing.Sequence[int], str: str, length: int
) -> str: ...
def convert(
    str: typing.Sequence[int], to_codeset: str, from_codeset: str
) -> typing.Tuple[bytes, int]: ...
def convert_error_quark() -> int: ...
def convert_with_fallback(
    str: typing.Sequence[int], to_codeset: str, from_codeset: str, fallback: str
) -> typing.Tuple[bytes, int]: ...
def creat(filename: str, mode: int) -> int: ...
def datalist_foreach(
    datalist: Data, func: typing.Callable[..., None], *user_data: typing.Any
) -> None: ...
def datalist_get_data(datalist: Data, key: str) -> None: ...
def datalist_get_flags(datalist: Data) -> int: ...
def datalist_id_get_data(datalist: Data, key_id: int) -> None: ...
def datalist_id_remove_multiple(datalist: Data, keys: typing.Sequence[int]) -> None: ...
def datalist_set_flags(datalist: Data, flags: int) -> None: ...
def datalist_unset_flags(datalist: Data, flags: int) -> None: ...
def dataset_destroy(dataset_location: None) -> None: ...
def dataset_foreach(
    dataset_location: None, func: typing.Callable[..., None], *user_data: typing.Any
) -> None: ...
def dataset_id_get_data(dataset_location: None, key_id: int) -> None: ...
def date_get_days_in_month(month: DateMonth, year: int) -> int: ...
def date_get_monday_weeks_in_year(year: int) -> int: ...
def date_get_sunday_weeks_in_year(year: int) -> int: ...
def date_is_leap_year(year: int) -> bool: ...
def date_strftime(s: str, slen: int, format: str, date: Date) -> int: ...
def date_valid_day(day: int) -> bool: ...
def date_valid_dmy(day: int, month: DateMonth, year: int) -> bool: ...
def date_valid_julian(julian_date: int) -> bool: ...
def date_valid_month(month: DateMonth) -> bool: ...
def date_valid_weekday(weekday: DateWeekday) -> bool: ...
def date_valid_year(year: int) -> bool: ...
def dcgettext(domain: typing.Optional[str], msgid: str, category: int) -> str: ...
def dgettext(domain: typing.Optional[str], msgid: str) -> str: ...
def dir_make_tmp(tmpl: typing.Optional[str] = None) -> str: ...
def direct_equal(v1: None, v2: None) -> bool: ...
def direct_hash(v: None) -> int: ...
def dngettext(
    domain: typing.Optional[str], msgid: str, msgid_plural: str, n: int
) -> str: ...
def double_equal(v1: None, v2: None) -> bool: ...
def double_hash(v: None) -> int: ...
def dpgettext(
    domain: typing.Optional[str], msgctxtid: str, msgidoffset: int
) -> str: ...
def dpgettext2(domain: typing.Optional[str], context: str, msgid: str) -> str: ...
def environ_getenv(
    envp: typing.Optional[typing.Sequence[str]], variable: str
) -> typing.Optional[str]: ...
def environ_setenv(
    envp: typing.Optional[typing.Sequence[str]],
    variable: str,
    value: str,
    overwrite: bool,
) -> list[str]: ...
def environ_unsetenv(
    envp: typing.Optional[typing.Sequence[str]], variable: str
) -> list[str]: ...
def error_domain_register(
    error_type_name: str,
    error_type_private_size: int,
    error_type_init: typing.Callable[[Error], None],
    error_type_copy: typing.Callable[[Error, Error], None],
    error_type_clear: typing.Callable[[Error], None],
) -> int: ...
def error_domain_register_static(
    error_type_name: str,
    error_type_private_size: int,
    error_type_init: typing.Callable[[Error], None],
    error_type_copy: typing.Callable[[Error, Error], None],
    error_type_clear: typing.Callable[[Error], None],
) -> int: ...
def fdwalk_set_cloexec(lowfd: int) -> int: ...
def file_error_from_errno(err_no: int) -> FileError: ...
def file_error_quark() -> int: ...
def file_get_contents(filename: str) -> typing.Tuple[bool, bytes]: ...
def file_open_tmp(tmpl: typing.Optional[str] = None) -> typing.Tuple[int, str]: ...
def file_read_link(filename: str) -> str: ...
def file_set_contents(filename: str, contents: typing.Sequence[int]) -> bool: ...
def file_set_contents_full(
    filename: str,
    contents: typing.Sequence[int],
    flags: FileSetContentsFlags,
    mode: int,
) -> bool: ...
def file_test(filename: str, test: FileTest) -> bool: ...
def filename_display_basename(filename: str) -> str: ...
def filename_display_name(filename: str) -> str: ...
def filename_from_uri(uri: str) -> typing.Tuple[str, str]: ...
def filename_from_utf8(utf8string, len=-1): ...  # FIXME Function
def filename_to_uri(filename: str, hostname: typing.Optional[str] = None) -> str: ...
def filename_to_utf8(opsysstring: str, len: int) -> typing.Tuple[str, int, int]: ...
def find_program_in_path(program: str) -> typing.Optional[str]: ...
def fopen(filename: str, mode: str) -> None: ...
def format_size(size: int) -> str: ...
def format_size_for_display(size: int) -> str: ...
def format_size_full(size: int, flags: FormatSizeFlags) -> str: ...
def free(mem: None) -> None: ...
def free_sized(mem: None, size: int) -> None: ...
def freopen(filename: str, mode: str, stream: None) -> None: ...
def fsync(fd: int) -> int: ...
def get_application_name() -> typing.Optional[str]: ...
def get_charset() -> typing.Tuple[bool, str]: ...
def get_codeset() -> str: ...
def get_console_charset() -> typing.Tuple[bool, str]: ...
def get_current_dir() -> str: ...
def get_current_time(): ...  # FIXME Function
def get_environ() -> list[str]: ...
def get_filename_charsets() -> typing.Tuple[bool, list[str]]: ...
def get_home_dir() -> str: ...
def get_host_name() -> str: ...
def get_language_names() -> list[str]: ...
def get_language_names_with_category(category_name: str) -> list[str]: ...
def get_locale_variants(locale: str) -> list[str]: ...
def get_monotonic_time() -> int: ...
def get_num_processors() -> int: ...
def get_os_info(key_name: str) -> typing.Optional[str]: ...
def get_prgname() -> typing.Optional[str]: ...
def get_real_name() -> str: ...
def get_real_time() -> int: ...
def get_system_config_dirs() -> list[str]: ...
def get_system_data_dirs() -> list[str]: ...
def get_tmp_dir() -> str: ...
def get_user_cache_dir() -> str: ...
def get_user_config_dir() -> str: ...
def get_user_data_dir() -> str: ...
def get_user_name() -> str: ...
def get_user_runtime_dir() -> str: ...
def get_user_special_dir(directory: UserDirectory) -> typing.Optional[str]: ...
def get_user_state_dir() -> str: ...
def getenv(variable: str) -> typing.Optional[str]: ...
def hash_table_add(hash_table: dict[None, None], key: None) -> bool: ...
def hash_table_contains(hash_table: dict[None, None], key: None) -> bool: ...
def hash_table_destroy(hash_table: dict[None, None]) -> None: ...
def hash_table_find(
    hash_table: dict[None, None],
    predicate: typing.Callable[..., bool],
    *user_data: typing.Any,
) -> None: ...
def hash_table_foreach(
    hash_table: dict[None, None],
    func: typing.Callable[..., None],
    *user_data: typing.Any,
) -> None: ...
def hash_table_foreach_remove(
    hash_table: dict[None, None],
    func: typing.Callable[..., bool],
    *user_data: typing.Any,
) -> int: ...
def hash_table_foreach_steal(
    hash_table: dict[None, None],
    func: typing.Callable[..., bool],
    *user_data: typing.Any,
) -> int: ...
def hash_table_insert(hash_table: dict[None, None], key: None, value: None) -> bool: ...
def hash_table_lookup(hash_table: dict[None, None], key: None) -> None: ...
def hash_table_lookup_extended(
    hash_table: dict[None, None], lookup_key: None
) -> typing.Tuple[bool, None, None]: ...
def hash_table_new_similar(other_hash_table: dict[None, None]) -> dict[None, None]: ...
def hash_table_ref(hash_table: dict[None, None]) -> dict[None, None]: ...
def hash_table_remove(hash_table: dict[None, None], key: None) -> bool: ...
def hash_table_remove_all(hash_table: dict[None, None]) -> None: ...
def hash_table_replace(
    hash_table: dict[None, None], key: None, value: None
) -> bool: ...
def hash_table_size(hash_table: dict[None, None]) -> int: ...
def hash_table_steal(hash_table: dict[None, None], key: None) -> bool: ...
def hash_table_steal_all(hash_table: dict[None, None]) -> None: ...
def hash_table_steal_extended(
    hash_table: dict[None, None], lookup_key: None
) -> typing.Tuple[bool, None, None]: ...
def hash_table_unref(hash_table: dict[None, None]) -> None: ...
def hook_destroy(hook_list: HookList, hook_id: int) -> bool: ...
def hook_destroy_link(hook_list: HookList, hook: Hook) -> None: ...
def hook_free(hook_list: HookList, hook: Hook) -> None: ...
def hook_insert_before(
    hook_list: HookList, sibling: typing.Optional[Hook], hook: Hook
) -> None: ...
def hook_insert_sorted(
    hook_list: HookList, hook: Hook, func: typing.Callable[[Hook, Hook], int]
) -> None: ...
def hook_prepend(hook_list: HookList, hook: Hook) -> None: ...
def hook_unref(hook_list: HookList, hook: Hook) -> None: ...
def hostname_is_ascii_encoded(hostname: str) -> bool: ...
def hostname_is_ip_address(hostname: str) -> bool: ...
def hostname_is_non_ascii(hostname: str) -> bool: ...
def hostname_to_ascii(hostname: str) -> typing.Optional[str]: ...
def hostname_to_unicode(hostname: str) -> typing.Optional[str]: ...

# override
def idle_add(func: typing.Callable[..., typing.Any], *args: typing.Any) -> int: ...
def idle_remove_by_data(data: None) -> bool: ...
def idle_source_new() -> Source: ...
def int64_equal(v1: None, v2: None) -> bool: ...
def int64_hash(v: None) -> int: ...
def int_equal(v1: None, v2: None) -> bool: ...
def int_hash(v: None) -> int: ...
def intern_static_string(string: typing.Optional[str] = None) -> str: ...
def intern_string(string: typing.Optional[str] = None) -> str: ...
def io_add_watch(*args, **kwargs): ...  # FIXME Function
def io_channel_error_from_errno(en: int) -> IOChannelError: ...
def io_channel_error_quark() -> int: ...
def io_create_watch(channel: IOChannel, condition: IOCondition) -> Source: ...
def key_file_error_quark() -> int: ...
def list_pop_allocator() -> None: ...
def list_push_allocator(allocator: Allocator) -> None: ...
def listenv() -> list[str]: ...
def locale_from_utf8(utf8string: str, len: int) -> typing.Tuple[bytes, int]: ...
def locale_to_utf8(
    opsysstring: typing.Sequence[int],
) -> typing.Tuple[str, int, int]: ...
def log_default_handler(
    log_domain: typing.Optional[str],
    log_level: LogLevelFlags,
    message: typing.Optional[str],
    unused_data: None,
) -> None: ...
def log_get_debug_enabled() -> bool: ...
def log_remove_handler(log_domain: str, handler_id: int) -> None: ...
def log_set_always_fatal(fatal_mask: LogLevelFlags) -> LogLevelFlags: ...
def log_set_debug_enabled(enabled: bool) -> None: ...
def log_set_fatal_mask(log_domain: str, fatal_mask: LogLevelFlags) -> LogLevelFlags: ...
def log_set_handler(
    log_domain: typing.Optional[str],
    log_levels: LogLevelFlags,
    log_func: typing.Callable[..., None],
    *user_data: typing.Any,
) -> int: ...
def log_set_writer_func(
    func: typing.Optional[typing.Callable[..., LogWriterOutput]] = None,
    *user_data: typing.Any,
) -> None: ...
def log_structured_array(
    log_level: LogLevelFlags, fields: typing.Sequence[LogField]
) -> None: ...
def log_variant(
    log_domain: typing.Optional[str], log_level: LogLevelFlags, fields: Variant
) -> None: ...
def log_writer_default(
    log_level: LogLevelFlags, fields: typing.Sequence[LogField], user_data: None
) -> LogWriterOutput: ...
def log_writer_default_set_debug_domains(
    domains: typing.Optional[str] = None,
) -> None: ...
def log_writer_default_set_use_stderr(use_stderr: bool) -> None: ...
def log_writer_default_would_drop(
    log_level: LogLevelFlags, log_domain: typing.Optional[str] = None
) -> bool: ...
def log_writer_format_fields(
    log_level: LogLevelFlags, fields: typing.Sequence[LogField], use_color: bool
) -> str: ...
def log_writer_is_journald(output_fd: int) -> bool: ...
def log_writer_journald(
    log_level: LogLevelFlags, fields: typing.Sequence[LogField], user_data: None
) -> LogWriterOutput: ...
def log_writer_standard_streams(
    log_level: LogLevelFlags, fields: typing.Sequence[LogField], user_data: None
) -> LogWriterOutput: ...
def log_writer_supports_color(output_fd: int) -> bool: ...
def log_writer_syslog(
    log_level: LogLevelFlags, fields: typing.Sequence[LogField], user_data: None
) -> LogWriterOutput: ...
def lstat(filename: str, buf: StatBuf) -> int: ...
def main_context_default() -> MainContext: ...
def main_context_get_thread_default() -> typing.Optional[MainContext]: ...
def main_context_ref_thread_default() -> MainContext: ...
def main_current_source() -> typing.Optional[Source]: ...
def main_depth() -> int: ...
def malloc(n_bytes: int) -> None: ...
def malloc0(n_bytes: int) -> None: ...
def malloc0_n(n_blocks: int, n_block_bytes: int) -> None: ...
def malloc_n(n_blocks: int, n_block_bytes: int) -> None: ...
def markup_error_quark() -> int: ...

# override
def markup_escape_text(str: typing.Union[str, bytes], length: int = ...) -> str: ...
def mem_chunk_info() -> None: ...
def mem_is_system_malloc() -> bool: ...
def mem_profile() -> None: ...
def mem_set_vtable(vtable: MemVTable) -> None: ...
def memdup(mem: None, byte_size: int) -> None: ...
def memdup2(mem: None, byte_size: int) -> None: ...
def mkdir(filename: str, mode: int) -> int: ...
def mkdir_with_parents(pathname: str, mode: int) -> int: ...
def node_pop_allocator() -> None: ...
def node_push_allocator(allocator: Allocator) -> None: ...
def nullify_pointer(nullify_location: None) -> None: ...
def number_parser_error_quark() -> int: ...
def on_error_query(prg_name: str) -> None: ...
def on_error_stack_trace(prg_name: str) -> None: ...
def once_init_enter() -> typing.Tuple[bool, None]: ...
def once_init_enter_impl(location: int) -> bool: ...
def once_init_enter_pointer(location: None) -> bool: ...
def once_init_leave(result: int) -> None: ...
def once_init_leave_pointer(location: None, result: None) -> None: ...
def open(filename: str, flags: int, mode: int) -> int: ...
def option_error_quark() -> int: ...
def parse_debug_string(
    string: typing.Optional[str], keys: typing.Sequence[DebugKey]
) -> int: ...
def path_buf_equal(v1: None, v2: None) -> bool: ...
def path_get_basename(file_name: str) -> str: ...
def path_get_dirname(file_name: str) -> str: ...
def path_is_absolute(file_name: str) -> bool: ...
def path_skip_root(file_name: str) -> typing.Optional[str]: ...
def pattern_match_simple(pattern: str, string: str) -> bool: ...
def pointer_bit_lock(address: None, lock_bit: int) -> None: ...
def pointer_bit_lock_and_get(address: None, lock_bit: int) -> int: ...
def pointer_bit_lock_mask_ptr(
    ptr: None, lock_bit: int, set: bool, preserve_mask: int, preserve_ptr: None
) -> None: ...
def pointer_bit_trylock(address: None, lock_bit: int) -> bool: ...
def pointer_bit_unlock(address: None, lock_bit: int) -> None: ...
def pointer_bit_unlock_and_set(
    address: None, lock_bit: int, ptr: None, preserve_mask: int
) -> None: ...
def poll(fds: PollFD, nfds: int, timeout: int) -> int: ...
def prefix_error_literal(prefix: str) -> Error: ...
def propagate_error(src: Error) -> Error: ...
def qsort_with_data(
    pbase: None,
    total_elems: int,
    size: int,
    compare_func: typing.Callable[..., int],
    *user_data: typing.Any,
) -> None: ...
def quark_from_static_string(string: typing.Optional[str] = None) -> int: ...
def quark_from_string(string: typing.Optional[str] = None) -> int: ...
def quark_to_string(quark: int) -> str: ...
def quark_try_string(string: typing.Optional[str] = None) -> int: ...
def random_double() -> float: ...
def random_double_range(begin: float, end: float) -> float: ...
def random_int() -> int: ...
def random_int_range(begin: int, end: int) -> int: ...
def random_set_seed(seed: int) -> None: ...
def rc_box_acquire(mem_block: None) -> None: ...
def rc_box_alloc(block_size: int) -> None: ...
def rc_box_alloc0(block_size: int) -> None: ...
def rc_box_dup(block_size: int, mem_block: None) -> None: ...
def rc_box_get_size(mem_block: None) -> int: ...
def rc_box_release(mem_block: None) -> None: ...
def rc_box_release_full(
    mem_block: None, clear_func: typing.Callable[[None], None]
) -> None: ...
def realloc(mem: None, n_bytes: int) -> None: ...
def realloc_n(mem: None, n_blocks: int, n_block_bytes: int) -> None: ...
def ref_count_compare(rc: int, val: int) -> bool: ...
def ref_count_dec(rc: int) -> bool: ...
def ref_count_inc(rc: int) -> None: ...
def ref_count_init(rc: int) -> None: ...
def ref_string_acquire(str: str) -> str: ...
def ref_string_length(str: str) -> int: ...
def ref_string_new(str: str) -> str: ...
def ref_string_new_intern(str: str) -> str: ...
def ref_string_new_len(str: str, len: int) -> str: ...
def ref_string_release(str: str) -> None: ...
def regex_check_replacement(replacement: str) -> typing.Tuple[bool, bool]: ...
def regex_error_quark() -> int: ...
def regex_escape_nul(string: str, length: int) -> str: ...
def regex_escape_string(string: str, length: int) -> str: ...
def regex_match_simple(
    pattern: str,
    string: str,
    compile_options: RegexCompileFlags,
    match_options: RegexMatchFlags,
) -> bool: ...
def regex_split_simple(
    pattern: str,
    string: str,
    compile_options: RegexCompileFlags,
    match_options: RegexMatchFlags,
) -> list[str]: ...
def reload_user_special_dirs_cache() -> None: ...
def remove(filename: str) -> int: ...
def rename(oldfilename: str, newfilename: str) -> int: ...
def rmdir(filename: str) -> int: ...
def sequence_foreach_range(
    begin: SequenceIter,
    end: SequenceIter,
    func: typing.Callable[..., None],
    *user_data: typing.Any,
) -> None: ...
def sequence_get(iter: SequenceIter) -> None: ...
def sequence_insert_before(iter: SequenceIter, data: None) -> SequenceIter: ...
def sequence_move(src: SequenceIter, dest: SequenceIter) -> None: ...
def sequence_move_range(
    dest: SequenceIter, begin: SequenceIter, end: SequenceIter
) -> None: ...
def sequence_range_get_midpoint(
    begin: SequenceIter, end: SequenceIter
) -> SequenceIter: ...
def sequence_remove(iter: SequenceIter) -> None: ...
def sequence_remove_range(begin: SequenceIter, end: SequenceIter) -> None: ...
def sequence_set(iter: SequenceIter, data: None) -> None: ...
def sequence_sort_changed(
    iter: SequenceIter, cmp_func: typing.Callable[..., int], *cmp_data: typing.Any
) -> None: ...
def sequence_sort_changed_iter(
    iter: SequenceIter, iter_cmp: typing.Callable[..., int], *cmp_data: typing.Any
) -> None: ...
def sequence_swap(a: SequenceIter, b: SequenceIter) -> None: ...
def set_application_name(application_name: str) -> None: ...
def set_error_literal(domain: int, code: int, message: str) -> Error: ...
def set_prgname(prgname: str) -> None: ...
def setenv(variable: str, value: str, overwrite: bool) -> bool: ...
def shell_error_quark() -> int: ...
def shell_parse_argv(command_line: str) -> typing.Tuple[bool, list[str]]: ...
def shell_quote(unquoted_string: str) -> str: ...
def shell_unquote(quoted_string: str) -> str: ...
def slice_alloc(block_size: int) -> None: ...
def slice_alloc0(block_size: int) -> None: ...
def slice_copy(block_size: int, mem_block: None) -> None: ...
def slice_free1(block_size: int, mem_block: None) -> None: ...
def slice_free_chain_with_offset(
    block_size: int, mem_chain: None, next_offset: int
) -> None: ...
def slice_get_config(ckey: SliceConfig) -> int: ...
def slice_get_config_state(ckey: SliceConfig, address: int, n_values: int) -> int: ...
def slice_set_config(ckey: SliceConfig, value: int) -> None: ...
def slist_pop_allocator() -> None: ...
def slist_push_allocator(allocator: Allocator) -> None: ...
def source_remove(tag: int) -> bool: ...
def source_remove_by_funcs_user_data(funcs: SourceFuncs, user_data: None) -> bool: ...
def source_remove_by_user_data(user_data: None) -> bool: ...
def source_set_name_by_id(tag: int, name: str) -> None: ...
def spaced_primes_closest(num: int) -> int: ...
def spawn_async(*args, **kwargs): ...  # FIXME Function
def spawn_async_with_fds(
    working_directory: typing.Optional[str],
    argv: typing.Sequence[str],
    envp: typing.Optional[typing.Sequence[str]],
    flags: SpawnFlags,
    child_setup: typing.Optional[typing.Callable[..., None]],
    stdin_fd: int,
    stdout_fd: int,
    stderr_fd: int,
    *user_data: typing.Any,
) -> typing.Tuple[bool, int]: ...
def spawn_async_with_pipes(
    working_directory: typing.Optional[str],
    argv: typing.Sequence[str],
    envp: typing.Optional[typing.Sequence[str]],
    flags: SpawnFlags,
    child_setup: typing.Optional[typing.Callable[..., None]] = None,
    *user_data: typing.Any,
) -> typing.Tuple[bool, int, int, int, int]: ...
def spawn_async_with_pipes_and_fds(
    working_directory: typing.Optional[str],
    argv: typing.Sequence[str],
    envp: typing.Optional[typing.Sequence[str]],
    flags: SpawnFlags,
    child_setup: typing.Optional[typing.Callable[..., None]],
    stdin_fd: int,
    stdout_fd: int,
    stderr_fd: int,
    source_fds: typing.Optional[typing.Sequence[int]] = None,
    target_fds: typing.Optional[typing.Sequence[int]] = None,
    *user_data: typing.Any,
) -> typing.Tuple[bool, int, int, int, int]: ...
def spawn_check_exit_status(wait_status: int) -> bool: ...
def spawn_check_wait_status(wait_status: int) -> bool: ...
def spawn_close_pid(pid: int) -> None: ...
def spawn_command_line_async(command_line: str) -> bool: ...
def spawn_command_line_sync(
    command_line: str,
) -> typing.Tuple[bool, bytes, bytes, int]: ...
def spawn_error_quark() -> int: ...
def spawn_exit_error_quark() -> int: ...
def spawn_sync(
    working_directory: typing.Optional[str],
    argv: typing.Sequence[str],
    envp: typing.Optional[typing.Sequence[str]],
    flags: SpawnFlags,
    child_setup: typing.Optional[typing.Callable[..., None]] = None,
    *user_data: typing.Any,
) -> typing.Tuple[bool, bytes, bytes, int]: ...
def stat(filename: str, buf: StatBuf) -> int: ...
def stpcpy(dest: str, src: str) -> str: ...
def str_equal(v1: None, v2: None) -> bool: ...
def str_has_prefix(str: str, prefix: str) -> bool: ...
def str_has_suffix(str: str, suffix: str) -> bool: ...
def str_hash(v: None) -> int: ...
def str_is_ascii(str: str) -> bool: ...
def str_match_string(
    search_term: str, potential_hit: str, accept_alternates: bool
) -> bool: ...
def str_to_ascii(str: str, from_locale: typing.Optional[str] = None) -> str: ...
def str_tokenize_and_fold(
    string: str, translit_locale: typing.Optional[str] = None
) -> typing.Tuple[list[str], list[str]]: ...
def strcanon(string: str, valid_chars: str, substitutor: int) -> str: ...
def strcasecmp(s1: str, s2: str) -> int: ...
def strchomp(string: str) -> str: ...
def strchug(string: str) -> str: ...
def strcmp0(
    str1: typing.Optional[str] = None, str2: typing.Optional[str] = None
) -> int: ...
def strcompress(source: str) -> str: ...
def strdelimit(
    string: str, delimiters: typing.Optional[str], new_delimiter: int
) -> str: ...
def strdown(string: str) -> str: ...
def strdup(str: typing.Optional[str] = None) -> str: ...
def strdupv(
    str_array: typing.Optional[typing.Sequence[str]] = None,
) -> typing.Optional[list[str]]: ...
def strerror(errnum: int) -> str: ...
def strescape(source: str, exceptions: typing.Optional[str] = None) -> str: ...
def strfreev(str_array: typing.Optional[typing.Sequence[str]] = None) -> None: ...
def strip_context(msgid: str, msgval: str) -> str: ...
def strjoinv(
    separator: typing.Optional[str], str_array: typing.Sequence[str]
) -> str: ...
def strlcat(dest: str, src: str, dest_size: int) -> int: ...
def strlcpy(dest: str, src: str, dest_size: int) -> int: ...
def strncasecmp(s1: str, s2: str, n: int) -> int: ...
def strndup(str: typing.Optional[str], n: int) -> typing.Optional[str]: ...
def strnfill(length: int, fill_char: int) -> str: ...
def strreverse(string: str) -> str: ...
def strrstr(haystack: str, needle: str) -> str: ...
def strrstr_len(haystack: str, haystack_len: int, needle: str) -> str: ...
def strsignal(signum: int) -> str: ...
def strsplit(string: str, delimiter: str, max_tokens: int) -> list[str]: ...
def strsplit_set(string: str, delimiters: str, max_tokens: int) -> list[str]: ...
def strstr_len(haystack: str, haystack_len: int, needle: str) -> str: ...
def strtod(nptr: str) -> typing.Tuple[float, str]: ...
def strup(string: str) -> str: ...
def strv_contains(strv: typing.Sequence[str], str: str) -> bool: ...
def strv_equal(strv1: typing.Sequence[str], strv2: typing.Sequence[str]) -> bool: ...
def strv_get_type() -> typing.Type: ...
def strv_length(str_array: typing.Sequence[str]) -> int: ...
def test_add_data_func(
    testpath: str, test_data: None, test_func: typing.Callable[..., None]
) -> None: ...
def test_add_data_func_full(
    testpath: str,
    test_data: None,
    test_func: typing.Callable[..., None],
    data_free_func: typing.Callable[[None], None],
) -> None: ...
def test_add_func(testpath: str, test_func: typing.Callable[[], None]) -> None: ...
def test_assert_expected_messages_internal(
    domain: str, file: str, line: int, func: str
) -> None: ...
def test_bug(bug_uri_snippet: str) -> None: ...
def test_bug_base(uri_pattern: str) -> None: ...
def test_disable_crash_reporting() -> None: ...
def test_expect_message(
    log_domain: typing.Optional[str], log_level: LogLevelFlags, pattern: str
) -> None: ...
def test_fail() -> None: ...
def test_failed() -> bool: ...
def test_get_dir(file_type: TestFileType) -> str: ...
def test_get_path() -> str: ...
def test_incomplete(msg: typing.Optional[str] = None) -> None: ...
def test_log_type_name(log_type: TestLogType) -> str: ...
def test_queue_destroy(
    destroy_func: typing.Callable[[None], None], destroy_data: None
) -> None: ...
def test_queue_free(gfree_pointer: None) -> None: ...
def test_rand_double() -> float: ...
def test_rand_double_range(range_start: float, range_end: float) -> float: ...
def test_rand_int() -> int: ...
def test_rand_int_range(begin: int, end: int) -> int: ...
def test_run() -> int: ...
def test_run_suite(suite: TestSuite) -> int: ...
def test_set_nonfatal_assertions() -> None: ...
def test_skip(msg: typing.Optional[str] = None) -> None: ...
def test_subprocess() -> bool: ...
def test_summary(summary: str) -> None: ...
def test_timer_elapsed() -> float: ...
def test_timer_last() -> float: ...
def test_timer_start() -> None: ...
def test_trap_assertions(
    domain: str, file: str, line: int, func: str, assertion_flags: int, pattern: str
) -> None: ...
def test_trap_fork(usec_timeout: int, test_trap_flags: TestTrapFlags) -> bool: ...
def test_trap_has_passed() -> bool: ...
def test_trap_reached_timeout() -> bool: ...
def test_trap_subprocess(
    test_path: typing.Optional[str], usec_timeout: int, test_flags: TestSubprocessFlags
) -> None: ...
def test_trap_subprocess_with_envp(
    test_path: typing.Optional[str],
    envp: typing.Optional[typing.Sequence[str]],
    usec_timeout: int,
    test_flags: TestSubprocessFlags,
) -> None: ...
def thread_error_quark() -> int: ...
def thread_exit(retval: None) -> None: ...
def thread_pool_get_max_idle_time() -> int: ...
def thread_pool_get_max_unused_threads() -> int: ...
def thread_pool_get_num_unused_threads() -> int: ...
def thread_pool_set_max_idle_time(interval: int) -> None: ...
def thread_pool_set_max_unused_threads(max_threads: int) -> None: ...
def thread_pool_stop_unused_threads() -> None: ...
def thread_self() -> Thread: ...
def thread_yield() -> None: ...
def threads_init(): ...  # FIXME Function
def time_val_from_iso8601(iso_date: str) -> typing.Tuple[bool, TimeVal]: ...

# override
def timeout_add(
    interval: int, function: typing.Callable[..., typing.Any], *args: typing.Any
) -> int: ...

# override
def timeout_add_seconds(
    interval: int, function: typing.Callable[..., typing.Any], *args: typing.Any
) -> int: ...
def timeout_source_new(interval: int) -> Source: ...
def timeout_source_new_seconds(interval: int) -> Source: ...
def trash_stack_height(stack_p: TrashStack) -> int: ...
def trash_stack_peek(stack_p: TrashStack) -> None: ...
def trash_stack_pop(stack_p: TrashStack) -> None: ...
def trash_stack_push(stack_p: TrashStack, data_p: None) -> None: ...
def try_malloc(n_bytes: int) -> None: ...
def try_malloc0(n_bytes: int) -> None: ...
def try_malloc0_n(n_blocks: int, n_block_bytes: int) -> None: ...
def try_malloc_n(n_blocks: int, n_block_bytes: int) -> None: ...
def try_realloc(mem: None, n_bytes: int) -> None: ...
def try_realloc_n(mem: None, n_blocks: int, n_block_bytes: int) -> None: ...
def ucs4_to_utf16(str: typing.Sequence[str]) -> typing.Tuple[int, int, int]: ...
def ucs4_to_utf8(str: typing.Sequence[str]) -> typing.Tuple[str, int, int]: ...
def unichar_break_type(c: str) -> UnicodeBreakType: ...
def unichar_combining_class(uc: str) -> int: ...
def unichar_compose(a: str, b: str) -> typing.Tuple[bool, str]: ...
def unichar_decompose(ch: str) -> typing.Tuple[bool, str, str]: ...
def unichar_digit_value(c: str) -> int: ...
def unichar_fully_decompose(
    ch: str, compat: bool, result_len: int
) -> typing.Tuple[int, str]: ...
def unichar_get_mirror_char(ch: str) -> typing.Tuple[bool, str]: ...
def unichar_get_script(ch: str) -> UnicodeScript: ...
def unichar_isalnum(c: str) -> bool: ...
def unichar_isalpha(c: str) -> bool: ...
def unichar_iscntrl(c: str) -> bool: ...
def unichar_isdefined(c: str) -> bool: ...
def unichar_isdigit(c: str) -> bool: ...
def unichar_isgraph(c: str) -> bool: ...
def unichar_islower(c: str) -> bool: ...
def unichar_ismark(c: str) -> bool: ...
def unichar_isprint(c: str) -> bool: ...
def unichar_ispunct(c: str) -> bool: ...
def unichar_isspace(c: str) -> bool: ...
def unichar_istitle(c: str) -> bool: ...
def unichar_isupper(c: str) -> bool: ...
def unichar_iswide(c: str) -> bool: ...
def unichar_iswide_cjk(c: str) -> bool: ...
def unichar_isxdigit(c: str) -> bool: ...
def unichar_iszerowidth(c: str) -> bool: ...
def unichar_to_utf8(c: str) -> typing.Tuple[int, str]: ...
def unichar_tolower(c: str) -> str: ...
def unichar_totitle(c: str) -> str: ...
def unichar_toupper(c: str) -> str: ...
def unichar_type(c: str) -> UnicodeType: ...
def unichar_validate(ch: str) -> bool: ...
def unichar_xdigit_value(c: str) -> int: ...
def unicode_canonical_decomposition(ch: str, result_len: int) -> str: ...
def unicode_canonical_ordering(string: typing.Sequence[str]) -> None: ...
def unicode_script_from_iso15924(iso15924: int) -> UnicodeScript: ...
def unicode_script_to_iso15924(script: UnicodeScript) -> int: ...
def unix_error_quark() -> int: ...
def unix_fd_add_full(
    priority: int,
    fd: int,
    condition: IOCondition,
    function: typing.Callable[..., bool],
    *user_data: typing.Any,
) -> int: ...
def unix_fd_source_new(fd: int, condition: IOCondition) -> Source: ...
def unix_get_passwd_entry(user_name: str) -> None: ...
def unix_open_pipe(fds: typing.Sequence[int], flags: int) -> bool: ...
def unix_set_fd_nonblocking(fd: int, nonblock: bool) -> bool: ...
def unix_signal_add(
    priority: int,
    signum: int,
    handler: typing.Callable[..., bool],
    *user_data: typing.Any,
) -> int: ...
def unix_signal_add_full(
    priority: int,
    signum: int,
    handler: typing.Callable[..., bool],
    *user_data: typing.Any,
) -> int: ...
def unix_signal_source_new(signum: int) -> Source: ...
def unlink(filename: str) -> int: ...
def unsetenv(variable: str) -> None: ...
def uri_build(
    flags: UriFlags,
    scheme: str,
    userinfo: typing.Optional[str],
    host: typing.Optional[str],
    port: int,
    path: str,
    query: typing.Optional[str] = None,
    fragment: typing.Optional[str] = None,
) -> Uri: ...
def uri_build_with_user(
    flags: UriFlags,
    scheme: str,
    user: typing.Optional[str],
    password: typing.Optional[str],
    auth_params: typing.Optional[str],
    host: typing.Optional[str],
    port: int,
    path: str,
    query: typing.Optional[str] = None,
    fragment: typing.Optional[str] = None,
) -> Uri: ...
def uri_error_quark() -> int: ...
def uri_escape_bytes(
    unescaped: typing.Sequence[int], reserved_chars_allowed: typing.Optional[str] = None
) -> str: ...
def uri_escape_string(
    unescaped: str, reserved_chars_allowed: typing.Optional[str], allow_utf8: bool
) -> str: ...
def uri_is_valid(uri_string: str, flags: UriFlags) -> bool: ...
def uri_join(
    flags: UriFlags,
    scheme: typing.Optional[str],
    userinfo: typing.Optional[str],
    host: typing.Optional[str],
    port: int,
    path: str,
    query: typing.Optional[str] = None,
    fragment: typing.Optional[str] = None,
) -> str: ...
def uri_join_with_user(
    flags: UriFlags,
    scheme: typing.Optional[str],
    user: typing.Optional[str],
    password: typing.Optional[str],
    auth_params: typing.Optional[str],
    host: typing.Optional[str],
    port: int,
    path: str,
    query: typing.Optional[str] = None,
    fragment: typing.Optional[str] = None,
) -> str: ...
def uri_list_extract_uris(uri_list: str) -> list[str]: ...
def uri_parse(uri_string: str, flags: UriFlags) -> Uri: ...
def uri_parse_params(
    params: str, length: int, separators: str, flags: UriParamsFlags
) -> dict[str, str]: ...
def uri_parse_scheme(uri: str) -> typing.Optional[str]: ...
def uri_peek_scheme(uri: str) -> typing.Optional[str]: ...
def uri_resolve_relative(
    base_uri_string: typing.Optional[str], uri_ref: str, flags: UriFlags
) -> str: ...
def uri_split(
    uri_ref: str, flags: UriFlags
) -> typing.Tuple[bool, str, str, str, int, str, str, str]: ...
def uri_split_network(
    uri_string: str, flags: UriFlags
) -> typing.Tuple[bool, str, str, int]: ...
def uri_split_with_user(
    uri_ref: str, flags: UriFlags
) -> typing.Tuple[bool, str, str, str, str, str, int, str, str, str]: ...
def uri_unescape_bytes(
    escaped_string: str, length: int, illegal_characters: typing.Optional[str] = None
) -> Bytes: ...
def uri_unescape_segment(
    escaped_string: typing.Optional[str] = None,
    escaped_string_end: typing.Optional[str] = None,
    illegal_characters: typing.Optional[str] = None,
) -> typing.Optional[str]: ...
def uri_unescape_string(
    escaped_string: str, illegal_characters: typing.Optional[str] = None
) -> typing.Optional[str]: ...
def usleep(microseconds: int) -> None: ...
def utf16_to_ucs4(str: typing.Sequence[int]) -> typing.Tuple[str, int, int]: ...
def utf16_to_utf8(str: typing.Sequence[int]) -> typing.Tuple[str, int, int]: ...
def utf8_casefold(str: str, len: int) -> str: ...
def utf8_collate(str1: str, str2: str) -> int: ...
def utf8_collate_key(str: str, len: int) -> str: ...
def utf8_collate_key_for_filename(str: str, len: int) -> str: ...
def utf8_find_next_char(
    p: str, end: typing.Optional[str] = None
) -> typing.Optional[str]: ...
def utf8_find_prev_char(str: str, p: str) -> typing.Optional[str]: ...
def utf8_get_char(p: str) -> str: ...
def utf8_get_char_validated(p: str, max_len: int) -> str: ...
def utf8_make_valid(str: str, len: int) -> str: ...
def utf8_normalize(str: str, len: int, mode: NormalizeMode) -> typing.Optional[str]: ...
def utf8_offset_to_pointer(str: str, offset: int) -> str: ...
def utf8_pointer_to_offset(str: str, pos: str) -> int: ...
def utf8_prev_char(p: str) -> str: ...
def utf8_strchr(p: str, len: int, c: str) -> typing.Optional[str]: ...
def utf8_strdown(str: str, len: int) -> str: ...
def utf8_strlen(p: str, max: int) -> int: ...
def utf8_strncpy(dest: str, src: str, n: int) -> str: ...
def utf8_strrchr(p: str, len: int, c: str) -> typing.Optional[str]: ...
def utf8_strreverse(str: str, len: int) -> str: ...
def utf8_strup(str: str, len: int) -> str: ...
def utf8_substring(str: str, start_pos: int, end_pos: int) -> str: ...
def utf8_to_ucs4(str: str, len: int) -> typing.Tuple[str, int, int]: ...
def utf8_to_ucs4_fast(str: str, len: int) -> typing.Tuple[str, int]: ...
def utf8_to_utf16(str: str, len: int) -> typing.Tuple[int, int, int]: ...
def utf8_truncate_middle(string: str, truncate_length: int) -> str: ...
def utf8_validate(str: typing.Sequence[int]) -> typing.Tuple[bool, str]: ...
def utf8_validate_len(str: typing.Sequence[int]) -> typing.Tuple[bool, str]: ...
def utime(filename: str, utb: None) -> int: ...
def uuid_string_is_valid(str: str) -> bool: ...
def uuid_string_random() -> str: ...
def variant_get_gtype() -> typing.Type: ...
def variant_is_object_path(string: str) -> bool: ...
def variant_is_signature(string: str) -> bool: ...
def variant_parse(
    type: typing.Optional[VariantType],
    text: str,
    limit: typing.Optional[str] = None,
    endptr: typing.Optional[str] = None,
) -> Variant: ...
def variant_parse_error_print_context(error: Error, source_str: str) -> str: ...
def variant_parse_error_quark() -> int: ...
def variant_parser_get_error_quark() -> int: ...
def variant_type_checked_(type_string: str) -> VariantType: ...
def variant_type_string_get_depth_(type_string: str) -> int: ...
def variant_type_string_is_valid(type_string: str) -> bool: ...
def variant_type_string_scan(
    string: str, limit: typing.Optional[str] = None
) -> typing.Tuple[bool, str]: ...

class Allocator(GObject.GPointer):
    def free(self) -> None: ...

class Array(GObject.GBoxed):
    """
    :Constructors:

    ::

        Array()
    """

    data: str = ...
    len: int = ...

class AsyncQueue(GObject.GPointer):
    def length(self) -> int: ...
    def length_unlocked(self) -> int: ...
    def lock(self) -> None: ...
    def pop(self) -> None: ...
    def pop_unlocked(self) -> None: ...
    def push(self, data: None) -> None: ...
    def push_front(self, item: None) -> None: ...
    def push_front_unlocked(self, item: None) -> None: ...
    def push_sorted(
        self, data: None, func: typing.Callable[..., int], *user_data: typing.Any
    ) -> None: ...
    def push_sorted_unlocked(
        self, data: None, func: typing.Callable[..., int], *user_data: typing.Any
    ) -> None: ...
    def push_unlocked(self, data: None) -> None: ...
    def ref_unlocked(self) -> None: ...
    def remove(self, item: None) -> bool: ...
    def remove_unlocked(self, item: None) -> bool: ...
    def sort(self, func: typing.Callable[..., int], *user_data: typing.Any) -> None: ...
    def sort_unlocked(
        self, func: typing.Callable[..., int], *user_data: typing.Any
    ) -> None: ...
    def timed_pop(self, end_time: TimeVal) -> None: ...
    def timed_pop_unlocked(self, end_time: TimeVal) -> None: ...
    def timeout_pop(self, timeout: int) -> None: ...
    def timeout_pop_unlocked(self, timeout: int) -> None: ...
    def try_pop(self) -> None: ...
    def try_pop_unlocked(self) -> None: ...
    def unlock(self) -> None: ...
    def unref(self) -> None: ...
    def unref_and_unlock(self) -> None: ...

class BookmarkFile(GObject.GBoxed):
    """
    :Constructors:

    ::

        new() -> GLib.BookmarkFile
    """

    def add_application(
        self,
        uri: str,
        name: typing.Optional[str] = None,
        exec: typing.Optional[str] = None,
    ) -> None: ...
    def add_group(self, uri: str, group: str) -> None: ...
    def copy(self) -> BookmarkFile: ...
    @staticmethod
    def error_quark() -> int: ...
    def free(self) -> None: ...
    def get_added(self, uri: str) -> int: ...
    def get_added_date_time(self, uri: str) -> DateTime: ...
    def get_app_info(
        self, uri: str, name: str
    ) -> typing.Tuple[bool, str, int, int]: ...
    def get_application_info(
        self, uri: str, name: str
    ) -> typing.Tuple[bool, str, int, DateTime]: ...
    def get_applications(self, uri: str) -> list[str]: ...
    def get_description(self, uri: str) -> str: ...
    def get_groups(self, uri: str) -> list[str]: ...
    def get_icon(self, uri: str) -> typing.Tuple[bool, str, str]: ...
    def get_is_private(self, uri: str) -> bool: ...
    def get_mime_type(self, uri: str) -> str: ...
    def get_modified(self, uri: str) -> int: ...
    def get_modified_date_time(self, uri: str) -> DateTime: ...
    def get_size(self) -> int: ...
    def get_title(self, uri: typing.Optional[str] = None) -> str: ...
    def get_uris(self) -> list[str]: ...
    def get_visited(self, uri: str) -> int: ...
    def get_visited_date_time(self, uri: str) -> DateTime: ...
    def has_application(self, uri: str, name: str) -> bool: ...
    def has_group(self, uri: str, group: str) -> bool: ...
    def has_item(self, uri: str) -> bool: ...
    def load_from_data(self, data: typing.Sequence[int]) -> bool: ...
    def load_from_data_dirs(self, file: str) -> typing.Tuple[bool, str]: ...
    def load_from_file(self, filename: str) -> bool: ...
    def move_item(self, old_uri: str, new_uri: typing.Optional[str] = None) -> bool: ...
    @classmethod
    def new(cls) -> BookmarkFile: ...
    def remove_application(self, uri: str, name: str) -> bool: ...
    def remove_group(self, uri: str, group: str) -> bool: ...
    def remove_item(self, uri: str) -> bool: ...
    def set_added(self, uri: str, added: int) -> None: ...
    def set_added_date_time(self, uri: str, added: DateTime) -> None: ...
    def set_app_info(
        self, uri: str, name: str, exec: str, count: int, stamp: int
    ) -> bool: ...
    def set_application_info(
        self,
        uri: str,
        name: str,
        exec: str,
        count: int,
        stamp: typing.Optional[DateTime] = None,
    ) -> bool: ...
    def set_description(self, uri: typing.Optional[str], description: str) -> None: ...
    def set_groups(
        self, uri: str, groups: typing.Optional[typing.Sequence[str]] = None
    ) -> None: ...
    def set_icon(
        self, uri: str, href: typing.Optional[str], mime_type: str
    ) -> None: ...
    def set_is_private(self, uri: str, is_private: bool) -> None: ...
    def set_mime_type(self, uri: str, mime_type: str) -> None: ...
    def set_modified(self, uri: str, modified: int) -> None: ...
    def set_modified_date_time(self, uri: str, modified: DateTime) -> None: ...
    def set_title(self, uri: typing.Optional[str], title: str) -> None: ...
    def set_visited(self, uri: str, visited: int) -> None: ...
    def set_visited_date_time(self, uri: str, visited: DateTime) -> None: ...
    def to_data(self) -> bytes: ...
    def to_file(self, filename: str) -> bool: ...

class ByteArray(GObject.GBoxed):
    """
    :Constructors:

    ::

        ByteArray()
    """

    data: int = ...
    len: int = ...
    @staticmethod
    def append(array: typing.Sequence[int], data: int, len: int) -> bytes: ...
    @staticmethod
    def free(array: typing.Sequence[int], free_segment: bool) -> int: ...
    @staticmethod
    def free_to_bytes(array: typing.Sequence[int]) -> Bytes: ...
    @staticmethod
    def new() -> bytes: ...
    @staticmethod
    def new_take(data: typing.Sequence[int]) -> bytes: ...
    @staticmethod
    def prepend(array: typing.Sequence[int], data: int, len: int) -> bytes: ...
    @staticmethod
    def ref(array: typing.Sequence[int]) -> bytes: ...
    @staticmethod
    def remove_index(array: typing.Sequence[int], index_: int) -> bytes: ...
    @staticmethod
    def remove_index_fast(array: typing.Sequence[int], index_: int) -> bytes: ...
    @staticmethod
    def remove_range(
        array: typing.Sequence[int], index_: int, length: int
    ) -> bytes: ...
    @staticmethod
    def set_size(array: typing.Sequence[int], length: int) -> bytes: ...
    @staticmethod
    def sized_new(reserved_size: int) -> bytes: ...
    @staticmethod
    def sort(
        array: typing.Sequence[int], compare_func: typing.Callable[[None, None], int]
    ) -> None: ...
    @staticmethod
    def sort_with_data(
        array: typing.Sequence[int],
        compare_func: typing.Callable[..., int],
        *user_data: typing.Any,
    ) -> None: ...
    @staticmethod
    def steal(array: typing.Sequence[int]) -> typing.Tuple[int, int]: ...
    @staticmethod
    def unref(array: typing.Sequence[int]) -> None: ...

class Bytes(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(data:list=None) -> GLib.Bytes
        new_take(data:list=None) -> GLib.Bytes
    """

    def compare(self, bytes2: Bytes) -> int: ...
    def equal(self, bytes2: Bytes) -> bool: ...
    def get_data(self) -> typing.Optional[bytes]: ...
    def get_region(self, element_size: int, offset: int, n_elements: int) -> None: ...
    def get_size(self) -> int: ...
    def hash(self) -> int: ...
    @classmethod
    def new(cls, data: typing.Optional[typing.Sequence[int]] = None) -> Bytes: ...
    def new_from_bytes(self, offset: int, length: int) -> Bytes: ...
    @classmethod
    def new_take(cls, data: typing.Optional[typing.Sequence[int]] = None) -> Bytes: ...
    def ref(self) -> Bytes: ...
    def unref(self) -> None: ...
    def unref_to_array(self) -> bytes: ...
    def unref_to_data(self) -> bytes: ...

class Cache(GObject.GPointer):
    def destroy(self) -> None: ...
    def insert(self, key: None) -> None: ...
    def key_foreach(
        self, func: typing.Callable[..., None], *user_data: typing.Any
    ) -> None: ...
    def remove(self, value: None) -> None: ...
    def value_foreach(
        self, func: typing.Callable[..., None], *user_data: typing.Any
    ) -> None: ...

class Checksum(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(checksum_type:GLib.ChecksumType) -> GLib.Checksum or None
    """

    def copy(self) -> Checksum: ...
    def free(self) -> None: ...
    def get_string(self) -> str: ...
    @classmethod
    def new(cls, checksum_type: ChecksumType) -> typing.Optional[Checksum]: ...
    def reset(self) -> None: ...
    @staticmethod
    def type_get_length(checksum_type: ChecksumType) -> int: ...
    def update(self, data: typing.Sequence[int]) -> None: ...

class Completion(GObject.GPointer):
    """
    :Constructors:

    ::

        Completion()
    """

    items: list[None] = ...
    func: typing.Callable[[None], str] = ...
    prefix: str = ...
    cache: list[None] = ...
    strncmp_func: typing.Callable[[str, str, int], int] = ...
    def clear_items(self) -> None: ...
    def complete_utf8(self, prefix: str, new_prefix: str) -> list[str]: ...
    def free(self) -> None: ...

class Cond(GObject.GPointer):
    """
    :Constructors:

    ::

        Cond()
    """

    p: None = ...
    i: list[int] = ...
    def broadcast(self) -> None: ...
    def clear(self) -> None: ...
    def init(self) -> None: ...
    def signal(self) -> None: ...
    def wait(self, mutex: Mutex) -> None: ...
    def wait_until(self, mutex: Mutex, end_time: int) -> bool: ...

class Data(GObject.GPointer): ...

class Date(GObject.GBoxed):
    """
    :Constructors:

    ::

        Date()
        new() -> GLib.Date
        new_dmy(day:int, month:GLib.DateMonth, year:int) -> GLib.Date
        new_julian(julian_day:int) -> GLib.Date
    """

    julian_days: int = ...
    julian: int = ...
    dmy: int = ...
    day: int = ...
    month: int = ...
    year: int = ...
    def add_days(self, n_days: int) -> None: ...
    def add_months(self, n_months: int) -> None: ...
    def add_years(self, n_years: int) -> None: ...
    def clamp(self, min_date: Date, max_date: Date) -> None: ...
    def clear(self, n_dates: int) -> None: ...
    def compare(self, rhs: Date) -> int: ...
    def copy(self) -> Date: ...
    def days_between(self, date2: Date) -> int: ...
    def free(self) -> None: ...
    def get_day(self) -> int: ...
    def get_day_of_year(self) -> int: ...
    @staticmethod
    def get_days_in_month(month: DateMonth, year: int) -> int: ...
    def get_iso8601_week_of_year(self) -> int: ...
    def get_julian(self) -> int: ...
    def get_monday_week_of_year(self) -> int: ...
    @staticmethod
    def get_monday_weeks_in_year(year: int) -> int: ...
    def get_month(self) -> DateMonth: ...
    def get_sunday_week_of_year(self) -> int: ...
    @staticmethod
    def get_sunday_weeks_in_year(year: int) -> int: ...
    def get_weekday(self) -> DateWeekday: ...
    def get_year(self) -> int: ...
    def is_first_of_month(self) -> bool: ...
    def is_last_of_month(self) -> bool: ...
    @staticmethod
    def is_leap_year(year: int) -> bool: ...
    @classmethod
    def new(cls) -> Date: ...
    @classmethod
    def new_dmy(cls, day: int, month: DateMonth, year: int) -> Date: ...
    @classmethod
    def new_julian(cls, julian_day: int) -> Date: ...
    def order(self, date2: Date) -> None: ...
    def set_day(self, day: int) -> None: ...
    def set_dmy(self, day: int, month: DateMonth, y: int) -> None: ...
    def set_julian(self, julian_date: int) -> None: ...
    def set_month(self, month: DateMonth) -> None: ...
    def set_parse(self, str: str) -> None: ...
    def set_time(self, time_: int) -> None: ...
    def set_time_t(self, timet: int) -> None: ...
    def set_time_val(self, timeval: TimeVal) -> None: ...
    def set_year(self, year: int) -> None: ...
    @staticmethod
    def strftime(s: str, slen: int, format: str, date: Date) -> int: ...
    def subtract_days(self, n_days: int) -> None: ...
    def subtract_months(self, n_months: int) -> None: ...
    def subtract_years(self, n_years: int) -> None: ...
    def to_struct_tm(self, tm: None) -> None: ...
    def valid(self) -> bool: ...
    @staticmethod
    def valid_day(day: int) -> bool: ...
    @staticmethod
    def valid_dmy(day: int, month: DateMonth, year: int) -> bool: ...
    @staticmethod
    def valid_julian(julian_date: int) -> bool: ...
    @staticmethod
    def valid_month(month: DateMonth) -> bool: ...
    @staticmethod
    def valid_weekday(weekday: DateWeekday) -> bool: ...
    @staticmethod
    def valid_year(year: int) -> bool: ...

class DateTime(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(tz:GLib.TimeZone, year:int, month:int, day:int, hour:int, minute:int, seconds:float) -> GLib.DateTime or None
        new_from_iso8601(text:str, default_tz:GLib.TimeZone=None) -> GLib.DateTime or None
        new_from_timeval_local(tv:GLib.TimeVal) -> GLib.DateTime or None
        new_from_timeval_utc(tv:GLib.TimeVal) -> GLib.DateTime or None
        new_from_unix_local(t:int) -> GLib.DateTime or None
        new_from_unix_local_usec(usecs:int) -> GLib.DateTime or None
        new_from_unix_utc(t:int) -> GLib.DateTime or None
        new_from_unix_utc_usec(usecs:int) -> GLib.DateTime or None
        new_local(year:int, month:int, day:int, hour:int, minute:int, seconds:float) -> GLib.DateTime or None
        new_now(tz:GLib.TimeZone) -> GLib.DateTime or None
        new_now_local() -> GLib.DateTime or None
        new_now_utc() -> GLib.DateTime or None
        new_utc(year:int, month:int, day:int, hour:int, minute:int, seconds:float) -> GLib.DateTime or None
    """

    def add(self, timespan: int) -> typing.Optional[DateTime]: ...
    def add_days(self, days: int) -> typing.Optional[DateTime]: ...
    def add_full(
        self,
        years: int,
        months: int,
        days: int,
        hours: int,
        minutes: int,
        seconds: float,
    ) -> typing.Optional[DateTime]: ...
    def add_hours(self, hours: int) -> typing.Optional[DateTime]: ...
    def add_minutes(self, minutes: int) -> typing.Optional[DateTime]: ...
    def add_months(self, months: int) -> typing.Optional[DateTime]: ...
    def add_seconds(self, seconds: float) -> typing.Optional[DateTime]: ...
    def add_weeks(self, weeks: int) -> typing.Optional[DateTime]: ...
    def add_years(self, years: int) -> typing.Optional[DateTime]: ...
    def compare(self, dt2: DateTime) -> int: ...
    def difference(self, begin: DateTime) -> int: ...
    def equal(self, dt2: DateTime) -> bool: ...
    def format(self, format: str) -> typing.Optional[str]: ...
    def format_iso8601(self) -> typing.Optional[str]: ...
    def get_day_of_month(self) -> int: ...
    def get_day_of_week(self) -> int: ...
    def get_day_of_year(self) -> int: ...
    def get_hour(self) -> int: ...
    def get_microsecond(self) -> int: ...
    def get_minute(self) -> int: ...
    def get_month(self) -> int: ...
    def get_second(self) -> int: ...
    def get_seconds(self) -> float: ...
    def get_timezone(self) -> TimeZone: ...
    def get_timezone_abbreviation(self) -> str: ...
    def get_utc_offset(self) -> int: ...
    def get_week_numbering_year(self) -> int: ...
    def get_week_of_year(self) -> int: ...
    def get_year(self) -> int: ...
    def get_ymd(self) -> typing.Tuple[int, int, int]: ...
    def hash(self) -> int: ...
    def is_daylight_savings(self) -> bool: ...
    @classmethod
    def new(
        cls,
        tz: TimeZone,
        year: int,
        month: int,
        day: int,
        hour: int,
        minute: int,
        seconds: float,
    ) -> typing.Optional[DateTime]: ...
    @classmethod
    def new_from_iso8601(
        cls, text: str, default_tz: typing.Optional[TimeZone] = None
    ) -> typing.Optional[DateTime]: ...
    @classmethod
    def new_from_timeval_local(cls, tv: TimeVal) -> typing.Optional[DateTime]: ...
    @classmethod
    def new_from_timeval_utc(cls, tv: TimeVal) -> typing.Optional[DateTime]: ...
    @classmethod
    def new_from_unix_local(cls, t: int) -> typing.Optional[DateTime]: ...
    @classmethod
    def new_from_unix_local_usec(cls, usecs: int) -> typing.Optional[DateTime]: ...
    @classmethod
    def new_from_unix_utc(cls, t: int) -> typing.Optional[DateTime]: ...
    @classmethod
    def new_from_unix_utc_usec(cls, usecs: int) -> typing.Optional[DateTime]: ...
    @classmethod
    def new_local(
        cls, year: int, month: int, day: int, hour: int, minute: int, seconds: float
    ) -> typing.Optional[DateTime]: ...
    @classmethod
    def new_now(cls, tz: TimeZone) -> typing.Optional[DateTime]: ...
    @classmethod
    def new_now_local(cls) -> typing.Optional[DateTime]: ...
    @classmethod
    def new_now_utc(cls) -> typing.Optional[DateTime]: ...
    @classmethod
    def new_utc(
        cls, year: int, month: int, day: int, hour: int, minute: int, seconds: float
    ) -> typing.Optional[DateTime]: ...
    def ref(self) -> DateTime: ...
    def to_local(self) -> typing.Optional[DateTime]: ...
    def to_timeval(self, tv: TimeVal) -> bool: ...
    def to_timezone(self, tz: TimeZone) -> typing.Optional[DateTime]: ...
    def to_unix(self) -> int: ...
    def to_unix_usec(self) -> int: ...
    def to_utc(self) -> typing.Optional[DateTime]: ...
    def unref(self) -> None: ...

class DebugKey(GObject.GPointer):
    """
    :Constructors:

    ::

        DebugKey()
    """

    key: str = ...
    value: int = ...

class Dir(GObject.GBoxed):
    """
    :Constructors:

    ::

        open(path:str, flags:int) -> GLib.Dir
    """

    def close(self) -> None: ...
    @staticmethod
    def make_tmp(tmpl: typing.Optional[str] = None) -> str: ...
    @classmethod
    def open(cls, path: str, flags: int) -> Dir: ...
    def read_name(self) -> str: ...
    def ref(self) -> Dir: ...
    def rewind(self) -> None: ...
    def unref(self) -> None: ...

class DoubleIEEE754(GObject.GPointer):
    v_double = ...  # FIXME Constant

# override
class Error(Exception):
    args: typing.Any
    code: GObject.GEnum
    domain: int
    message: str

    def __init__(
        self,
        message: str = ...,
        domain: typing.Union[int, str] = ...,
        code: typing.Union[GObject.GEnum, int] = ...,
    ) -> None: ...
    def copy(self) -> Error: ...
    def matches(
        self, domain: typing.Union[int, str], code: typing.Union[GObject.GEnum, int]
    ) -> bool: ...
    @classmethod
    def new_literal(
        cls, domain: int, message: str, code: typing.Union[GObject.GEnum, int]
    ) -> Error: ...

class FloatIEEE754(GObject.GPointer):
    v_float = ...  # FIXME Constant

# override
class GError:
    args: typing.Any
    code: GObject.GEnum
    domain: int
    message: str

    def __init__(
        self,
        message: str = ...,
        domain: typing.Union[int, str] = ...,
        code: typing.Union[GObject.GEnum, int] = ...,
    ) -> None: ...
    def copy(self) -> GError: ...
    def matches(
        self, domain: typing.Union[int, str], code: typing.Union[GObject.GEnum, int]
    ) -> bool: ...
    @classmethod
    def new_literal(
        cls, domain: int, message: str, code: typing.Union[GObject.GEnum, int]
    ) -> GError: ...

class HashTable(GObject.GBoxed):
    @staticmethod
    def add(hash_table: dict[None, None], key: None) -> bool: ...
    @staticmethod
    def contains(hash_table: dict[None, None], key: None) -> bool: ...
    @staticmethod
    def destroy(hash_table: dict[None, None]) -> None: ...
    @staticmethod
    def find(
        hash_table: dict[None, None],
        predicate: typing.Callable[..., bool],
        *user_data: typing.Any,
    ) -> None: ...
    @staticmethod
    def foreach(
        hash_table: dict[None, None],
        func: typing.Callable[..., None],
        *user_data: typing.Any,
    ) -> None: ...
    @staticmethod
    def foreach_remove(
        hash_table: dict[None, None],
        func: typing.Callable[..., bool],
        *user_data: typing.Any,
    ) -> int: ...
    @staticmethod
    def foreach_steal(
        hash_table: dict[None, None],
        func: typing.Callable[..., bool],
        *user_data: typing.Any,
    ) -> int: ...
    @staticmethod
    def insert(hash_table: dict[None, None], key: None, value: None) -> bool: ...
    @staticmethod
    def lookup(hash_table: dict[None, None], key: None) -> None: ...
    @staticmethod
    def lookup_extended(
        hash_table: dict[None, None], lookup_key: None
    ) -> typing.Tuple[bool, None, None]: ...
    @staticmethod
    def new_similar(other_hash_table: dict[None, None]) -> dict[None, None]: ...
    @staticmethod
    def ref(hash_table: dict[None, None]) -> dict[None, None]: ...
    @staticmethod
    def remove(hash_table: dict[None, None], key: None) -> bool: ...
    @staticmethod
    def remove_all(hash_table: dict[None, None]) -> None: ...
    @staticmethod
    def replace(hash_table: dict[None, None], key: None, value: None) -> bool: ...
    @staticmethod
    def size(hash_table: dict[None, None]) -> int: ...
    @staticmethod
    def steal(hash_table: dict[None, None], key: None) -> bool: ...
    @staticmethod
    def steal_all(hash_table: dict[None, None]) -> None: ...
    @staticmethod
    def steal_extended(
        hash_table: dict[None, None], lookup_key: None
    ) -> typing.Tuple[bool, None, None]: ...
    @staticmethod
    def unref(hash_table: dict[None, None]) -> None: ...

class HashTableIter(GObject.GPointer):
    """
    :Constructors:

    ::

        HashTableIter()
    """

    dummy1: None = ...
    dummy2: None = ...
    dummy3: None = ...
    dummy4: int = ...
    dummy5: bool = ...
    dummy6: None = ...
    def get_hash_table(self) -> dict[None, None]: ...
    def init(self, hash_table: dict[None, None]) -> None: ...
    def next(self) -> typing.Tuple[bool, None, None]: ...
    def remove(self) -> None: ...
    def replace(self, value: None) -> None: ...
    def steal(self) -> None: ...

class Hmac(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(digest_type:GLib.ChecksumType, key:list) -> GLib.Hmac or None
    """

    def copy(self) -> Hmac: ...
    def get_digest(self, buffer: typing.Sequence[int]) -> None: ...
    def get_string(self) -> str: ...
    @classmethod
    def new(
        cls, digest_type: ChecksumType, key: typing.Sequence[int]
    ) -> typing.Optional[Hmac]: ...
    def ref(self) -> Hmac: ...
    def unref(self) -> None: ...
    def update(self, data: typing.Sequence[int]) -> None: ...

class Hook(GObject.GPointer):
    """
    :Constructors:

    ::

        Hook()
    """

    data: None = ...
    next: Hook = ...
    prev: Hook = ...
    ref_count: int = ...
    hook_id: int = ...
    flags: int = ...
    func: None = ...
    destroy: typing.Callable[[None], None] = ...
    def compare_ids(self, sibling: Hook) -> int: ...
    @staticmethod
    def destroy(hook_list: HookList, hook_id: int) -> bool: ...
    @staticmethod
    def destroy_link(hook_list: HookList, hook: Hook) -> None: ...
    @staticmethod
    def free(hook_list: HookList, hook: Hook) -> None: ...
    @staticmethod
    def insert_before(
        hook_list: HookList, sibling: typing.Optional[Hook], hook: Hook
    ) -> None: ...
    @staticmethod
    def insert_sorted(
        hook_list: HookList, hook: Hook, func: typing.Callable[[Hook, Hook], int]
    ) -> None: ...
    @staticmethod
    def prepend(hook_list: HookList, hook: Hook) -> None: ...
    @staticmethod
    def unref(hook_list: HookList, hook: Hook) -> None: ...

class HookList(GObject.GPointer):
    """
    :Constructors:

    ::

        HookList()
    """

    seq_id: int = ...
    hook_size: int = ...
    is_setup: int = ...
    hooks: Hook = ...
    dummy3: None = ...
    finalize_hook: typing.Callable[[HookList, Hook], None] = ...
    dummy: list[None] = ...
    def clear(self) -> None: ...
    def init(self, hook_size: int) -> None: ...
    def invoke(self, may_recurse: bool) -> None: ...
    def invoke_check(self, may_recurse: bool) -> None: ...
    def marshal(
        self,
        may_recurse: bool,
        marshaller: typing.Callable[..., None],
        *marshal_data: typing.Any,
    ) -> None: ...
    def marshal_check(
        self,
        may_recurse: bool,
        marshaller: typing.Callable[..., bool],
        *marshal_data: typing.Any,
    ) -> None: ...

class IOChannel(GObject.GBoxed):
    """
    :Constructors:

    ::

        IOChannel()
        new_file(filename:str, mode:str) -> GLib.IOChannel
        unix_new(fd:int) -> GLib.IOChannel
    """

    ref_count: int = ...
    funcs: IOFuncs = ...
    encoding: str = ...
    read_cd: None = ...
    write_cd: None = ...
    line_term: str = ...
    line_term_len: int = ...
    buf_size: int = ...
    read_buf: String = ...
    encoded_read_buf: String = ...
    write_buf: String = ...
    partial_write_buf: list[int] = ...
    use_buffer: int = ...
    do_encode: int = ...
    close_on_unref: int = ...
    is_readable: int = ...
    is_writeable: int = ...
    is_seekable: int = ...
    reserved1: None = ...
    reserved2: None = ...
    _whence_map = ...  # FIXME Constant

    def add_watch(
        self, condition, callback, *user_data, **kwargs
    ): ...  # FIXME Function
    def close(self) -> None: ...
    @staticmethod
    def error_from_errno(en: int) -> IOChannelError: ...
    @staticmethod
    def error_quark() -> int: ...
    def flush(self) -> IOStatus: ...
    def get_buffer_condition(self) -> IOCondition: ...
    def get_buffer_size(self) -> int: ...
    def get_buffered(self) -> bool: ...
    def get_close_on_unref(self) -> bool: ...
    def get_encoding(self) -> str: ...
    def get_flags(self) -> IOFlags: ...
    def get_line_term(self) -> typing.Tuple[str, int]: ...
    def init(self) -> None: ...
    @classmethod
    def new_file(cls, filename: str, mode: str) -> IOChannel: ...
    def read(self, max_count=-1): ...  # FIXME Function
    def read_chars(self) -> typing.Tuple[IOStatus, bytes, int]: ...
    def read_line(self) -> typing.Tuple[IOStatus, str, int, int]: ...
    def read_line_string(
        self, buffer: String, terminator_pos: typing.Optional[int] = None
    ) -> IOStatus: ...
    def read_to_end(self) -> typing.Tuple[IOStatus, bytes]: ...
    def read_unichar(self) -> typing.Tuple[IOStatus, str]: ...
    def readline(self, size_hint=-1): ...  # FIXME Function
    def readlines(self, size_hint=-1): ...  # FIXME Function
    def ref(self) -> IOChannel: ...
    def seek(self, offset, whence=0): ...  # FIXME Function
    def seek_position(self, offset: int, type: SeekType) -> IOStatus: ...
    def set_buffer_size(self, size: int) -> None: ...
    def set_buffered(self, buffered: bool) -> None: ...
    def set_close_on_unref(self, do_close: bool) -> None: ...
    def set_encoding(self, encoding: typing.Optional[str] = None) -> IOStatus: ...
    def set_flags(self, flags: IOFlags) -> IOStatus: ...
    def set_line_term(self, line_term: typing.Optional[str], length: int) -> None: ...
    def shutdown(self, flush: bool) -> IOStatus: ...
    def unix_get_fd(self) -> int: ...
    @classmethod
    def unix_new(cls, fd: int) -> IOChannel: ...
    def unref(self) -> None: ...
    def write(self, buf, buflen=-1): ...  # FIXME Function
    def write_chars(
        self, buf: typing.Sequence[int], count: int
    ) -> typing.Tuple[IOStatus, int]: ...
    def write_unichar(self, thechar: str) -> IOStatus: ...
    def writelines(self, lines): ...  # FIXME Function

class IOFuncs(GObject.GPointer):
    """
    :Constructors:

    ::

        IOFuncs()
    """

    io_read: typing.Callable[[IOChannel, str, int, int], IOStatus] = ...
    io_write: typing.Callable[[IOChannel, str, int, int], IOStatus] = ...
    io_seek: typing.Callable[[IOChannel, int, SeekType], IOStatus] = ...
    io_close: typing.Callable[[IOChannel], IOStatus] = ...
    io_create_watch: typing.Callable[[IOChannel, IOCondition], Source] = ...
    io_free: typing.Callable[[IOChannel], None] = ...
    io_set_flags: typing.Callable[[IOChannel, IOFlags], IOStatus] = ...
    io_get_flags: typing.Callable[[IOChannel], IOFlags] = ...

class Idle(GObject.GBoxed):
    """
    :Constructors:

    ::

        Source()
        new(source_funcs:GLib.SourceFuncs, struct_size:int) -> GLib.Source
    """

    callback_data: None = ...
    callback_funcs: SourceCallbackFuncs = ...
    source_funcs: SourceFuncs = ...
    ref_count: int = ...
    context: MainContext = ...
    priority: int = ...
    flags: int = ...
    source_id: int = ...
    poll_fds: list[None] = ...
    prev: Source = ...
    next: Source = ...
    name: str = ...
    priv: SourcePrivate = ...
    can_recurse = ...  # FIXME Constant

    def add_child_source(self, child_source: Source) -> None: ...
    def add_poll(self, fd: PollFD) -> None: ...
    def add_unix_fd(self, fd: int, events: IOCondition) -> None: ...
    def attach(self, context: typing.Optional[MainContext] = None) -> int: ...
    def destroy(self) -> None: ...
    def finalize(self): ...  # FIXME Function
    def get_can_recurse(self) -> bool: ...
    def get_context(self) -> typing.Optional[MainContext]: ...
    def get_current_time(self): ...  # FIXME Function
    def get_id(self) -> int: ...
    def get_name(self) -> typing.Optional[str]: ...
    def get_priority(self) -> int: ...
    def get_ready_time(self) -> int: ...
    def get_time(self) -> int: ...
    def is_destroyed(self) -> bool: ...
    def modify_unix_fd(self, tag: None, new_events: IOCondition) -> None: ...
    @classmethod
    def new(cls, source_funcs: SourceFuncs, struct_size: int) -> Source: ...
    def query_unix_fd(self, tag: None) -> IOCondition: ...
    def ref(self) -> Source: ...
    @staticmethod
    def remove(tag: int) -> bool: ...
    @staticmethod
    def remove_by_funcs_user_data(funcs: SourceFuncs, user_data: None) -> bool: ...
    @staticmethod
    def remove_by_user_data(user_data: None) -> bool: ...
    def remove_child_source(self, child_source: Source) -> None: ...
    def remove_poll(self, fd: PollFD) -> None: ...
    def remove_unix_fd(self, tag: None) -> None: ...
    def set_callback(self, fn, user_data=None): ...  # FIXME Function
    def set_callback_indirect(
        self, callback_data: None, callback_funcs: SourceCallbackFuncs
    ) -> None: ...
    def set_can_recurse(self, can_recurse: bool) -> None: ...
    def set_funcs(self, funcs: SourceFuncs) -> None: ...
    def set_name(self, name: str) -> None: ...
    @staticmethod
    def set_name_by_id(tag: int, name: str) -> None: ...
    def set_priority(self, priority: int) -> None: ...
    def set_ready_time(self, ready_time: int) -> None: ...
    def set_static_name(self, name: str) -> None: ...
    def unref(self) -> None: ...

class KeyFile(GObject.GBoxed):
    """
    :Constructors:

    ::

        new() -> GLib.KeyFile
    """

    @staticmethod
    def error_quark() -> int: ...
    def get_boolean(self, group_name: str, key: str) -> bool: ...
    def get_boolean_list(self, group_name: str, key: str) -> list[bool]: ...
    def get_comment(
        self, group_name: typing.Optional[str] = None, key: typing.Optional[str] = None
    ) -> str: ...
    def get_double(self, group_name: str, key: str) -> float: ...
    def get_double_list(self, group_name: str, key: str) -> list[float]: ...
    def get_groups(self) -> typing.Tuple[list[str], int]: ...
    def get_int64(self, group_name: str, key: str) -> int: ...
    def get_integer(self, group_name: str, key: str) -> int: ...
    def get_integer_list(self, group_name: str, key: str) -> list[int]: ...
    def get_keys(self, group_name: str) -> typing.Tuple[list[str], int]: ...
    def get_locale_for_key(
        self, group_name: str, key: str, locale: typing.Optional[str] = None
    ) -> typing.Optional[str]: ...
    def get_locale_string(
        self, group_name: str, key: str, locale: typing.Optional[str] = None
    ) -> str: ...
    def get_locale_string_list(
        self, group_name: str, key: str, locale: typing.Optional[str] = None
    ) -> list[str]: ...
    def get_start_group(self) -> typing.Optional[str]: ...
    def get_string(self, group_name: str, key: str) -> str: ...
    def get_string_list(self, group_name: str, key: str) -> list[str]: ...
    def get_uint64(self, group_name: str, key: str) -> int: ...
    def get_value(self, group_name: str, key: str) -> str: ...
    def has_group(self, group_name: str) -> bool: ...
    def load_from_bytes(self, bytes: Bytes, flags: KeyFileFlags) -> bool: ...
    def load_from_data(self, data: str, length: int, flags: KeyFileFlags) -> bool: ...
    def load_from_data_dirs(
        self, file: str, flags: KeyFileFlags
    ) -> typing.Tuple[bool, str]: ...
    def load_from_dirs(
        self, file: str, search_dirs: typing.Sequence[str], flags: KeyFileFlags
    ) -> typing.Tuple[bool, str]: ...
    def load_from_file(self, file: str, flags: KeyFileFlags) -> bool: ...
    @classmethod
    def new(cls) -> KeyFile: ...
    def remove_comment(
        self, group_name: typing.Optional[str] = None, key: typing.Optional[str] = None
    ) -> bool: ...
    def remove_group(self, group_name: str) -> bool: ...
    def remove_key(self, group_name: str, key: str) -> bool: ...
    def save_to_file(self, filename: str) -> bool: ...
    def set_boolean(self, group_name: str, key: str, value: bool) -> None: ...
    def set_boolean_list(
        self, group_name: str, key: str, list: typing.Sequence[bool]
    ) -> None: ...
    def set_comment(
        self, group_name: typing.Optional[str], key: typing.Optional[str], comment: str
    ) -> bool: ...
    def set_double(self, group_name: str, key: str, value: float) -> None: ...
    def set_double_list(
        self, group_name: str, key: str, list: typing.Sequence[float]
    ) -> None: ...
    def set_int64(self, group_name: str, key: str, value: int) -> None: ...
    def set_integer(self, group_name: str, key: str, value: int) -> None: ...
    def set_integer_list(
        self, group_name: str, key: str, list: typing.Sequence[int]
    ) -> None: ...
    def set_list_separator(self, separator: int) -> None: ...
    def set_locale_string(
        self, group_name: str, key: str, locale: str, string: str
    ) -> None: ...
    def set_locale_string_list(
        self, group_name: str, key: str, locale: str, list: typing.Sequence[str]
    ) -> None: ...
    def set_string(self, group_name: str, key: str, string: str) -> None: ...
    def set_string_list(
        self, group_name: str, key: str, list: typing.Sequence[str]
    ) -> None: ...
    def set_uint64(self, group_name: str, key: str, value: int) -> None: ...
    def set_value(self, group_name: str, key: str, value: str) -> None: ...
    def to_data(self) -> typing.Tuple[str, int]: ...
    def unref(self) -> None: ...

class List(GObject.GPointer):
    """
    :Constructors:

    ::

        List()
    """

    data: None = ...
    next: list[None] = ...
    prev: list[None] = ...
    @staticmethod
    def pop_allocator() -> None: ...
    @staticmethod
    def push_allocator(allocator: Allocator) -> None: ...

class LogField(GObject.GPointer):
    """
    :Constructors:

    ::

        LogField()
    """

    key: str = ...
    value: None = ...
    length: int = ...

class MainContext(GObject.GBoxed):
    """
    :Constructors:

    ::

        new() -> GLib.MainContext
        new_with_flags(flags:GLib.MainContextFlags) -> GLib.MainContext
    """

    def acquire(self) -> bool: ...
    def add_poll(self, fd: PollFD, priority: int) -> None: ...
    def check(self, max_priority: int, fds: typing.Sequence[PollFD]) -> bool: ...
    @staticmethod
    def default() -> MainContext: ...
    def dispatch(self) -> None: ...
    def find_source_by_funcs_user_data(
        self, funcs: SourceFuncs, user_data: None
    ) -> Source: ...
    def find_source_by_id(self, source_id: int) -> Source: ...
    def find_source_by_user_data(self, user_data: None) -> Source: ...
    @staticmethod
    def get_thread_default() -> typing.Optional[MainContext]: ...
    def invoke_full(
        self, priority: int, function: typing.Callable[..., bool], *data: typing.Any
    ) -> None: ...
    def is_owner(self) -> bool: ...
    # override
    def iteration(self, may_block: bool = True) -> bool: ...
    @classmethod
    def new(cls) -> MainContext: ...
    @classmethod
    def new_with_flags(cls, flags: MainContextFlags) -> MainContext: ...
    def pending(self) -> bool: ...
    def pop_thread_default(self) -> None: ...
    def prepare(self) -> typing.Tuple[bool, int]: ...
    def push_thread_default(self) -> None: ...
    def query(self, max_priority: int) -> typing.Tuple[int, int, list[PollFD]]: ...
    def ref(self) -> MainContext: ...
    @staticmethod
    def ref_thread_default() -> MainContext: ...
    def release(self) -> None: ...
    def remove_poll(self, fd: PollFD) -> None: ...
    def unref(self) -> None: ...
    def wait(self, cond: Cond, mutex: Mutex) -> bool: ...
    def wakeup(self) -> None: ...

class MainLoop(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(context:GLib.MainContext=None, is_running:bool) -> GLib.MainLoop
    """

    def get_context(self) -> MainContext: ...
    def is_running(self) -> bool: ...
    @classmethod
    def new(
        cls, context: typing.Optional[MainContext], is_running: bool
    ) -> MainLoop: ...
    def quit(self) -> None: ...
    def ref(self) -> MainLoop: ...
    def run(self): ...  # FIXME Function
    def unref(self) -> None: ...

class MappedFile(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(filename:str, writable:bool) -> GLib.MappedFile
        new_from_fd(fd:int, writable:bool) -> GLib.MappedFile
    """

    def free(self) -> None: ...
    def get_bytes(self) -> Bytes: ...
    def get_contents(self) -> str: ...
    def get_length(self) -> int: ...
    @classmethod
    def new(cls, filename: str, writable: bool) -> MappedFile: ...
    @classmethod
    def new_from_fd(cls, fd: int, writable: bool) -> MappedFile: ...
    def ref(self) -> MappedFile: ...
    def unref(self) -> None: ...

class MarkupParseContext(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(parser:GLib.MarkupParser, flags:GLib.MarkupParseFlags, user_data=None, user_data_dnotify:GLib.DestroyNotify) -> GLib.MarkupParseContext
    """

    def end_parse(self) -> bool: ...
    def free(self) -> None: ...
    def get_element(self) -> str: ...
    def get_element_stack(self) -> list[str]: ...
    def get_position(self) -> typing.Tuple[int, int]: ...
    def get_user_data(self) -> None: ...
    @classmethod
    def new(
        cls,
        parser: MarkupParser,
        flags: MarkupParseFlags,
        user_data: None,
        user_data_dnotify: typing.Callable[[None], None],
    ) -> MarkupParseContext: ...
    def parse(self, text: str, text_len: int) -> bool: ...
    def pop(self) -> None: ...
    def push(self, parser: MarkupParser, user_data: None) -> None: ...
    def ref(self) -> MarkupParseContext: ...
    def unref(self) -> None: ...

class MarkupParser(GObject.GPointer):
    """
    :Constructors:

    ::

        MarkupParser()
    """

    start_element: typing.Callable[..., None] = ...
    end_element: typing.Callable[..., None] = ...
    text: typing.Callable[..., None] = ...
    passthrough: typing.Callable[..., None] = ...
    error: typing.Callable[..., None] = ...

class MatchInfo(GObject.GBoxed):
    def expand_references(self, string_to_expand: str) -> typing.Optional[str]: ...
    def fetch(self, match_num: int) -> typing.Optional[str]: ...
    def fetch_all(self) -> list[str]: ...
    def fetch_named(self, name: str) -> typing.Optional[str]: ...
    def fetch_named_pos(self, name: str) -> typing.Tuple[bool, int, int]: ...
    def fetch_pos(self, match_num: int) -> typing.Tuple[bool, int, int]: ...
    def free(self) -> None: ...
    def get_match_count(self) -> int: ...
    def get_regex(self) -> Regex: ...
    def get_string(self) -> str: ...
    def is_partial_match(self) -> bool: ...
    def matches(self) -> bool: ...
    def next(self) -> bool: ...
    def ref(self) -> MatchInfo: ...
    def unref(self) -> None: ...

class MemChunk(GObject.GPointer):
    def alloc(self) -> None: ...
    def alloc0(self) -> None: ...
    def clean(self) -> None: ...
    def destroy(self) -> None: ...
    def free(self, mem: None) -> None: ...
    @staticmethod
    def info() -> None: ...
    def print_(self) -> None: ...
    def reset(self) -> None: ...

class MemVTable(GObject.GPointer):
    """
    :Constructors:

    ::

        MemVTable()
    """

    malloc: typing.Callable[[int], None] = ...
    realloc: typing.Callable[[None, int], None] = ...
    free: typing.Callable[[None], None] = ...
    calloc: typing.Callable[[int, int], None] = ...
    try_malloc: typing.Callable[[int], None] = ...
    try_realloc: typing.Callable[[None, int], None] = ...

class Mutex(GObject.GPointer):
    i = ...  # FIXME Constant
    p = ...  # FIXME Constant

    def clear(self) -> None: ...
    def init(self) -> None: ...
    def lock(self) -> None: ...
    def trylock(self) -> bool: ...
    def unlock(self) -> None: ...

class Node(GObject.GPointer):
    """
    :Constructors:

    ::

        Node()
    """

    data: None = ...
    next: Node = ...
    prev: Node = ...
    parent: Node = ...
    children: Node = ...
    def child_index(self, data: None) -> int: ...
    def child_position(self, child: Node) -> int: ...
    def children_foreach(
        self, flags: TraverseFlags, func: typing.Callable[..., None], *data: typing.Any
    ) -> None: ...
    def depth(self) -> int: ...
    def destroy(self) -> None: ...
    def is_ancestor(self, descendant: Node) -> bool: ...
    def max_height(self) -> int: ...
    def n_children(self) -> int: ...
    def n_nodes(self, flags: TraverseFlags) -> int: ...
    @staticmethod
    def pop_allocator() -> None: ...
    @staticmethod
    def push_allocator(allocator: Allocator) -> None: ...
    def reverse_children(self) -> None: ...
    def traverse(
        self,
        order: TraverseType,
        flags: TraverseFlags,
        max_depth: int,
        func: typing.Callable[..., bool],
        *data: typing.Any,
    ) -> None: ...
    def unlink(self) -> None: ...

class Once(GObject.GPointer):
    """
    :Constructors:

    ::

        Once()
    """

    status: OnceStatus = ...
    retval: None = ...
    @staticmethod
    def init_enter() -> typing.Tuple[bool, None]: ...
    @staticmethod
    def init_enter_impl(location: int) -> bool: ...
    @staticmethod
    def init_enter_pointer(location: None) -> bool: ...
    @staticmethod
    def init_leave(result: int) -> None: ...
    @staticmethod
    def init_leave_pointer(location: None, result: None) -> None: ...

class OptionContext:
    def add_group(self, *args, **kwargs): ...  # FIXME Function
    def get_help_enabled(self, *args, **kwargs): ...  # FIXME Function
    def get_ignore_unknown_options(self, *args, **kwargs): ...  # FIXME Function
    def get_main_group(self, *args, **kwargs): ...  # FIXME Function
    def parse(self, *args, **kwargs): ...  # FIXME Function
    def set_help_enabled(self, *args, **kwargs): ...  # FIXME Function
    def set_ignore_unknown_options(self, *args, **kwargs): ...  # FIXME Function
    def set_main_group(self, *args, **kwargs): ...  # FIXME Function

class OptionEntry(GObject.GPointer):
    """
    :Constructors:

    ::

        OptionEntry()
    """

    long_name: str = ...
    short_name: int = ...
    flags: int = ...
    arg: OptionArg = ...
    arg_data: None = ...
    description: str = ...
    arg_description: str = ...

class OptionGroup:
    def add_entries(self, *args, **kwargs): ...  # FIXME Function
    def set_translation_domain(self, *args, **kwargs): ...  # FIXME Function

class PathBuf(GObject.GPointer):
    """
    :Constructors:

    ::

        PathBuf()
    """

    dummy: list[None] = ...
    def clear(self) -> None: ...
    def clear_to_path(self) -> typing.Optional[str]: ...
    @staticmethod
    def equal(v1: None, v2: None) -> bool: ...
    def free(self) -> None: ...
    def free_to_path(self) -> typing.Optional[str]: ...
    def init(self) -> PathBuf: ...
    def init_from_path(self, path: typing.Optional[str] = None) -> PathBuf: ...
    def pop(self) -> bool: ...
    def push(self, path: str) -> PathBuf: ...
    def set_extension(self, extension: typing.Optional[str] = None) -> bool: ...
    def set_filename(self, file_name: str) -> bool: ...
    def to_path(self) -> typing.Optional[str]: ...

class PatternSpec(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(pattern:str) -> GLib.PatternSpec
    """

    def copy(self) -> PatternSpec: ...
    def equal(self, pspec2: PatternSpec) -> bool: ...
    def free(self) -> None: ...
    def match(
        self,
        string_length: int,
        string: str,
        string_reversed: typing.Optional[str] = None,
    ) -> bool: ...
    def match_string(self, string: str) -> bool: ...
    @classmethod
    def new(cls, pattern: str) -> PatternSpec: ...

class Pid:
    denominator = ...  # FIXME Constant
    imag = ...  # FIXME Constant
    numerator = ...  # FIXME Constant
    real = ...  # FIXME Constant

    def as_integer_ratio(self, /): ...  # FIXME Function
    def bit_count(self, /): ...  # FIXME Function
    def bit_length(self, /): ...  # FIXME Function
    def close(self, *args, **kwargs): ...  # FIXME Function
    def conjugate(self, *args, **kwargs): ...  # FIXME Function
    def from_bytes(bytes, byteorder="big", *, signed=False): ...  # FIXME Function
    def is_integer(self, /): ...  # FIXME Function
    def to_bytes(
        self, /, length=1, byteorder="big", *, signed=False
    ): ...  # FIXME Function

class PollFD(GObject.GBoxed):
    """
    :Constructors:

    ::

        PollFD()
    """

    fd: int = ...
    events: int = ...
    revents: int = ...

class Private(GObject.GPointer):
    """
    :Constructors:

    ::

        Private()
    """

    p: None = ...
    notify: typing.Callable[[None], None] = ...
    future: list[None] = ...
    def get(self) -> None: ...
    def replace(self, value: None) -> None: ...
    def set(self, value: None) -> None: ...

class PtrArray(GObject.GBoxed):
    """
    :Constructors:

    ::

        PtrArray()
    """

    pdata: None = ...
    len: int = ...

class Queue(GObject.GPointer):
    """
    :Constructors:

    ::

        Queue()
    """

    head: list[None] = ...
    tail: list[None] = ...
    length: int = ...
    def clear(self) -> None: ...
    def clear_full(
        self, free_func: typing.Optional[typing.Callable[[None], None]] = None
    ) -> None: ...
    def foreach(
        self, func: typing.Callable[..., None], *user_data: typing.Any
    ) -> None: ...
    def free(self) -> None: ...
    def free_full(self, free_func: typing.Callable[[None], None]) -> None: ...
    def get_length(self) -> int: ...
    def index(self, data: None) -> int: ...
    def init(self) -> None: ...
    def insert_sorted(
        self, data: None, func: typing.Callable[..., int], *user_data: typing.Any
    ) -> None: ...
    def is_empty(self) -> bool: ...
    def peek_head(self) -> None: ...
    def peek_nth(self, n: int) -> None: ...
    def peek_tail(self) -> None: ...
    def pop_head(self) -> None: ...
    def pop_nth(self, n: int) -> None: ...
    def pop_tail(self) -> None: ...
    def push_head(self, data: None) -> None: ...
    def push_nth(self, data: None, n: int) -> None: ...
    def push_tail(self, data: None) -> None: ...
    def remove(self, data: None) -> bool: ...
    def remove_all(self, data: None) -> int: ...
    def reverse(self) -> None: ...
    def sort(
        self, compare_func: typing.Callable[..., int], *user_data: typing.Any
    ) -> None: ...

class RWLock(GObject.GPointer):
    """
    :Constructors:

    ::

        RWLock()
    """

    p: None = ...
    i: list[int] = ...
    def clear(self) -> None: ...
    def init(self) -> None: ...
    def reader_lock(self) -> None: ...
    def reader_trylock(self) -> bool: ...
    def reader_unlock(self) -> None: ...
    def writer_lock(self) -> None: ...
    def writer_trylock(self) -> bool: ...
    def writer_unlock(self) -> None: ...

class Rand(GObject.GBoxed):
    """
    :Constructors:

    ::

        new() -> GLib.Rand
        new_with_seed(seed:int) -> GLib.Rand
        new_with_seed_array(seed:int, seed_length:int) -> GLib.Rand
    """

    def copy(self) -> Rand: ...
    def double(self) -> float: ...
    def double_range(self, begin: float, end: float) -> float: ...
    def free(self) -> None: ...
    def int(self) -> int: ...
    def int_range(self, begin: int, end: int) -> int: ...
    @classmethod
    def new(cls) -> Rand: ...
    @classmethod
    def new_with_seed(cls, seed: int) -> Rand: ...
    @classmethod
    def new_with_seed_array(cls, seed: int, seed_length: int) -> Rand: ...
    def set_seed(self, seed: int) -> None: ...
    def set_seed_array(self, seed: int, seed_length: int) -> None: ...

class RecMutex(GObject.GPointer):
    """
    :Constructors:

    ::

        RecMutex()
    """

    p: None = ...
    i: list[int] = ...
    def clear(self) -> None: ...
    def init(self) -> None: ...
    def lock(self) -> None: ...
    def trylock(self) -> bool: ...
    def unlock(self) -> None: ...

class Regex(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(pattern:str, compile_options:GLib.RegexCompileFlags, match_options:GLib.RegexMatchFlags) -> GLib.Regex or None
    """

    @staticmethod
    def check_replacement(replacement: str) -> typing.Tuple[bool, bool]: ...
    @staticmethod
    def error_quark() -> int: ...
    @staticmethod
    def escape_nul(string: str, length: int) -> str: ...
    @staticmethod
    def escape_string(string: str, length: int) -> str: ...
    def get_capture_count(self) -> int: ...
    def get_compile_flags(self) -> RegexCompileFlags: ...
    def get_has_cr_or_lf(self) -> bool: ...
    def get_match_flags(self) -> RegexMatchFlags: ...
    def get_max_backref(self) -> int: ...
    def get_max_lookbehind(self) -> int: ...
    def get_pattern(self) -> str: ...
    def get_string_number(self, name: str) -> int: ...
    def match(
        self, string: str, match_options: RegexMatchFlags
    ) -> typing.Tuple[bool, MatchInfo]: ...
    def match_all(
        self, string: str, match_options: RegexMatchFlags
    ) -> typing.Tuple[bool, MatchInfo]: ...
    def match_all_full(
        self,
        string: typing.Sequence[str],
        start_position: int,
        match_options: RegexMatchFlags,
    ) -> typing.Tuple[bool, MatchInfo]: ...
    def match_full(
        self,
        string: typing.Sequence[str],
        start_position: int,
        match_options: RegexMatchFlags,
    ) -> typing.Tuple[bool, MatchInfo]: ...
    @staticmethod
    def match_simple(
        pattern: str,
        string: str,
        compile_options: RegexCompileFlags,
        match_options: RegexMatchFlags,
    ) -> bool: ...
    @classmethod
    def new(
        cls,
        pattern: str,
        compile_options: RegexCompileFlags,
        match_options: RegexMatchFlags,
    ) -> typing.Optional[Regex]: ...
    def ref(self) -> Regex: ...
    def replace(
        self,
        string: typing.Sequence[str],
        start_position: int,
        replacement: str,
        match_options: RegexMatchFlags,
    ) -> str: ...
    def replace_eval(
        self,
        string: typing.Sequence[str],
        start_position: int,
        match_options: RegexMatchFlags,
        eval: typing.Callable[..., bool],
        *user_data: typing.Any,
    ) -> str: ...
    def replace_literal(
        self,
        string: typing.Sequence[str],
        start_position: int,
        replacement: str,
        match_options: RegexMatchFlags,
    ) -> str: ...
    def split(self, string: str, match_options: RegexMatchFlags) -> list[str]: ...
    def split_full(
        self,
        string: typing.Sequence[str],
        start_position: int,
        match_options: RegexMatchFlags,
        max_tokens: int,
    ) -> list[str]: ...
    @staticmethod
    def split_simple(
        pattern: str,
        string: str,
        compile_options: RegexCompileFlags,
        match_options: RegexMatchFlags,
    ) -> list[str]: ...
    def unref(self) -> None: ...

class Relation(GObject.GPointer):
    def count(self, key: None, field: int) -> int: ...
    def delete(self, key: None, field: int) -> int: ...
    def destroy(self) -> None: ...
    def print_(self) -> None: ...

class SList(GObject.GPointer):
    """
    :Constructors:

    ::

        SList()
    """

    data: None = ...
    next: list[None] = ...
    @staticmethod
    def pop_allocator() -> None: ...
    @staticmethod
    def push_allocator(allocator: Allocator) -> None: ...

class Scanner(GObject.GPointer):
    """
    :Constructors:

    ::

        Scanner()
    """

    user_data: None = ...
    max_parse_errors: int = ...
    parse_errors: int = ...
    input_name: str = ...
    qdata: Data = ...
    config: ScannerConfig = ...
    token: TokenType = ...
    value: TokenValue = ...
    line: int = ...
    position: int = ...
    next_token: TokenType = ...
    next_value: TokenValue = ...
    next_line: int = ...
    next_position: int = ...
    symbol_table: dict[None, None] = ...
    input_fd: int = ...
    text: str = ...
    text_end: str = ...
    buffer: str = ...
    scope_id: int = ...
    msg_handler: typing.Callable[[Scanner, str, bool], None] = ...
    def cur_line(self) -> int: ...
    def cur_position(self) -> int: ...
    def cur_token(self) -> TokenType: ...
    def destroy(self) -> None: ...
    def eof(self) -> bool: ...
    def get_next_token(self) -> TokenType: ...
    def input_file(self, input_fd: int) -> None: ...
    def input_text(self, text: str, text_len: int) -> None: ...
    def lookup_symbol(self, symbol: str) -> None: ...
    def peek_next_token(self) -> TokenType: ...
    def scope_add_symbol(self, scope_id: int, symbol: str, value: None) -> None: ...
    def scope_foreach_symbol(
        self, scope_id: int, func: typing.Callable[..., None], *user_data: typing.Any
    ) -> None: ...
    def scope_lookup_symbol(self, scope_id: int, symbol: str) -> None: ...
    def scope_remove_symbol(self, scope_id: int, symbol: str) -> None: ...
    def set_scope(self, scope_id: int) -> int: ...
    def sync_file_offset(self) -> None: ...
    def unexp_token(
        self,
        expected_token: TokenType,
        identifier_spec: str,
        symbol_spec: str,
        symbol_name: str,
        message: str,
        is_error: int,
    ) -> None: ...

class ScannerConfig(GObject.GPointer):
    """
    :Constructors:

    ::

        ScannerConfig()
    """

    cset_skip_characters: str = ...
    cset_identifier_first: str = ...
    cset_identifier_nth: str = ...
    cpair_comment_single: str = ...
    case_sensitive: int = ...
    skip_comment_multi: int = ...
    skip_comment_single: int = ...
    scan_comment_multi: int = ...
    scan_identifier: int = ...
    scan_identifier_1char: int = ...
    scan_identifier_NULL: int = ...
    scan_symbols: int = ...
    scan_binary: int = ...
    scan_octal: int = ...
    scan_float: int = ...
    scan_hex: int = ...
    scan_hex_dollar: int = ...
    scan_string_sq: int = ...
    scan_string_dq: int = ...
    numbers_2_int: int = ...
    int_2_float: int = ...
    identifier_2_string: int = ...
    char_2_token: int = ...
    symbol_2_token: int = ...
    scope_0_fallback: int = ...
    store_int64: int = ...
    padding_dummy: int = ...

class Sequence(GObject.GPointer):
    def append(self, data: None) -> SequenceIter: ...
    def foreach(
        self, func: typing.Callable[..., None], *user_data: typing.Any
    ) -> None: ...
    @staticmethod
    def foreach_range(
        begin: SequenceIter,
        end: SequenceIter,
        func: typing.Callable[..., None],
        *user_data: typing.Any,
    ) -> None: ...
    def free(self) -> None: ...
    @staticmethod
    def get(iter: SequenceIter) -> None: ...
    def get_begin_iter(self) -> SequenceIter: ...
    def get_end_iter(self) -> SequenceIter: ...
    def get_iter_at_pos(self, pos: int) -> SequenceIter: ...
    def get_length(self) -> int: ...
    @staticmethod
    def insert_before(iter: SequenceIter, data: None) -> SequenceIter: ...
    def insert_sorted(
        self, data: None, cmp_func: typing.Callable[..., int], *cmp_data: typing.Any
    ) -> SequenceIter: ...
    def insert_sorted_iter(
        self, data: None, iter_cmp: typing.Callable[..., int], *cmp_data: typing.Any
    ) -> SequenceIter: ...
    def is_empty(self) -> bool: ...
    def lookup(
        self, data: None, cmp_func: typing.Callable[..., int], *cmp_data: typing.Any
    ) -> typing.Optional[SequenceIter]: ...
    def lookup_iter(
        self, data: None, iter_cmp: typing.Callable[..., int], *cmp_data: typing.Any
    ) -> typing.Optional[SequenceIter]: ...
    @staticmethod
    def move(src: SequenceIter, dest: SequenceIter) -> None: ...
    @staticmethod
    def move_range(
        dest: SequenceIter, begin: SequenceIter, end: SequenceIter
    ) -> None: ...
    def prepend(self, data: None) -> SequenceIter: ...
    @staticmethod
    def range_get_midpoint(begin: SequenceIter, end: SequenceIter) -> SequenceIter: ...
    @staticmethod
    def remove(iter: SequenceIter) -> None: ...
    @staticmethod
    def remove_range(begin: SequenceIter, end: SequenceIter) -> None: ...
    def search(
        self, data: None, cmp_func: typing.Callable[..., int], *cmp_data: typing.Any
    ) -> SequenceIter: ...
    def search_iter(
        self, data: None, iter_cmp: typing.Callable[..., int], *cmp_data: typing.Any
    ) -> SequenceIter: ...
    @staticmethod
    def set(iter: SequenceIter, data: None) -> None: ...
    def sort(
        self, cmp_func: typing.Callable[..., int], *cmp_data: typing.Any
    ) -> None: ...
    @staticmethod
    def sort_changed(
        iter: SequenceIter, cmp_func: typing.Callable[..., int], *cmp_data: typing.Any
    ) -> None: ...
    @staticmethod
    def sort_changed_iter(
        iter: SequenceIter, iter_cmp: typing.Callable[..., int], *cmp_data: typing.Any
    ) -> None: ...
    def sort_iter(
        self, cmp_func: typing.Callable[..., int], *cmp_data: typing.Any
    ) -> None: ...
    @staticmethod
    def swap(a: SequenceIter, b: SequenceIter) -> None: ...

class SequenceIter(GObject.GPointer):
    def compare(self, b: SequenceIter) -> int: ...
    def get_position(self) -> int: ...
    def get_sequence(self) -> Sequence: ...
    def is_begin(self) -> bool: ...
    def is_end(self) -> bool: ...
    def move(self, delta: int) -> SequenceIter: ...
    def next(self) -> SequenceIter: ...
    def prev(self) -> SequenceIter: ...

class Source(GObject.GBoxed):
    """
    :Constructors:

    ::

        Source()
        new(source_funcs:GLib.SourceFuncs, struct_size:int) -> GLib.Source
    """

    callback_data: None = ...
    callback_funcs: SourceCallbackFuncs = ...
    source_funcs: SourceFuncs = ...
    ref_count: int = ...
    context: MainContext = ...
    priority: int = ...
    flags: int = ...
    source_id: int = ...
    poll_fds: list[None] = ...
    prev: Source = ...
    next: Source = ...
    name: str = ...
    priv: SourcePrivate = ...
    can_recurse = ...  # FIXME Constant

    def add_child_source(self, child_source: Source) -> None: ...
    def add_poll(self, fd: PollFD) -> None: ...
    def add_unix_fd(self, fd: int, events: IOCondition) -> None: ...
    def attach(self, context: typing.Optional[MainContext] = None) -> int: ...
    def destroy(self) -> None: ...
    def finalize(self): ...  # FIXME Function
    def get_can_recurse(self) -> bool: ...
    def get_context(self) -> typing.Optional[MainContext]: ...
    def get_current_time(self): ...  # FIXME Function
    def get_id(self) -> int: ...
    def get_name(self) -> typing.Optional[str]: ...
    def get_priority(self) -> int: ...
    def get_ready_time(self) -> int: ...
    def get_time(self) -> int: ...
    def is_destroyed(self) -> bool: ...
    def modify_unix_fd(self, tag: None, new_events: IOCondition) -> None: ...
    @classmethod
    def new(cls, source_funcs: SourceFuncs, struct_size: int) -> Source: ...
    def query_unix_fd(self, tag: None) -> IOCondition: ...
    def ref(self) -> Source: ...
    @staticmethod
    def remove(tag: int) -> bool: ...
    @staticmethod
    def remove_by_funcs_user_data(funcs: SourceFuncs, user_data: None) -> bool: ...
    @staticmethod
    def remove_by_user_data(user_data: None) -> bool: ...
    def remove_child_source(self, child_source: Source) -> None: ...
    def remove_poll(self, fd: PollFD) -> None: ...
    def remove_unix_fd(self, tag: None) -> None: ...
    def set_callback(self, fn, user_data=None): ...  # FIXME Function
    def set_callback_indirect(
        self, callback_data: None, callback_funcs: SourceCallbackFuncs
    ) -> None: ...
    def set_can_recurse(self, can_recurse: bool) -> None: ...
    def set_funcs(self, funcs: SourceFuncs) -> None: ...
    def set_name(self, name: str) -> None: ...
    @staticmethod
    def set_name_by_id(tag: int, name: str) -> None: ...
    def set_priority(self, priority: int) -> None: ...
    def set_ready_time(self, ready_time: int) -> None: ...
    def set_static_name(self, name: str) -> None: ...
    def unref(self) -> None: ...

class SourceCallbackFuncs(GObject.GPointer):
    """
    :Constructors:

    ::

        SourceCallbackFuncs()
    """

    ref: typing.Callable[[None], None] = ...
    unref: typing.Callable[[None], None] = ...
    get: None = ...

class SourceFuncs(GObject.GPointer):
    """
    :Constructors:

    ::

        SourceFuncs()
    """

    prepare: typing.Callable[[Source, int], bool] = ...
    check: typing.Callable[[Source], bool] = ...
    dispatch: None = ...
    finalize: typing.Callable[[Source], None] = ...
    closure_callback: typing.Callable[..., bool] = ...
    closure_marshal: typing.Callable[[], None] = ...

class SourcePrivate(GObject.GPointer): ...
class StatBuf(GObject.GPointer): ...

class String(GObject.GBoxed):
    """
    :Constructors:

    ::

        String()
        new(init:str=None) -> GLib.String
        new_len(init:str, len:int) -> GLib.String
        new_take(init:str=None) -> GLib.String
        sized_new(dfl_size:int) -> GLib.String
    """

    str: str = ...
    len: int = ...
    allocated_len: int = ...
    def append(self, val: str) -> String: ...
    def append_c(self, c: int) -> String: ...
    def append_len(self, val: str, len: int) -> String: ...
    def append_unichar(self, wc: str) -> String: ...
    def append_uri_escaped(
        self, unescaped: str, reserved_chars_allowed: str, allow_utf8: bool
    ) -> String: ...
    def ascii_down(self) -> String: ...
    def ascii_up(self) -> String: ...
    def assign(self, rval: str) -> String: ...
    def down(self) -> String: ...
    def equal(self, v2: String) -> bool: ...
    def erase(self, pos: int, len: int) -> String: ...
    def free(self, free_segment: bool) -> typing.Optional[str]: ...
    def free_and_steal(self) -> str: ...
    def free_to_bytes(self) -> Bytes: ...
    def hash(self) -> int: ...
    def insert(self, pos: int, val: str) -> String: ...
    def insert_c(self, pos: int, c: int) -> String: ...
    def insert_len(self, pos: int, val: str, len: int) -> String: ...
    def insert_unichar(self, pos: int, wc: str) -> String: ...
    @classmethod
    def new(cls, init: typing.Optional[str] = None) -> String: ...
    @classmethod
    def new_len(cls, init: str, len: int) -> String: ...
    @classmethod
    def new_take(cls, init: typing.Optional[str] = None) -> String: ...
    def overwrite(self, pos: int, val: str) -> String: ...
    def overwrite_len(self, pos: int, val: str, len: int) -> String: ...
    def prepend(self, val: str) -> String: ...
    def prepend_c(self, c: int) -> String: ...
    def prepend_len(self, val: str, len: int) -> String: ...
    def prepend_unichar(self, wc: str) -> String: ...
    def replace(self, find: str, replace: str, limit: int) -> int: ...
    def set_size(self, len: int) -> String: ...
    @classmethod
    def sized_new(cls, dfl_size: int) -> String: ...
    def truncate(self, len: int) -> String: ...
    def up(self) -> String: ...

class StringChunk(GObject.GPointer):
    def clear(self) -> None: ...
    def free(self) -> None: ...
    def insert(self, string: str) -> str: ...
    def insert_const(self, string: str) -> str: ...
    def insert_len(self, string: str, len: int) -> str: ...

class StrvBuilder(GObject.GBoxed):
    """
    :Constructors:

    ::

        new() -> GLib.StrvBuilder
    """

    def add(self, value: str) -> None: ...
    def addv(self, value: typing.Sequence[str]) -> None: ...
    def end(self) -> list[str]: ...
    @classmethod
    def new(cls) -> StrvBuilder: ...
    def ref(self) -> StrvBuilder: ...
    def take(self, value: str) -> None: ...
    def unref(self) -> None: ...

class TestCase(GObject.GPointer):
    def free(self) -> None: ...

class TestConfig(GObject.GPointer):
    """
    :Constructors:

    ::

        TestConfig()
    """

    test_initialized: bool = ...
    test_quick: bool = ...
    test_perf: bool = ...
    test_verbose: bool = ...
    test_quiet: bool = ...
    test_undefined: bool = ...

class TestLogBuffer(GObject.GPointer):
    """
    :Constructors:

    ::

        TestLogBuffer()
    """

    data: String = ...
    msgs: list[None] = ...
    def free(self) -> None: ...
    def push(self, n_bytes: int, bytes: int) -> None: ...

class TestLogMsg(GObject.GPointer):
    """
    :Constructors:

    ::

        TestLogMsg()
    """

    log_type: TestLogType = ...
    n_strings: int = ...
    strings: str = ...
    n_nums: int = ...
    nums: None = ...
    def free(self) -> None: ...

class TestSuite(GObject.GPointer):
    def add(self, test_case: TestCase) -> None: ...
    def add_suite(self, nestedsuite: TestSuite) -> None: ...
    def free(self) -> None: ...

class Thread(GObject.GBoxed):
    """
    :Constructors:

    ::

        Thread()
        new(name:str=None, func:GLib.ThreadFunc, data=None) -> GLib.Thread
        try_new(name:str=None, func:GLib.ThreadFunc, data=None) -> GLib.Thread
    """

    func: typing.Callable[[None], None] = ...
    data: None = ...
    joinable: bool = ...
    priority: None = ...
    @staticmethod
    def error_quark() -> int: ...
    @staticmethod
    def exit(retval: None) -> None: ...
    def join(self) -> None: ...
    @classmethod
    def new(
        cls,
        name: typing.Optional[str],
        func: typing.Callable[..., None],
        *data: typing.Any,
    ) -> Thread: ...
    def ref(self) -> Thread: ...
    @staticmethod
    def self() -> Thread: ...
    @classmethod
    def try_new(
        cls,
        name: typing.Optional[str],
        func: typing.Callable[..., None],
        *data: typing.Any,
    ) -> Thread: ...
    def unref(self) -> None: ...
    @staticmethod
    def yield_() -> None: ...

class ThreadPool(GObject.GPointer):
    """
    :Constructors:

    ::

        ThreadPool()
    """

    func: typing.Callable[..., None] = ...
    user_data: None = ...
    exclusive: bool = ...
    def free(self, immediate: bool, wait_: bool) -> None: ...
    @staticmethod
    def get_max_idle_time() -> int: ...
    def get_max_threads(self) -> int: ...
    @staticmethod
    def get_max_unused_threads() -> int: ...
    def get_num_threads(self) -> int: ...
    @staticmethod
    def get_num_unused_threads() -> int: ...
    def move_to_front(self, data: None) -> bool: ...
    def push(self, data: None) -> bool: ...
    @staticmethod
    def set_max_idle_time(interval: int) -> None: ...
    def set_max_threads(self, max_threads: int) -> bool: ...
    @staticmethod
    def set_max_unused_threads(max_threads: int) -> None: ...
    @staticmethod
    def stop_unused_threads() -> None: ...
    def unprocessed(self) -> int: ...

class TimeVal(GObject.GPointer):
    """
    :Constructors:

    ::

        TimeVal()
    """

    tv_sec: int = ...
    tv_usec: int = ...
    def add(self, microseconds: int) -> None: ...
    @staticmethod
    def from_iso8601(iso_date: str) -> typing.Tuple[bool, TimeVal]: ...
    def to_iso8601(self) -> typing.Optional[str]: ...

class TimeZone(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(identifier:str=None) -> GLib.TimeZone
        new_identifier(identifier:str=None) -> GLib.TimeZone or None
        new_local() -> GLib.TimeZone
        new_offset(seconds:int) -> GLib.TimeZone
        new_utc() -> GLib.TimeZone
    """

    def adjust_time(self, type: TimeType) -> typing.Tuple[int, int]: ...
    def find_interval(self, type: TimeType, time_: int) -> int: ...
    def get_abbreviation(self, interval: int) -> str: ...
    def get_identifier(self) -> str: ...
    def get_offset(self, interval: int) -> int: ...
    def is_dst(self, interval: int) -> bool: ...
    @classmethod
    def new(cls, identifier: typing.Optional[str] = None) -> TimeZone: ...
    @classmethod
    def new_identifier(
        cls, identifier: typing.Optional[str] = None
    ) -> typing.Optional[TimeZone]: ...
    @classmethod
    def new_local(cls) -> TimeZone: ...
    @classmethod
    def new_offset(cls, seconds: int) -> TimeZone: ...
    @classmethod
    def new_utc(cls) -> TimeZone: ...
    def ref(self) -> TimeZone: ...
    def unref(self) -> None: ...

class Timeout(GObject.GBoxed):
    """
    :Constructors:

    ::

        Source()
        new(source_funcs:GLib.SourceFuncs, struct_size:int) -> GLib.Source
    """

    callback_data: None = ...
    callback_funcs: SourceCallbackFuncs = ...
    source_funcs: SourceFuncs = ...
    ref_count: int = ...
    context: MainContext = ...
    priority: int = ...
    flags: int = ...
    source_id: int = ...
    poll_fds: list[None] = ...
    prev: Source = ...
    next: Source = ...
    name: str = ...
    priv: SourcePrivate = ...
    can_recurse = ...  # FIXME Constant

    def add_child_source(self, child_source: Source) -> None: ...
    def add_poll(self, fd: PollFD) -> None: ...
    def add_unix_fd(self, fd: int, events: IOCondition) -> None: ...
    def attach(self, context: typing.Optional[MainContext] = None) -> int: ...
    def destroy(self) -> None: ...
    def finalize(self): ...  # FIXME Function
    def get_can_recurse(self) -> bool: ...
    def get_context(self) -> typing.Optional[MainContext]: ...
    def get_current_time(self): ...  # FIXME Function
    def get_id(self) -> int: ...
    def get_name(self) -> typing.Optional[str]: ...
    def get_priority(self) -> int: ...
    def get_ready_time(self) -> int: ...
    def get_time(self) -> int: ...
    def is_destroyed(self) -> bool: ...
    def modify_unix_fd(self, tag: None, new_events: IOCondition) -> None: ...
    @classmethod
    def new(cls, source_funcs: SourceFuncs, struct_size: int) -> Source: ...
    def query_unix_fd(self, tag: None) -> IOCondition: ...
    def ref(self) -> Source: ...
    @staticmethod
    def remove(tag: int) -> bool: ...
    @staticmethod
    def remove_by_funcs_user_data(funcs: SourceFuncs, user_data: None) -> bool: ...
    @staticmethod
    def remove_by_user_data(user_data: None) -> bool: ...
    def remove_child_source(self, child_source: Source) -> None: ...
    def remove_poll(self, fd: PollFD) -> None: ...
    def remove_unix_fd(self, tag: None) -> None: ...
    def set_callback(self, fn, user_data=None): ...  # FIXME Function
    def set_callback_indirect(
        self, callback_data: None, callback_funcs: SourceCallbackFuncs
    ) -> None: ...
    def set_can_recurse(self, can_recurse: bool) -> None: ...
    def set_funcs(self, funcs: SourceFuncs) -> None: ...
    def set_name(self, name: str) -> None: ...
    @staticmethod
    def set_name_by_id(tag: int, name: str) -> None: ...
    def set_priority(self, priority: int) -> None: ...
    def set_ready_time(self, ready_time: int) -> None: ...
    def set_static_name(self, name: str) -> None: ...
    def unref(self) -> None: ...

class Timer(GObject.GPointer):
    def continue_(self) -> None: ...
    def destroy(self) -> None: ...
    def elapsed(self, microseconds: int) -> float: ...
    def is_active(self) -> bool: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class TokenValue(GObject.GPointer):
    v_binary = ...  # FIXME Constant
    v_char = ...  # FIXME Constant
    v_comment = ...  # FIXME Constant
    v_error = ...  # FIXME Constant
    v_float = ...  # FIXME Constant
    v_hex = ...  # FIXME Constant
    v_identifier = ...  # FIXME Constant
    v_int = ...  # FIXME Constant
    v_int64 = ...  # FIXME Constant
    v_octal = ...  # FIXME Constant
    v_string = ...  # FIXME Constant
    v_symbol = ...  # FIXME Constant

class TrashStack(GObject.GPointer):
    """
    :Constructors:

    ::

        TrashStack()
    """

    next: TrashStack = ...
    @staticmethod
    def height(stack_p: TrashStack) -> int: ...
    @staticmethod
    def peek(stack_p: TrashStack) -> None: ...
    @staticmethod
    def pop(stack_p: TrashStack) -> None: ...
    @staticmethod
    def push(stack_p: TrashStack, data_p: None) -> None: ...

class Tree(GObject.GBoxed):
    """
    :Constructors:

    ::

        new_full(key_compare_func:GLib.CompareDataFunc, key_compare_data=None, key_destroy_func:GLib.DestroyNotify) -> GLib.Tree
    """

    def destroy(self) -> None: ...
    def foreach(
        self, func: typing.Callable[..., bool], *user_data: typing.Any
    ) -> None: ...
    def foreach_node(
        self, func: typing.Callable[..., bool], *user_data: typing.Any
    ) -> None: ...
    def height(self) -> int: ...
    def insert(self, key: None, value: None) -> None: ...
    def insert_node(self, key: None, value: None) -> typing.Optional[TreeNode]: ...
    def lookup(self, key: None) -> None: ...
    def lookup_extended(self, lookup_key: None) -> typing.Tuple[bool, None, None]: ...
    def lookup_node(self, key: None) -> typing.Optional[TreeNode]: ...
    def lower_bound(self, key: None) -> typing.Optional[TreeNode]: ...
    @classmethod
    def new_full(
        cls,
        key_compare_func: typing.Callable[..., int],
        key_destroy_func: typing.Callable[[None], None],
        *key_compare_data: typing.Any,
    ) -> Tree: ...
    def nnodes(self) -> int: ...
    def node_first(self) -> typing.Optional[TreeNode]: ...
    def node_last(self) -> typing.Optional[TreeNode]: ...
    def ref(self) -> Tree: ...
    def remove(self, key: None) -> bool: ...
    def remove_all(self) -> None: ...
    def replace(self, key: None, value: None) -> None: ...
    def replace_node(self, key: None, value: None) -> typing.Optional[TreeNode]: ...
    def search(
        self, search_func: typing.Callable[..., int], *user_data: typing.Any
    ) -> None: ...
    def search_node(
        self, search_func: typing.Callable[..., int], *user_data: typing.Any
    ) -> typing.Optional[TreeNode]: ...
    def steal(self, key: None) -> bool: ...
    def traverse(
        self,
        traverse_func: typing.Callable[..., bool],
        traverse_type: TraverseType,
        *user_data: typing.Any,
    ) -> None: ...
    def unref(self) -> None: ...
    def upper_bound(self, key: None) -> typing.Optional[TreeNode]: ...

class TreeNode(GObject.GPointer):
    def key(self) -> None: ...
    def next(self) -> typing.Optional[TreeNode]: ...
    def previous(self) -> typing.Optional[TreeNode]: ...
    def value(self) -> None: ...

class Tuples(GObject.GPointer):
    """
    :Constructors:

    ::

        Tuples()
    """

    len: int = ...
    def destroy(self) -> None: ...
    def index(self, index_: int, field: int) -> None: ...

class UnixPipe(GObject.GPointer):
    """
    :Constructors:

    ::

        UnixPipe()
    """

    fds: list[int] = ...

class Uri(GObject.GBoxed):
    @staticmethod
    def build(
        flags: UriFlags,
        scheme: str,
        userinfo: typing.Optional[str],
        host: typing.Optional[str],
        port: int,
        path: str,
        query: typing.Optional[str] = None,
        fragment: typing.Optional[str] = None,
    ) -> Uri: ...
    @staticmethod
    def build_with_user(
        flags: UriFlags,
        scheme: str,
        user: typing.Optional[str],
        password: typing.Optional[str],
        auth_params: typing.Optional[str],
        host: typing.Optional[str],
        port: int,
        path: str,
        query: typing.Optional[str] = None,
        fragment: typing.Optional[str] = None,
    ) -> Uri: ...
    @staticmethod
    def error_quark() -> int: ...
    @staticmethod
    def escape_bytes(
        unescaped: typing.Sequence[int],
        reserved_chars_allowed: typing.Optional[str] = None,
    ) -> str: ...
    @staticmethod
    def escape_string(
        unescaped: str, reserved_chars_allowed: typing.Optional[str], allow_utf8: bool
    ) -> str: ...
    def get_auth_params(self) -> typing.Optional[str]: ...
    def get_flags(self) -> UriFlags: ...
    def get_fragment(self) -> typing.Optional[str]: ...
    def get_host(self) -> typing.Optional[str]: ...
    def get_password(self) -> typing.Optional[str]: ...
    def get_path(self) -> str: ...
    def get_port(self) -> int: ...
    def get_query(self) -> typing.Optional[str]: ...
    def get_scheme(self) -> str: ...
    def get_user(self) -> typing.Optional[str]: ...
    def get_userinfo(self) -> typing.Optional[str]: ...
    @staticmethod
    def is_valid(uri_string: str, flags: UriFlags) -> bool: ...
    @staticmethod
    def join(
        flags: UriFlags,
        scheme: typing.Optional[str],
        userinfo: typing.Optional[str],
        host: typing.Optional[str],
        port: int,
        path: str,
        query: typing.Optional[str] = None,
        fragment: typing.Optional[str] = None,
    ) -> str: ...
    @staticmethod
    def join_with_user(
        flags: UriFlags,
        scheme: typing.Optional[str],
        user: typing.Optional[str],
        password: typing.Optional[str],
        auth_params: typing.Optional[str],
        host: typing.Optional[str],
        port: int,
        path: str,
        query: typing.Optional[str] = None,
        fragment: typing.Optional[str] = None,
    ) -> str: ...
    @staticmethod
    def list_extract_uris(uri_list: str) -> list[str]: ...
    @staticmethod
    def parse(uri_string: str, flags: UriFlags) -> Uri: ...
    @staticmethod
    def parse_params(
        params: str, length: int, separators: str, flags: UriParamsFlags
    ) -> dict[str, str]: ...
    def parse_relative(self, uri_ref: str, flags: UriFlags) -> Uri: ...
    @staticmethod
    def parse_scheme(uri: str) -> typing.Optional[str]: ...
    @staticmethod
    def peek_scheme(uri: str) -> typing.Optional[str]: ...
    @staticmethod
    def resolve_relative(
        base_uri_string: typing.Optional[str], uri_ref: str, flags: UriFlags
    ) -> str: ...
    @staticmethod
    def split(
        uri_ref: str, flags: UriFlags
    ) -> typing.Tuple[bool, str, str, str, int, str, str, str]: ...
    @staticmethod
    def split_network(
        uri_string: str, flags: UriFlags
    ) -> typing.Tuple[bool, str, str, int]: ...
    @staticmethod
    def split_with_user(
        uri_ref: str, flags: UriFlags
    ) -> typing.Tuple[bool, str, str, str, str, str, int, str, str, str]: ...
    def to_string(self) -> str: ...
    def to_string_partial(self, flags: UriHideFlags) -> str: ...
    @staticmethod
    def unescape_bytes(
        escaped_string: str,
        length: int,
        illegal_characters: typing.Optional[str] = None,
    ) -> Bytes: ...
    @staticmethod
    def unescape_segment(
        escaped_string: typing.Optional[str] = None,
        escaped_string_end: typing.Optional[str] = None,
        illegal_characters: typing.Optional[str] = None,
    ) -> typing.Optional[str]: ...
    @staticmethod
    def unescape_string(
        escaped_string: str, illegal_characters: typing.Optional[str] = None
    ) -> typing.Optional[str]: ...

class UriParamsIter(GObject.GPointer):
    """
    :Constructors:

    ::

        UriParamsIter()
    """

    dummy0: int = ...
    dummy1: None = ...
    dummy2: None = ...
    dummy3: bytes = ...
    def init(
        self, params: str, length: int, separators: str, flags: UriParamsFlags
    ) -> None: ...
    def next(self) -> typing.Tuple[bool, str, str]: ...

# override
class Variant(GObject.GPointer):
    """
    :Constructors:

    ::

        new_array(child_type:GLib.VariantType=None, children:list=None) -> GLib.Variant
        new_boolean(value:bool) -> GLib.Variant
        new_byte(value:int) -> GLib.Variant
        new_bytestring(string:list) -> GLib.Variant
        new_bytestring_array(strv:list) -> GLib.Variant
        new_dict_entry(key:GLib.Variant, value:GLib.Variant) -> GLib.Variant
        new_double(value:float) -> GLib.Variant
        new_fixed_array(element_type:GLib.VariantType, elements=None, n_elements:int, element_size:int) -> GLib.Variant
        new_from_bytes(type:GLib.VariantType, bytes:GLib.Bytes, trusted:bool) -> GLib.Variant
        new_from_data(type:GLib.VariantType, data:list, trusted:bool, notify:GLib.DestroyNotify, user_data=None) -> GLib.Variant
        new_handle(value:int) -> GLib.Variant
        new_int16(value:int) -> GLib.Variant
        new_int32(value:int) -> GLib.Variant
        new_int64(value:int) -> GLib.Variant
        new_maybe(child_type:GLib.VariantType=None, child:GLib.Variant=None) -> GLib.Variant
        new_object_path(object_path:str) -> GLib.Variant
        new_objv(strv:list) -> GLib.Variant
        new_signature(signature:str) -> GLib.Variant
        new_string(string:str) -> GLib.Variant
        new_strv(strv:list) -> GLib.Variant
        new_tuple(children:list) -> GLib.Variant
        new_uint16(value:int) -> GLib.Variant
        new_uint32(value:int) -> GLib.Variant
        new_uint64(value:int) -> GLib.Variant
        new_variant(value:GLib.Variant) -> GLib.Variant
    """

    def __init__(self, format_string: str, value: typing.Any) -> None: ...
    def byteswap(self) -> Variant: ...
    def check_format_string(self, format_string: str, copy_only: bool) -> bool: ...
    def classify(self) -> VariantClass: ...
    def compare(self, two: Variant) -> int: ...
    def dup_bytestring(self) -> bytes: ...
    def dup_bytestring_array(self) -> list[str]: ...
    def dup_objv(self) -> list[str]: ...
    def dup_string(self) -> typing.Tuple[str, int]: ...
    def dup_strv(self) -> list[str]: ...
    def equal(self, two: Variant) -> bool: ...
    def get_boolean(self) -> bool: ...
    def get_byte(self) -> int: ...
    def get_bytestring(self) -> bytes: ...
    def get_bytestring_array(self) -> list[str]: ...
    def get_child_value(self, index_: int) -> Variant: ...
    def get_data(self) -> None: ...
    def get_data_as_bytes(self) -> Bytes: ...
    def get_double(self) -> float: ...
    def get_handle(self) -> int: ...
    def get_int16(self) -> int: ...
    def get_int32(self) -> int: ...
    def get_int64(self) -> int: ...
    def get_maybe(self) -> typing.Optional[Variant]: ...
    def get_normal_form(self) -> Variant: ...
    def get_objv(self) -> list[str]: ...
    def get_size(self) -> int: ...
    def get_string(self) -> str: ...
    def get_strv(self) -> list[str]: ...
    def get_type(self) -> VariantType: ...
    def get_type_string(self) -> str: ...
    def get_uint16(self) -> int: ...
    def get_uint32(self) -> int: ...
    def get_uint64(self) -> int: ...
    def get_variant(self) -> Variant: ...
    def hash(self) -> int: ...
    def is_container(self) -> bool: ...
    def is_floating(self) -> bool: ...
    def is_normal_form(self) -> bool: ...
    @staticmethod
    def is_object_path(string: str) -> bool: ...
    def is_of_type(self, type: VariantType) -> bool: ...
    @staticmethod
    def is_signature(string: str) -> bool: ...
    def keys(self): ...
    def lookup_value(
        self, key: str, expected_type: typing.Optional[VariantType] = None
    ) -> Variant: ...
    def n_children(self) -> int: ...
    @classmethod
    def new_array(
        cls,
        child_type: typing.Optional[VariantType] = None,
        children: typing.Optional[typing.Sequence[Variant]] = None,
    ) -> Variant: ...
    @classmethod
    def new_boolean(cls, value: bool) -> Variant: ...
    @classmethod
    def new_byte(cls, value: int) -> Variant: ...
    @classmethod
    def new_bytestring(cls, string: typing.Sequence[int]) -> Variant: ...
    @classmethod
    def new_bytestring_array(cls, strv: typing.Sequence[str]) -> Variant: ...
    @classmethod
    def new_dict_entry(cls, key: Variant, value: Variant) -> Variant: ...
    @classmethod
    def new_double(cls, value: float) -> Variant: ...
    @classmethod
    def new_fixed_array(
        cls,
        element_type: VariantType,
        elements: None,
        n_elements: int,
        element_size: int,
    ) -> Variant: ...
    @classmethod
    def new_from_bytes(
        cls, type: VariantType, bytes: Bytes, trusted: bool
    ) -> Variant: ...
    @classmethod
    def new_from_data(
        cls,
        type: VariantType,
        data: typing.Sequence[int],
        trusted: bool,
        notify: typing.Callable[[None], None],
        user_data: None,
    ) -> Variant: ...
    @classmethod
    def new_handle(cls, value: int) -> Variant: ...
    @classmethod
    def new_int16(cls, value: int) -> Variant: ...
    @classmethod
    def new_int32(cls, value: int) -> Variant: ...
    @classmethod
    def new_int64(cls, value: int) -> Variant: ...
    @classmethod
    def new_maybe(
        cls,
        child_type: typing.Optional[VariantType] = None,
        child: typing.Optional[Variant] = None,
    ) -> Variant: ...
    @classmethod
    def new_object_path(cls, object_path: str) -> Variant: ...
    @classmethod
    def new_objv(cls, strv: typing.Sequence[str]) -> Variant: ...
    @classmethod
    def new_signature(cls, signature: str) -> Variant: ...
    @classmethod
    def new_string(cls, string: str) -> Variant: ...
    @classmethod
    def new_strv(cls, strv: typing.Sequence[str]) -> Variant: ...
    @classmethod
    def new_tuple(cls, children: Variant) -> Variant: ...
    @classmethod
    def new_uint16(cls, value: int) -> Variant: ...
    @classmethod
    def new_uint32(cls, value: int) -> Variant: ...
    @classmethod
    def new_uint64(cls, value: int) -> Variant: ...
    @classmethod
    def new_variant(cls, value: Variant) -> Variant: ...
    @staticmethod
    def parse(
        type: typing.Optional[VariantType],
        text: str,
        limit: typing.Optional[str] = None,
        endptr: typing.Optional[str] = None,
    ) -> Variant: ...
    @staticmethod
    def parse_error_print_context(error: Error, source_str: str) -> str: ...
    @staticmethod
    def parse_error_quark() -> int: ...
    @staticmethod
    def parser_get_error_quark() -> int: ...
    def print_(self, type_annotate: bool) -> str: ...
    def ref(self) -> Variant: ...
    def ref_sink(self) -> Variant: ...
    def split_signature(signature): ...
    def store(self, data: None) -> None: ...
    def take_ref(self) -> Variant: ...
    def unpack(self) -> typing.Any: ...
    def unref(self) -> None: ...
    def __getitem__(self, key: typing.Any) -> typing.Any: ...
    def __len__(self) -> int: ...

class VariantBuilder(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(type:GLib.VariantType) -> GLib.VariantBuilder
    """

    # override
    def __init__(self, type: VariantType): ...
    def add_value(self, value: Variant) -> None: ...
    def close(self) -> None: ...
    def end(self) -> Variant: ...
    @classmethod
    def new(cls, type: VariantType) -> VariantBuilder: ...
    def open(self, type: VariantType) -> None: ...
    def ref(self) -> VariantBuilder: ...
    def unref(self) -> None: ...

class VariantDict(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(from_asv:GLib.Variant=None) -> GLib.VariantDict
    """

    def clear(self) -> None: ...
    def contains(self, key: str) -> bool: ...
    def end(self) -> Variant: ...
    def insert_value(self, key: str, value: Variant) -> None: ...
    def lookup_value(
        self, key: str, expected_type: typing.Optional[VariantType] = None
    ) -> typing.Optional[Variant]: ...
    @classmethod
    def new(cls, from_asv: typing.Optional[Variant] = None) -> VariantDict: ...
    def ref(self) -> VariantDict: ...
    def remove(self, key: str) -> bool: ...
    def unref(self) -> None: ...

class VariantType(GObject.GBoxed):
    """
    :Constructors:

    ::

        new(type_string:str) -> GLib.VariantType
        new_array(element:GLib.VariantType) -> GLib.VariantType
        new_dict_entry(key:GLib.VariantType, value:GLib.VariantType) -> GLib.VariantType
        new_maybe(element:GLib.VariantType) -> GLib.VariantType
        new_tuple(items:list) -> GLib.VariantType
    """

    # override
    def __init__(self, string: str) -> None: ...
    @staticmethod
    def checked_(type_string: str) -> VariantType: ...
    def copy(self) -> VariantType: ...
    def dup_string(self) -> str: ...
    def element(self) -> VariantType: ...
    def equal(self, type2: VariantType) -> bool: ...
    def first(self) -> VariantType: ...
    def free(self) -> None: ...
    def get_string_length(self) -> int: ...
    def hash(self) -> int: ...
    def is_array(self) -> bool: ...
    def is_basic(self) -> bool: ...
    def is_container(self) -> bool: ...
    def is_definite(self) -> bool: ...
    def is_dict_entry(self) -> bool: ...
    def is_maybe(self) -> bool: ...
    def is_subtype_of(self, supertype: VariantType) -> bool: ...
    def is_tuple(self) -> bool: ...
    def is_variant(self) -> bool: ...
    def key(self) -> VariantType: ...
    def n_items(self) -> int: ...
    @classmethod
    def new(cls, type_string: str) -> VariantType: ...
    @classmethod
    def new_array(cls, element: VariantType) -> VariantType: ...
    @classmethod
    def new_dict_entry(cls, key: VariantType, value: VariantType) -> VariantType: ...
    @classmethod
    def new_maybe(cls, element: VariantType) -> VariantType: ...
    @classmethod
    def new_tuple(cls, items: typing.Sequence[VariantType]) -> VariantType: ...
    def next(self) -> VariantType: ...
    @staticmethod
    def string_get_depth_(type_string: str) -> int: ...
    @staticmethod
    def string_is_valid(type_string: str) -> bool: ...
    @staticmethod
    def string_scan(
        string: str, limit: typing.Optional[str] = None
    ) -> typing.Tuple[bool, str]: ...
    def value(self) -> VariantType: ...

class AsciiType(GObject.GFlags):
    ALNUM = 1
    ALPHA = 2
    CNTRL = 4
    DIGIT = 8
    GRAPH = 16
    LOWER = 32
    PRINT = 64
    PUNCT = 128
    SPACE = 256
    UPPER = 512
    XDIGIT = 1024

class FileSetContentsFlags(GObject.GFlags):
    CONSISTENT = 1
    DURABLE = 2
    NONE = 0
    ONLY_EXISTING = 4

class FileTest(GObject.GFlags):
    EXISTS = 16
    IS_DIR = 4
    IS_EXECUTABLE = 8
    IS_REGULAR = 1
    IS_SYMLINK = 2

class FormatSizeFlags(GObject.GFlags):
    BITS = 4
    DEFAULT = 0
    IEC_UNITS = 2
    LONG_FORMAT = 1
    ONLY_UNIT = 16
    ONLY_VALUE = 8

class HookFlagMask(GObject.GFlags):
    ACTIVE = 1
    IN_CALL = 2
    MASK = 15

class IOCondition(GObject.GFlags):
    ERR = 8
    HUP = 16
    IN = 1
    NVAL = 32
    OUT = 4
    PRI = 2

class IOFlags(GObject.GFlags):
    APPEND = 1
    GET_MASK = 31
    IS_READABLE = 4
    IS_SEEKABLE = 16
    IS_WRITABLE = 8
    IS_WRITEABLE = 8
    MASK = 31
    NONBLOCK = 2
    NONE = 0
    SET_MASK = 3

class KeyFileFlags(GObject.GFlags):
    KEEP_COMMENTS = 1
    KEEP_TRANSLATIONS = 2
    NONE = 0

class LogLevelFlags(GObject.GFlags):
    FLAG_FATAL = 2
    FLAG_RECURSION = 1
    LEVEL_CRITICAL = 8
    LEVEL_DEBUG = 128
    LEVEL_ERROR = 4
    LEVEL_INFO = 64
    LEVEL_MASK = 18446744073709551612
    LEVEL_MESSAGE = 32
    LEVEL_WARNING = 16

class MainContextFlags(GObject.GFlags):
    NONE = 0
    OWNERLESS_POLLING = 1

class MarkupCollectType(GObject.GFlags):
    BOOLEAN = 3
    INVALID = 0
    OPTIONAL = 65536
    STRDUP = 2
    STRING = 1
    TRISTATE = 4

class MarkupParseFlags(GObject.GFlags):
    DEFAULT_FLAGS = 0
    DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1
    IGNORE_QUALIFIED = 8
    PREFIX_ERROR_POSITION = 4
    TREAT_CDATA_AS_TEXT = 2

class OptionFlags(GObject.GFlags):
    FILENAME = 16
    HIDDEN = 1
    IN_MAIN = 2
    NOALIAS = 64
    NONE = 0
    NO_ARG = 8
    OPTIONAL_ARG = 32
    REVERSE = 4

class RegexCompileFlags(GObject.GFlags):
    ANCHORED = 16
    BSR_ANYCRLF = 8388608
    CASELESS = 1
    DEFAULT = 0
    DOLLAR_ENDONLY = 32
    DOTALL = 4
    DUPNAMES = 524288
    EXTENDED = 8
    FIRSTLINE = 262144
    JAVASCRIPT_COMPAT = 33554432
    MULTILINE = 2
    NEWLINE_ANYCRLF = 5242880
    NEWLINE_CR = 1048576
    NEWLINE_CRLF = 3145728
    NEWLINE_LF = 2097152
    NO_AUTO_CAPTURE = 4096
    OPTIMIZE = 8192
    RAW = 2048
    UNGREEDY = 512

class RegexMatchFlags(GObject.GFlags):
    ANCHORED = 16
    BSR_ANY = 16777216
    BSR_ANYCRLF = 8388608
    DEFAULT = 0
    NEWLINE_ANY = 4194304
    NEWLINE_ANYCRLF = 5242880
    NEWLINE_CR = 1048576
    NEWLINE_CRLF = 3145728
    NEWLINE_LF = 2097152
    NOTBOL = 128
    NOTEMPTY = 1024
    NOTEMPTY_ATSTART = 268435456
    NOTEOL = 256
    PARTIAL = 32768
    PARTIAL_HARD = 134217728
    PARTIAL_SOFT = 32768

class SpawnFlags(GObject.GFlags):
    CHILD_INHERITS_STDERR = 1024
    CHILD_INHERITS_STDIN = 32
    CHILD_INHERITS_STDOUT = 512
    CLOEXEC_PIPES = 256
    DEFAULT = 0
    DO_NOT_REAP_CHILD = 2
    FILE_AND_ARGV_ZERO = 64
    LEAVE_DESCRIPTORS_OPEN = 1
    SEARCH_PATH = 4
    SEARCH_PATH_FROM_ENVP = 128
    STDERR_TO_DEV_NULL = 16
    STDIN_FROM_DEV_NULL = 2048
    STDOUT_TO_DEV_NULL = 8

class TestSubprocessFlags(GObject.GFlags):
    DEFAULT = 0
    INHERIT_STDERR = 4
    INHERIT_STDIN = 1
    INHERIT_STDOUT = 2

class TestTrapFlags(GObject.GFlags):
    DEFAULT = 0
    INHERIT_STDIN = 512
    SILENCE_STDERR = 256
    SILENCE_STDOUT = 128

class TraverseFlags(GObject.GFlags):
    ALL = 3
    LEAFS = 1
    LEAVES = 1
    MASK = 3
    NON_LEAFS = 2
    NON_LEAVES = 2

class UriFlags(GObject.GFlags):
    ENCODED = 8
    ENCODED_FRAGMENT = 128
    ENCODED_PATH = 64
    ENCODED_QUERY = 32
    HAS_AUTH_PARAMS = 4
    HAS_PASSWORD = 2
    NONE = 0
    NON_DNS = 16
    PARSE_RELAXED = 1
    SCHEME_NORMALIZE = 256

class UriHideFlags(GObject.GFlags):
    AUTH_PARAMS = 4
    FRAGMENT = 16
    NONE = 0
    PASSWORD = 2
    QUERY = 8
    USERINFO = 1

class UriParamsFlags(GObject.GFlags):
    CASE_INSENSITIVE = 1
    NONE = 0
    PARSE_RELAXED = 4
    WWW_FORM = 2

class BookmarkFileError(GObject.GEnum):
    APP_NOT_REGISTERED = 2
    FILE_NOT_FOUND = 7
    INVALID_URI = 0
    INVALID_VALUE = 1
    READ = 4
    UNKNOWN_ENCODING = 5
    URI_NOT_FOUND = 3
    WRITE = 6

class ChecksumType(GObject.GEnum):
    MD5 = 0
    SHA1 = 1
    SHA256 = 2
    SHA384 = 4
    SHA512 = 3

class ConvertError(GObject.GEnum):
    BAD_URI = 4
    EMBEDDED_NUL = 7
    FAILED = 2
    ILLEGAL_SEQUENCE = 1
    NOT_ABSOLUTE_PATH = 5
    NO_CONVERSION = 0
    NO_MEMORY = 6
    PARTIAL_INPUT = 3

class DateDMY(GObject.GEnum):
    DAY = 0
    MONTH = 1
    YEAR = 2

class DateMonth(GObject.GEnum):
    APRIL = 4
    AUGUST = 8
    BAD_MONTH = 0
    DECEMBER = 12
    FEBRUARY = 2
    JANUARY = 1
    JULY = 7
    JUNE = 6
    MARCH = 3
    MAY = 5
    NOVEMBER = 11
    OCTOBER = 10
    SEPTEMBER = 9

class DateWeekday(GObject.GEnum):
    BAD_WEEKDAY = 0
    FRIDAY = 5
    MONDAY = 1
    SATURDAY = 6
    SUNDAY = 7
    THURSDAY = 4
    TUESDAY = 2
    WEDNESDAY = 3

class ErrorType(GObject.GEnum):
    DIGIT_RADIX = 5
    FLOAT_MALFORMED = 7
    FLOAT_RADIX = 6
    NON_DIGIT_IN_CONST = 4
    UNEXP_EOF = 1
    UNEXP_EOF_IN_COMMENT = 3
    UNEXP_EOF_IN_STRING = 2
    UNKNOWN = 0

class FileError(GObject.GEnum):
    ACCES = 2
    AGAIN = 19
    BADF = 16
    EXIST = 0
    FAILED = 24
    FAULT = 10
    INTR = 20
    INVAL = 17
    IO = 21
    ISDIR = 1
    LOOP = 11
    MFILE = 14
    NAMETOOLONG = 3
    NFILE = 15
    NODEV = 7
    NOENT = 4
    NOMEM = 13
    NOSPC = 12
    NOSYS = 23
    NOTDIR = 5
    NXIO = 6
    PERM = 22
    PIPE = 18
    ROFS = 8
    TXTBSY = 9

class IOChannelError(GObject.GEnum):
    FAILED = 8
    FBIG = 0
    INVAL = 1
    IO = 2
    ISDIR = 3
    NOSPC = 4
    NXIO = 5
    OVERFLOW = 6
    PIPE = 7

class IOError(GObject.GEnum):
    AGAIN = 1
    INVAL = 2
    NONE = 0
    UNKNOWN = 3

class IOStatus(GObject.GEnum):
    AGAIN = 3
    EOF = 2
    ERROR = 0
    NORMAL = 1

class KeyFileError(GObject.GEnum):
    GROUP_NOT_FOUND = 4
    INVALID_VALUE = 5
    KEY_NOT_FOUND = 3
    NOT_FOUND = 2
    PARSE = 1
    UNKNOWN_ENCODING = 0

class LogWriterOutput(GObject.GEnum):
    HANDLED = 1
    UNHANDLED = 0

class MarkupError(GObject.GEnum):
    BAD_UTF8 = 0
    EMPTY = 1
    INVALID_CONTENT = 5
    MISSING_ATTRIBUTE = 6
    PARSE = 2
    UNKNOWN_ATTRIBUTE = 4
    UNKNOWN_ELEMENT = 3

class NormalizeMode(GObject.GEnum):
    ALL = 2
    ALL_COMPOSE = 3
    DEFAULT = 0
    DEFAULT_COMPOSE = 1
    NFC = 1
    NFD = 0
    NFKC = 3
    NFKD = 2

class NumberParserError(GObject.GEnum):
    INVALID = 0
    OUT_OF_BOUNDS = 1

class OnceStatus(GObject.GEnum):
    NOTCALLED = 0
    PROGRESS = 1
    READY = 2

class OptionArg(GObject.GEnum):
    CALLBACK = 3
    DOUBLE = 7
    FILENAME = 4
    FILENAME_ARRAY = 6
    INT = 2
    INT64 = 8
    NONE = 0
    STRING = 1
    STRING_ARRAY = 5

class OptionError(GObject.GEnum):
    BAD_VALUE = 1
    FAILED = 2
    UNKNOWN_OPTION = 0

class RegexError(GObject.GEnum):
    ASSERTION_EXPECTED = 128
    BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159
    BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166
    CHARACTER_VALUE_TOO_LARGE = 176
    COMPILE = 0
    DEFINE_REPETION = 155
    DUPLICATE_SUBPATTERN_NAME = 143
    EXPRESSION_TOO_LARGE = 120
    EXTRA_SUBPATTERN_NAME = 165
    HEX_CODE_TOO_LARGE = 134
    INCONSISTENT_NEWLINE_OPTIONS = 156
    INEXISTENT_SUBPATTERN_REFERENCE = 115
    INFINITE_LOOP = 140
    INTERNAL = 4
    INVALID_CONDITION = 135
    INVALID_CONTROL_CHAR = 168
    INVALID_DATA_CHARACTER = 164
    INVALID_ESCAPE_IN_CHARACTER_CLASS = 107
    INVALID_OCTAL_VALUE = 151
    INVALID_RELATIVE_REFERENCE = 158
    MALFORMED_CONDITION = 126
    MALFORMED_PROPERTY = 146
    MATCH = 3
    MEMORY_ERROR = 121
    MISSING_BACK_REFERENCE = 157
    MISSING_CONTROL_CHAR = 102
    MISSING_DIGIT = 163
    MISSING_NAME = 169
    MISSING_SUBPATTERN_NAME = 162
    MISSING_SUBPATTERN_NAME_TERMINATOR = 142
    NAME_TOO_LONG = 175
    NOTHING_TO_REPEAT = 109
    NOT_SUPPORTED_IN_CLASS = 171
    NUMBER_TOO_BIG = 161
    OPTIMIZE = 1
    POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131
    POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113
    QUANTIFIERS_OUT_OF_ORDER = 104
    QUANTIFIER_TOO_BIG = 105
    RANGE_OUT_OF_ORDER = 108
    REPLACE = 2
    SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136
    STRAY_BACKSLASH = 101
    SUBPATTERN_NAME_TOO_LONG = 148
    TOO_MANY_BRANCHES_IN_DEFINE = 154
    TOO_MANY_CONDITIONAL_BRANCHES = 127
    TOO_MANY_FORWARD_REFERENCES = 172
    TOO_MANY_SUBPATTERNS = 149
    UNKNOWN_BACKTRACKING_CONTROL_VERB = 160
    UNKNOWN_POSIX_CLASS_NAME = 130
    UNKNOWN_PROPERTY = 147
    UNMATCHED_PARENTHESIS = 114
    UNRECOGNIZED_CHARACTER = 112
    UNRECOGNIZED_ESCAPE = 103
    UNTERMINATED_CHARACTER_CLASS = 106
    UNTERMINATED_COMMENT = 118
    VARIABLE_LENGTH_LOOKBEHIND = 125

class SeekType(GObject.GEnum):
    CUR = 0
    END = 2
    SET = 1

class ShellError(GObject.GEnum):
    BAD_QUOTING = 0
    EMPTY_STRING = 1
    FAILED = 2

class SliceConfig(GObject.GEnum):
    ALWAYS_MALLOC = 1
    BYPASS_MAGAZINES = 2
    CHUNK_SIZES = 5
    COLOR_INCREMENT = 4
    CONTENTION_COUNTER = 6
    WORKING_SET_MSECS = 3

class SpawnError(GObject.GEnum):
    ACCES = 3
    CHDIR = 2
    FAILED = 19
    FORK = 0
    INVAL = 16
    IO = 13
    ISDIR = 17
    LIBBAD = 18
    LOOP = 11
    MFILE = 15
    NAMETOOLONG = 7
    NFILE = 14
    NOENT = 8
    NOEXEC = 6
    NOMEM = 9
    NOTDIR = 10
    PERM = 4
    READ = 1
    TOO_BIG = 5
    TXTBUSY = 12

class TestFileType(GObject.GEnum):
    BUILT = 1
    DIST = 0

class TestLogType(GObject.GEnum):
    ERROR = 1
    LIST_CASE = 3
    MAX_RESULT = 8
    MESSAGE = 9
    MIN_RESULT = 7
    NONE = 0
    SKIP_CASE = 4
    START_BINARY = 2
    START_CASE = 5
    START_SUITE = 10
    STOP_CASE = 6
    STOP_SUITE = 11

class TestResult(GObject.GEnum):
    FAILURE = 2
    INCOMPLETE = 3
    SKIPPED = 1
    SUCCESS = 0

class ThreadError(GObject.GEnum):
    THREAD_ERROR_AGAIN = 0

class TimeType(GObject.GEnum):
    DAYLIGHT = 1
    STANDARD = 0
    UNIVERSAL = 2

class TokenType(GObject.GEnum):
    BINARY = 259
    CHAR = 258
    COMMA = 44
    COMMENT_MULTI = 269
    COMMENT_SINGLE = 268
    EOF = 0
    EQUAL_SIGN = 61
    ERROR = 257
    FLOAT = 263
    HEX = 262
    IDENTIFIER = 266
    IDENTIFIER_NULL = 267
    INT = 261
    LEFT_BRACE = 91
    LEFT_CURLY = 123
    LEFT_PAREN = 40
    NONE = 256
    OCTAL = 260
    RIGHT_BRACE = 93
    RIGHT_CURLY = 125
    RIGHT_PAREN = 41
    STRING = 264
    SYMBOL = 265

class TraverseType(GObject.GEnum):
    IN_ORDER = 0
    LEVEL_ORDER = 3
    POST_ORDER = 2
    PRE_ORDER = 1

class UnicodeBreakType(GObject.GEnum):
    AFTER = 10
    AKSARA = 43
    AKSARA_PRE_BASE = 44
    AKSARA_START = 45
    ALPHABETIC = 23
    AMBIGUOUS = 27
    BEFORE = 11
    BEFORE_AND_AFTER = 12
    CARRIAGE_RETURN = 1
    CLOSE_PARANTHESIS = 36
    CLOSE_PARENTHESIS = 36
    CLOSE_PUNCTUATION = 16
    COMBINING_MARK = 3
    COMPLEX_CONTEXT = 26
    CONDITIONAL_JAPANESE_STARTER = 37
    CONTINGENT = 8
    EMOJI_BASE = 40
    EMOJI_MODIFIER = 41
    EXCLAMATION = 18
    HANGUL_LVT_SYLLABLE = 35
    HANGUL_LV_SYLLABLE = 34
    HANGUL_L_JAMO = 31
    HANGUL_T_JAMO = 33
    HANGUL_V_JAMO = 32
    HEBREW_LETTER = 38
    HYPHEN = 13
    IDEOGRAPHIC = 19
    INFIX_SEPARATOR = 21
    INSEPARABLE = 6
    LINE_FEED = 2
    MANDATORY = 0
    NEXT_LINE = 29
    NON_BREAKING_GLUE = 7
    NON_STARTER = 14
    NUMERIC = 20
    OPEN_PUNCTUATION = 15
    POSTFIX = 25
    PREFIX = 24
    QUOTATION = 17
    REGIONAL_INDICATOR = 39
    SPACE = 9
    SURROGATE = 4
    SYMBOL = 22
    UNKNOWN = 28
    VIRAMA = 47
    VIRAMA_FINAL = 46
    WORD_JOINER = 30
    ZERO_WIDTH_JOINER = 42
    ZERO_WIDTH_SPACE = 5

class UnicodeScript(GObject.GEnum):
    ADLAM = 132
    AHOM = 126
    ANATOLIAN_HIEROGLYPHS = 127
    ARABIC = 2
    ARMENIAN = 3
    AVESTAN = 78
    BALINESE = 62
    BAMUM = 79
    BASSA_VAH = 103
    BATAK = 93
    BENGALI = 4
    BHAIKSUKI = 133
    BOPOMOFO = 5
    BRAHMI = 94
    BRAILLE = 46
    BUGINESE = 55
    BUHID = 44
    CANADIAN_ABORIGINAL = 40
    CARIAN = 75
    CAUCASIAN_ALBANIAN = 104
    CHAKMA = 96
    CHAM = 72
    CHEROKEE = 6
    CHORASMIAN = 153
    COMMON = 0
    COPTIC = 7
    CUNEIFORM = 63
    CYPRIOT = 47
    CYPRO_MINOAN = 157
    CYRILLIC = 8
    DESERET = 9
    DEVANAGARI = 10
    DIVES_AKURU = 154
    DOGRA = 142
    DUPLOYAN = 105
    EGYPTIAN_HIEROGLYPHS = 80
    ELBASAN = 106
    ELYMAIC = 149
    ETHIOPIC = 11
    GEORGIAN = 12
    GLAGOLITIC = 56
    GOTHIC = 13
    GRANTHA = 107
    GREEK = 14
    GUJARATI = 15
    GUNJALA_GONDI = 143
    GURMUKHI = 16
    HAN = 17
    HANGUL = 18
    HANIFI_ROHINGYA = 144
    HANUNOO = 43
    HATRAN = 128
    HEBREW = 19
    HIRAGANA = 20
    IMPERIAL_ARAMAIC = 81
    INHERITED = 1
    INSCRIPTIONAL_PAHLAVI = 82
    INSCRIPTIONAL_PARTHIAN = 83
    INVALID_CODE = -1
    JAVANESE = 84
    KAITHI = 85
    KANNADA = 21
    KATAKANA = 22
    KAWI = 163
    KAYAH_LI = 67
    KHAROSHTHI = 60
    KHITAN_SMALL_SCRIPT = 155
    KHMER = 23
    KHOJKI = 108
    KHUDAWADI = 109
    LAO = 24
    LATIN = 25
    LEPCHA = 68
    LIMBU = 48
    LINEAR_A = 110
    LINEAR_B = 51
    LISU = 86
    LYCIAN = 76
    LYDIAN = 77
    MAHAJANI = 111
    MAKASAR = 145
    MALAYALAM = 26
    MANDAIC = 95
    MANICHAEAN = 112
    MARCHEN = 134
    MASARAM_GONDI = 138
    MATH = 162
    MEDEFAIDRIN = 146
    MEETEI_MAYEK = 87
    MENDE_KIKAKUI = 113
    MEROITIC_CURSIVE = 97
    MEROITIC_HIEROGLYPHS = 98
    MIAO = 99
    MODI = 114
    MONGOLIAN = 27
    MRO = 115
    MULTANI = 129
    MYANMAR = 28
    NABATAEAN = 116
    NAG_MUNDARI = 164
    NANDINAGARI = 150
    NEWA = 135
    NEW_TAI_LUE = 54
    NKO = 66
    NUSHU = 139
    NYIAKENG_PUACHUE_HMONG = 151
    OGHAM = 29
    OLD_HUNGARIAN = 130
    OLD_ITALIC = 30
    OLD_NORTH_ARABIAN = 117
    OLD_PERMIC = 118
    OLD_PERSIAN = 59
    OLD_SOGDIAN = 147
    OLD_SOUTH_ARABIAN = 88
    OLD_TURKIC = 89
    OLD_UYGHUR = 158
    OL_CHIKI = 73
    ORIYA = 31
    OSAGE = 136
    OSMANYA = 49
    PAHAWH_HMONG = 119
    PALMYRENE = 120
    PAU_CIN_HAU = 121
    PHAGS_PA = 65
    PHOENICIAN = 64
    PSALTER_PAHLAVI = 122
    REJANG = 69
    RUNIC = 32
    SAMARITAN = 90
    SAURASHTRA = 71
    SHARADA = 100
    SHAVIAN = 50
    SIDDHAM = 123
    SIGNWRITING = 131
    SINHALA = 33
    SOGDIAN = 148
    SORA_SOMPENG = 101
    SOYOMBO = 140
    SUNDANESE = 70
    SYLOTI_NAGRI = 58
    SYRIAC = 34
    TAGALOG = 42
    TAGBANWA = 45
    TAI_LE = 52
    TAI_THAM = 91
    TAI_VIET = 92
    TAKRI = 102
    TAMIL = 35
    TANGSA = 159
    TANGUT = 137
    TELUGU = 36
    THAANA = 37
    THAI = 38
    TIBETAN = 39
    TIFINAGH = 57
    TIRHUTA = 124
    TOTO = 160
    UGARITIC = 53
    UNKNOWN = 61
    VAI = 74
    VITHKUQI = 161
    WANCHO = 152
    WARANG_CITI = 125
    YEZIDI = 156
    YI = 41
    ZANABAZAR_SQUARE = 141
    @staticmethod
    def from_iso15924(iso15924: int) -> UnicodeScript: ...
    @staticmethod
    def to_iso15924(script: UnicodeScript) -> int: ...

class UnicodeType(GObject.GEnum):
    CLOSE_PUNCTUATION = 18
    CONNECT_PUNCTUATION = 16
    CONTROL = 0
    CURRENCY_SYMBOL = 23
    DASH_PUNCTUATION = 17
    DECIMAL_NUMBER = 13
    ENCLOSING_MARK = 11
    FINAL_PUNCTUATION = 19
    FORMAT = 1
    INITIAL_PUNCTUATION = 20
    LETTER_NUMBER = 14
    LINE_SEPARATOR = 27
    LOWERCASE_LETTER = 5
    MATH_SYMBOL = 25
    MODIFIER_LETTER = 6
    MODIFIER_SYMBOL = 24
    NON_SPACING_MARK = 12
    OPEN_PUNCTUATION = 22
    OTHER_LETTER = 7
    OTHER_NUMBER = 15
    OTHER_PUNCTUATION = 21
    OTHER_SYMBOL = 26
    PARAGRAPH_SEPARATOR = 28
    PRIVATE_USE = 3
    SPACE_SEPARATOR = 29
    SPACING_MARK = 10
    SURROGATE = 4
    TITLECASE_LETTER = 8
    UNASSIGNED = 2
    UPPERCASE_LETTER = 9

class UnixPipeEnd(GObject.GEnum):
    READ = 0
    WRITE = 1

class UriError(GObject.GEnum):
    BAD_AUTH_PARAMS = 4
    BAD_FRAGMENT = 9
    BAD_HOST = 5
    BAD_PASSWORD = 3
    BAD_PATH = 7
    BAD_PORT = 6
    BAD_QUERY = 8
    BAD_SCHEME = 1
    BAD_USER = 2
    FAILED = 0

class UserDirectory(GObject.GEnum):
    DIRECTORY_DESKTOP = 0
    DIRECTORY_DOCUMENTS = 1
    DIRECTORY_DOWNLOAD = 2
    DIRECTORY_MUSIC = 3
    DIRECTORY_PICTURES = 4
    DIRECTORY_PUBLIC_SHARE = 5
    DIRECTORY_TEMPLATES = 6
    DIRECTORY_VIDEOS = 7
    N_DIRECTORIES = 8

class VariantClass(GObject.GEnum):
    ARRAY = 97
    BOOLEAN = 98
    BYTE = 121
    DICT_ENTRY = 123
    DOUBLE = 100
    HANDLE = 104
    INT16 = 110
    INT32 = 105
    INT64 = 120
    MAYBE = 109
    OBJECT_PATH = 111
    SIGNATURE = 103
    STRING = 115
    TUPLE = 40
    UINT16 = 113
    UINT32 = 117
    UINT64 = 116
    VARIANT = 118

class VariantParseError(GObject.GEnum):
    BASIC_TYPE_EXPECTED = 1
    CANNOT_INFER_TYPE = 2
    DEFINITE_TYPE_EXPECTED = 3
    FAILED = 0
    INPUT_NOT_AT_END = 4
    INVALID_CHARACTER = 5
    INVALID_FORMAT_STRING = 6
    INVALID_OBJECT_PATH = 7
    INVALID_SIGNATURE = 8
    INVALID_TYPE_STRING = 9
    NO_COMMON_TYPE = 10
    NUMBER_OUT_OF_RANGE = 11
    NUMBER_TOO_BIG = 12
    RECURSION = 18
    TYPE_ERROR = 13
    UNEXPECTED_TOKEN = 14
    UNKNOWN_KEYWORD = 15
    UNTERMINATED_STRING_CONSTANT = 16
    VALUE_EXPECTED = 17
