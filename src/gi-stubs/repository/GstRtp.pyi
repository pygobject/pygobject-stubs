from typing import Any
from typing import Callable
from typing import Literal
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TypeVar

from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gst
from gi.repository import GstBase

RTCP_MAX_BYE_SSRC_COUNT: int = 31
RTCP_MAX_RB_COUNT: int = 31
RTCP_MAX_SDES: int = 255
RTCP_MAX_SDES_ITEM_COUNT: int = 31
RTCP_REDUCED_SIZE_VALID_MASK: int = 49400
RTCP_VALID_MASK: int = 57598
RTCP_VALID_VALUE: int = 200
RTCP_VERSION: int = 2
RTP_HDREXT_BASE: str = "urn:ietf:params:rtp-hdrext:"
RTP_HDREXT_ELEMENT_CLASS: str = "Network/Extension/RTPHeader"
RTP_HDREXT_NTP_56: str = "ntp-56"
RTP_HDREXT_NTP_56_SIZE: int = 7
RTP_HDREXT_NTP_64: str = "ntp-64"
RTP_HDREXT_NTP_64_SIZE: int = 8
RTP_HEADER_EXTENSION_URI_METADATA_KEY: str = "RTP-Header-Extension-URI"
RTP_PAYLOAD_1016_STRING: str = "1"
RTP_PAYLOAD_CELLB_STRING: str = "25"
RTP_PAYLOAD_CN_STRING: str = "13"
RTP_PAYLOAD_DVI4_11025_STRING: str = "16"
RTP_PAYLOAD_DVI4_16000_STRING: str = "6"
RTP_PAYLOAD_DVI4_22050_STRING: str = "17"
RTP_PAYLOAD_DVI4_8000_STRING: str = "5"
RTP_PAYLOAD_DYNAMIC_STRING: str = "[96, 127]"
RTP_PAYLOAD_G721_STRING: str = "2"
RTP_PAYLOAD_G722_STRING: str = "9"
RTP_PAYLOAD_G723_53: int = 17
RTP_PAYLOAD_G723_53_STRING: str = "17"
RTP_PAYLOAD_G723_63: int = 16
RTP_PAYLOAD_G723_63_STRING: str = "16"
RTP_PAYLOAD_G723_STRING: str = "4"
RTP_PAYLOAD_G728_STRING: str = "15"
RTP_PAYLOAD_G729_STRING: str = "18"
RTP_PAYLOAD_GSM_STRING: str = "3"
RTP_PAYLOAD_H261_STRING: str = "31"
RTP_PAYLOAD_H263_STRING: str = "34"
RTP_PAYLOAD_JPEG_STRING: str = "26"
RTP_PAYLOAD_L16_MONO_STRING: str = "11"
RTP_PAYLOAD_L16_STEREO_STRING: str = "10"
RTP_PAYLOAD_LPC_STRING: str = "7"
RTP_PAYLOAD_MP2T_STRING: str = "33"
RTP_PAYLOAD_MPA_STRING: str = "14"
RTP_PAYLOAD_MPV_STRING: str = "32"
RTP_PAYLOAD_NV_STRING: str = "28"
RTP_PAYLOAD_PCMA_STRING: str = "8"
RTP_PAYLOAD_PCMU_STRING: str = "0"
RTP_PAYLOAD_QCELP_STRING: str = "12"
RTP_PAYLOAD_TS41: int = 19
RTP_PAYLOAD_TS41_STRING: str = "19"
RTP_PAYLOAD_TS48: int = 18
RTP_PAYLOAD_TS48_STRING: str = "18"
RTP_SOURCE_META_MAX_CSRC_COUNT: int = 15
RTP_VERSION: int = 2
_lock = ...  # FIXME Constant
_namespace: str = "GstRtp"
_version: str = "1.0"

def buffer_add_rtp_source_meta(
    buffer: Gst.Buffer, ssrc: Optional[int] = None, csrc: Optional[Sequence[int]] = None
) -> RTPSourceMeta: ...
def buffer_get_rtp_source_meta(buffer: Gst.Buffer) -> Optional[RTPSourceMeta]: ...
def rtcp_buffer_map(
    buffer: Gst.Buffer, flags: Gst.MapFlags, rtcp: RTCPBuffer
) -> bool: ...
def rtcp_buffer_new(mtu: int) -> Gst.Buffer: ...
def rtcp_buffer_new_copy_data(data: Sequence[int]) -> Gst.Buffer: ...
def rtcp_buffer_new_take_data(data: Sequence[int]) -> Gst.Buffer: ...
def rtcp_buffer_validate(buffer: Gst.Buffer) -> bool: ...
def rtcp_buffer_validate_data(data: Sequence[int]) -> bool: ...
def rtcp_buffer_validate_data_reduced(data: Sequence[int]) -> bool: ...
def rtcp_buffer_validate_reduced(buffer: Gst.Buffer) -> bool: ...
def rtcp_ntp_to_unix(ntptime: int) -> int: ...
def rtcp_sdes_name_to_type(name: str) -> RTCPSDESType: ...
def rtcp_sdes_type_to_name(type: RTCPSDESType) -> str: ...
def rtcp_unix_to_ntp(unixtime: int) -> int: ...
def rtp_buffer_allocate_data(
    buffer: Gst.Buffer, payload_len: int, pad_len: int, csrc_count: int
) -> None: ...
def rtp_buffer_calc_header_len(csrc_count: int) -> int: ...
def rtp_buffer_calc_packet_len(
    payload_len: int, pad_len: int, csrc_count: int
) -> int: ...
def rtp_buffer_calc_payload_len(
    packet_len: int, pad_len: int, csrc_count: int
) -> int: ...
def rtp_buffer_compare_seqnum(seqnum1: int, seqnum2: int) -> int: ...
def rtp_buffer_default_clock_rate(payload_type: int) -> int: ...
def rtp_buffer_ext_timestamp(timestamp: int) -> Tuple[int, int]: ...
def rtp_buffer_get_extension_onebyte_header_from_bytes(
    bytes: GLib.Bytes, bit_pattern: int, id: int, nth: int
) -> Tuple[bool, bytes]: ...
def rtp_buffer_map(
    buffer: Gst.Buffer, flags: Gst.MapFlags
) -> Tuple[bool, RTPBuffer]: ...
def rtp_buffer_new_allocate(
    payload_len: int, pad_len: int, csrc_count: int
) -> Gst.Buffer: ...
def rtp_buffer_new_allocate_len(
    packet_len: int, pad_len: int, csrc_count: int
) -> Gst.Buffer: ...
def rtp_buffer_new_copy_data(data: Sequence[int]) -> Gst.Buffer: ...
def rtp_buffer_new_take_data(data: Sequence[int]) -> Gst.Buffer: ...
def rtp_get_header_extension_list() -> list[Gst.ElementFactory]: ...
def rtp_hdrext_get_ntp_56(data: Sequence[int]) -> Tuple[bool, int]: ...
def rtp_hdrext_get_ntp_64(data: Sequence[int]) -> Tuple[bool, int]: ...
def rtp_hdrext_set_ntp_56(data: None, size: int, ntptime: int) -> bool: ...
def rtp_hdrext_set_ntp_64(data: None, size: int, ntptime: int) -> bool: ...
def rtp_payload_info_for_name(
    media: str, encoding_name: str
) -> Optional[RTPPayloadInfo]: ...
def rtp_payload_info_for_pt(payload_type: int) -> Optional[RTPPayloadInfo]: ...
def rtp_source_meta_api_get_type() -> Type: ...
def rtp_source_meta_get_info() -> Gst.MetaInfo: ...

class RTCPBuffer(GObject.GPointer):
    """
    :Constructors:

    ::

        RTCPBuffer()
    """

    buffer: Gst.Buffer = ...
    map: Gst.MapInfo = ...
    def add_packet(self, type: RTCPType, packet: RTCPPacket) -> bool: ...
    def get_first_packet(self, packet: RTCPPacket) -> bool: ...
    def get_packet_count(self) -> int: ...
    @staticmethod
    def map(buffer: Gst.Buffer, flags: Gst.MapFlags, rtcp: RTCPBuffer) -> bool: ...
    @staticmethod
    def new(mtu: int) -> Gst.Buffer: ...
    @staticmethod
    def new_copy_data(data: Sequence[int]) -> Gst.Buffer: ...
    @staticmethod
    def new_take_data(data: Sequence[int]) -> Gst.Buffer: ...
    def unmap(self) -> bool: ...
    @staticmethod
    def validate(buffer: Gst.Buffer) -> bool: ...
    @staticmethod
    def validate_data(data: Sequence[int]) -> bool: ...
    @staticmethod
    def validate_data_reduced(data: Sequence[int]) -> bool: ...
    @staticmethod
    def validate_reduced(buffer: Gst.Buffer) -> bool: ...

class RTCPPacket(GObject.GPointer):
    """
    :Constructors:

    ::

        RTCPPacket()
    """

    rtcp: RTCPBuffer = ...
    offset: int = ...
    padding: bool = ...
    count: int = ...
    type: RTCPType = ...
    length: int = ...
    item_offset: int = ...
    item_count: int = ...
    entry_offset: int = ...
    def add_profile_specific_ext(self, data: Sequence[int]) -> bool: ...
    def add_rb(
        self,
        ssrc: int,
        fractionlost: int,
        packetslost: int,
        exthighestseq: int,
        jitter: int,
        lsr: int,
        dlsr: int,
    ) -> bool: ...
    def app_get_data(self) -> int: ...
    def app_get_data_length(self) -> int: ...
    def app_get_name(self) -> str: ...
    def app_get_ssrc(self) -> int: ...
    def app_get_subtype(self) -> int: ...
    def app_set_data_length(self, wordlen: int) -> bool: ...
    def app_set_name(self, name: str) -> None: ...
    def app_set_ssrc(self, ssrc: int) -> None: ...
    def app_set_subtype(self, subtype: int) -> None: ...
    def bye_add_ssrc(self, ssrc: int) -> bool: ...
    def bye_add_ssrcs(self, ssrc: Sequence[int]) -> bool: ...
    def bye_get_nth_ssrc(self, nth: int) -> int: ...
    def bye_get_reason(self) -> Optional[str]: ...
    def bye_get_reason_len(self) -> int: ...
    def bye_get_ssrc_count(self) -> int: ...
    def bye_set_reason(self, reason: str) -> bool: ...
    def copy_profile_specific_ext(self) -> Tuple[bool, bytes]: ...
    def fb_get_fci(self) -> int: ...
    def fb_get_fci_length(self) -> int: ...
    def fb_get_media_ssrc(self) -> int: ...
    def fb_get_sender_ssrc(self) -> int: ...
    def fb_get_type(self) -> RTCPFBType: ...
    def fb_set_fci_length(self, wordlen: int) -> bool: ...
    def fb_set_media_ssrc(self, ssrc: int) -> None: ...
    def fb_set_sender_ssrc(self, ssrc: int) -> None: ...
    def fb_set_type(self, type: RTCPFBType) -> None: ...
    def get_count(self) -> int: ...
    def get_length(self) -> int: ...
    def get_padding(self) -> bool: ...
    def get_profile_specific_ext(self) -> Tuple[bool, bytes]: ...
    def get_profile_specific_ext_length(self) -> int: ...
    def get_rb(self, nth: int) -> Tuple[int, int, int, int, int, int, int]: ...
    def get_rb_count(self) -> int: ...
    def get_type(self) -> RTCPType: ...
    def move_to_next(self) -> bool: ...
    def remove(self) -> bool: ...
    def rr_get_ssrc(self) -> int: ...
    def rr_set_ssrc(self, ssrc: int) -> None: ...
    def sdes_add_entry(self, type: RTCPSDESType, data: Sequence[int]) -> bool: ...
    def sdes_add_item(self, ssrc: int) -> bool: ...
    def sdes_copy_entry(self, type: RTCPSDESType) -> Tuple[bool, bytes]: ...
    def sdes_first_entry(self) -> bool: ...
    def sdes_first_item(self) -> bool: ...
    def sdes_get_entry(self, type: RTCPSDESType) -> Tuple[bool, bytes]: ...
    def sdes_get_item_count(self) -> int: ...
    def sdes_get_ssrc(self) -> int: ...
    def sdes_next_entry(self) -> bool: ...
    def sdes_next_item(self) -> bool: ...
    def set_rb(
        self,
        nth: int,
        ssrc: int,
        fractionlost: int,
        packetslost: int,
        exthighestseq: int,
        jitter: int,
        lsr: int,
        dlsr: int,
    ) -> None: ...
    def sr_get_sender_info(self) -> Tuple[int, int, int, int, int]: ...
    def sr_set_sender_info(
        self, ssrc: int, ntptime: int, rtptime: int, packet_count: int, octet_count: int
    ) -> None: ...
    def xr_first_rb(self) -> bool: ...
    def xr_get_block_length(self) -> int: ...
    def xr_get_block_type(self) -> RTCPXRType: ...
    def xr_get_dlrr_block(
        self, nth: int, ssrc: int, last_rr: int, delay: int
    ) -> bool: ...
    def xr_get_prt_by_seq(self, seq: int, receipt_time: int) -> bool: ...
    def xr_get_prt_info(
        self, ssrc: int, thinning: int, begin_seq: int, end_seq: int
    ) -> bool: ...
    def xr_get_rle_info(
        self, ssrc: int, thinning: int, begin_seq: int, end_seq: int, chunk_count: int
    ) -> bool: ...
    def xr_get_rle_nth_chunk(self, nth: int, chunk: int) -> bool: ...
    def xr_get_rrt(self, timestamp: int) -> bool: ...
    def xr_get_ssrc(self) -> int: ...
    def xr_get_summary_info(self, ssrc: int, begin_seq: int, end_seq: int) -> bool: ...
    def xr_get_summary_jitter(
        self, min_jitter: int, max_jitter: int, mean_jitter: int, dev_jitter: int
    ) -> bool: ...
    def xr_get_summary_pkt(self, lost_packets: int, dup_packets: int) -> bool: ...
    def xr_get_summary_ttl(
        self, is_ipv4: bool, min_ttl: int, max_ttl: int, mean_ttl: int, dev_ttl: int
    ) -> bool: ...
    def xr_get_voip_burst_metrics(
        self,
        burst_density: int,
        gap_density: int,
        burst_duration: int,
        gap_duration: int,
    ) -> bool: ...
    def xr_get_voip_configuration_params(self, gmin: int, rx_config: int) -> bool: ...
    def xr_get_voip_delay_metrics(
        self, roundtrip_delay: int, end_system_delay: int
    ) -> bool: ...
    def xr_get_voip_jitter_buffer_params(
        self, jb_nominal: int, jb_maximum: int, jb_abs_max: int
    ) -> bool: ...
    def xr_get_voip_metrics_ssrc(self, ssrc: int) -> bool: ...
    def xr_get_voip_packet_metrics(self, loss_rate: int, discard_rate: int) -> bool: ...
    def xr_get_voip_quality_metrics(
        self, r_factor: int, ext_r_factor: int, mos_lq: int, mos_cq: int
    ) -> bool: ...
    def xr_get_voip_signal_metrics(
        self, signal_level: int, noise_level: int, rerl: int, gmin: int
    ) -> bool: ...
    def xr_next_rb(self) -> bool: ...

class RTPBaseAudioPayload(RTPBasePayload):
    """
    :Constructors:

    ::

        RTPBaseAudioPayload(**properties)

    Object GstRTPBaseAudioPayload

    Properties from GstRTPBaseAudioPayload:
      buffer-list -> gboolean: Buffer List
        Use Buffer Lists

    Signals from GstRTPBasePayload:
      add-extension (GstRTPHeaderExtension)
      request-extension (guint, gchararray) -> GstRTPHeaderExtension
      clear-extensions ()

    Properties from GstRTPBasePayload:
      mtu -> guint: MTU
        Maximum size of one packet
      pt -> guint: payload type
        The payload type of the packets
      ssrc -> guint: SSRC
        The SSRC of the packets (default == random)
      timestamp-offset -> guint: Timestamp Offset
        Offset to add to all outgoing timestamps (default = random)
      seqnum-offset -> gint: Sequence number Offset
        Offset to add to all outgoing seqnum (-1 = random)
      max-ptime -> gint64: Max packet time
        Maximum duration of the packet data in ns (-1 = unlimited up to MTU)
      min-ptime -> gint64: Min packet time
        Minimum duration of the packet data in ns (can't go above MTU)
      timestamp -> guint: Timestamp
        The RTP timestamp of the last processed packet
      seqnum -> guint: Sequence number
        The RTP sequence number of the last processed packet
      perfect-rtptime -> gboolean: Perfect RTP Time
        Generate perfect RTP timestamps when possible
      ptime-multiple -> gint64: Packet time multiple
        Force buffers to be multiples of this duration in ns (0 disables)
      source-info -> gboolean: RTP source information
        Write CSRC based on buffer meta RTP source information
      onvif-no-rate-control -> gboolean: ONVIF no rate control
        Enable ONVIF Rate-Control=no timestamping mode
      scale-rtptime -> gboolean: Scale RTP time
        Whether the RTP timestamp should be scaled with the rate (speed)
      auto-header-extension -> gboolean: Automatic RTP header extension
        Whether RTP header extensions should be automatically enabled, if an implementation is available

    Signals from GstElement:
      pad-added (GstPad)
      pad-removed (GstPad)
      no-more-pads ()

    Signals from GstObject:
      deep-notify (GstObject, GParam)

    Properties from GstObject:
      name -> gchararray: Name
        The name of the object
      parent -> GstObject: Parent
        The parent of the object

    Signals from GObject:
      notify (GParam)
    """

    class Props:
        buffer_list: bool
        auto_header_extension: bool
        max_ptime: int
        min_ptime: int
        mtu: int
        onvif_no_rate_control: bool
        perfect_rtptime: bool
        pt: int
        ptime_multiple: int
        scale_rtptime: bool
        seqnum: int
        seqnum_offset: int
        source_info: bool
        ssrc: int
        stats: Gst.Structure
        timestamp: int
        timestamp_offset: int
        name: Optional[str]
        parent: Optional[Gst.Object]

    props: Props = ...
    payload: RTPBasePayload = ...
    priv: RTPBaseAudioPayloadPrivate = ...
    base_ts: int = ...
    frame_size: int = ...
    frame_duration: int = ...
    sample_size: int = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        buffer_list: bool = ...,
        auto_header_extension: bool = ...,
        max_ptime: int = ...,
        min_ptime: int = ...,
        mtu: int = ...,
        onvif_no_rate_control: bool = ...,
        perfect_rtptime: bool = ...,
        pt: int = ...,
        ptime_multiple: int = ...,
        scale_rtptime: bool = ...,
        seqnum_offset: int = ...,
        source_info: bool = ...,
        ssrc: int = ...,
        timestamp_offset: int = ...,
        name: Optional[str] = ...,
        parent: Gst.Object = ...,
    ): ...
    def flush(self, payload_len: int, timestamp: int) -> Gst.FlowReturn: ...
    def get_adapter(self) -> GstBase.Adapter: ...
    def push(self, data: Sequence[int], timestamp: int) -> Gst.FlowReturn: ...
    def set_frame_based(self) -> None: ...
    def set_frame_options(self, frame_duration: int, frame_size: int) -> None: ...
    def set_sample_based(self) -> None: ...
    def set_sample_options(self, sample_size: int) -> None: ...
    def set_samplebits_options(self, sample_size: int) -> None: ...

class RTPBaseAudioPayloadClass(GObject.GPointer):
    """
    :Constructors:

    ::

        RTPBaseAudioPayloadClass()
    """

    parent_class: RTPBasePayloadClass = ...
    _gst_reserved: list[None] = ...

class RTPBaseAudioPayloadPrivate(GObject.GPointer): ...

class RTPBaseDepayload(Gst.Element):
    """
    :Constructors:

    ::

        RTPBaseDepayload(**properties)

    Object GstRTPBaseDepayload

    Signals from GstRTPBaseDepayload:
      add-extension (GstRTPHeaderExtension)
      request-extension (guint, gchararray) -> GstRTPHeaderExtension
      clear-extensions ()

    Properties from GstRTPBaseDepayload:
      source-info -> gboolean: RTP source information
        Add RTP source information as buffer meta
      max-reorder -> gint: Max Reorder
        Max seqnum reorder before assuming sender has restarted
      auto-header-extension -> gboolean: Automatic RTP header extension
        Whether RTP header extensions should be automatically enabled, if an implementation is available

    Signals from GstElement:
      pad-added (GstPad)
      pad-removed (GstPad)
      no-more-pads ()

    Signals from GstObject:
      deep-notify (GstObject, GParam)

    Properties from GstObject:
      name -> gchararray: Name
        The name of the object
      parent -> GstObject: Parent
        The parent of the object

    Signals from GObject:
      notify (GParam)
    """

    class Props:
        auto_header_extension: bool
        max_reorder: int
        source_info: bool
        stats: Gst.Structure
        name: Optional[str]
        parent: Optional[Gst.Object]

    props: Props = ...
    parent: Gst.Element = ...
    sinkpad: Gst.Pad = ...
    srcpad: Gst.Pad = ...
    clock_rate: int = ...
    segment: Gst.Segment = ...
    need_newsegment: bool = ...
    priv: RTPBaseDepayloadPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        auto_header_extension: bool = ...,
        max_reorder: int = ...,
        source_info: bool = ...,
        name: Optional[str] = ...,
        parent: Gst.Object = ...,
    ): ...
    def do_handle_event(self, event: Gst.Event) -> bool: ...
    def do_packet_lost(self, event: Gst.Event) -> bool: ...
    def do_process(self, in_: Gst.Buffer) -> Gst.Buffer: ...
    def do_process_rtp_packet(self, rtp_buffer: RTPBuffer) -> Gst.Buffer: ...
    def do_set_caps(self, caps: Gst.Caps) -> bool: ...
    def is_source_info_enabled(self) -> bool: ...
    def push(self, out_buf: Gst.Buffer) -> Gst.FlowReturn: ...
    def push_list(self, out_list: Gst.BufferList) -> Gst.FlowReturn: ...
    def set_source_info_enabled(self, enable: bool) -> None: ...

class RTPBaseDepayloadClass(GObject.GPointer):
    """
    :Constructors:

    ::

        RTPBaseDepayloadClass()
    """

    parent_class: Gst.ElementClass = ...
    set_caps: Callable[[RTPBaseDepayload, Gst.Caps], bool] = ...
    process: Callable[[RTPBaseDepayload, Gst.Buffer], Gst.Buffer] = ...
    packet_lost: Callable[[RTPBaseDepayload, Gst.Event], bool] = ...
    handle_event: Callable[[RTPBaseDepayload, Gst.Event], bool] = ...
    process_rtp_packet: Callable[[RTPBaseDepayload, RTPBuffer], Gst.Buffer] = ...
    _gst_reserved: list[None] = ...

class RTPBaseDepayloadPrivate(GObject.GPointer): ...

class RTPBasePayload(Gst.Element):
    """
    :Constructors:

    ::

        RTPBasePayload(**properties)

    Object GstRTPBasePayload

    Signals from GstRTPBasePayload:
      add-extension (GstRTPHeaderExtension)
      request-extension (guint, gchararray) -> GstRTPHeaderExtension
      clear-extensions ()

    Properties from GstRTPBasePayload:
      mtu -> guint: MTU
        Maximum size of one packet
      pt -> guint: payload type
        The payload type of the packets
      ssrc -> guint: SSRC
        The SSRC of the packets (default == random)
      timestamp-offset -> guint: Timestamp Offset
        Offset to add to all outgoing timestamps (default = random)
      seqnum-offset -> gint: Sequence number Offset
        Offset to add to all outgoing seqnum (-1 = random)
      max-ptime -> gint64: Max packet time
        Maximum duration of the packet data in ns (-1 = unlimited up to MTU)
      min-ptime -> gint64: Min packet time
        Minimum duration of the packet data in ns (can't go above MTU)
      timestamp -> guint: Timestamp
        The RTP timestamp of the last processed packet
      seqnum -> guint: Sequence number
        The RTP sequence number of the last processed packet
      perfect-rtptime -> gboolean: Perfect RTP Time
        Generate perfect RTP timestamps when possible
      ptime-multiple -> gint64: Packet time multiple
        Force buffers to be multiples of this duration in ns (0 disables)
      source-info -> gboolean: RTP source information
        Write CSRC based on buffer meta RTP source information
      onvif-no-rate-control -> gboolean: ONVIF no rate control
        Enable ONVIF Rate-Control=no timestamping mode
      scale-rtptime -> gboolean: Scale RTP time
        Whether the RTP timestamp should be scaled with the rate (speed)
      auto-header-extension -> gboolean: Automatic RTP header extension
        Whether RTP header extensions should be automatically enabled, if an implementation is available

    Signals from GstElement:
      pad-added (GstPad)
      pad-removed (GstPad)
      no-more-pads ()

    Signals from GstObject:
      deep-notify (GstObject, GParam)

    Properties from GstObject:
      name -> gchararray: Name
        The name of the object
      parent -> GstObject: Parent
        The parent of the object

    Signals from GObject:
      notify (GParam)
    """

    class Props:
        auto_header_extension: bool
        max_ptime: int
        min_ptime: int
        mtu: int
        onvif_no_rate_control: bool
        perfect_rtptime: bool
        pt: int
        ptime_multiple: int
        scale_rtptime: bool
        seqnum: int
        seqnum_offset: int
        source_info: bool
        ssrc: int
        stats: Gst.Structure
        timestamp: int
        timestamp_offset: int
        name: Optional[str]
        parent: Optional[Gst.Object]

    props: Props = ...
    element: Gst.Element = ...
    sinkpad: Gst.Pad = ...
    srcpad: Gst.Pad = ...
    ts_base: int = ...
    seqnum_base: int = ...
    media: str = ...
    encoding_name: str = ...
    dynamic: bool = ...
    clock_rate: int = ...
    ts_offset: int = ...
    timestamp: int = ...
    seqnum_offset: int = ...
    seqnum: int = ...
    max_ptime: int = ...
    pt: int = ...
    ssrc: int = ...
    current_ssrc: int = ...
    mtu: int = ...
    segment: Gst.Segment = ...
    min_ptime: int = ...
    ptime: int = ...
    ptime_multiple: int = ...
    priv: RTPBasePayloadPrivate = ...
    _gst_reserved: list[None] = ...
    def __init__(
        self,
        auto_header_extension: bool = ...,
        max_ptime: int = ...,
        min_ptime: int = ...,
        mtu: int = ...,
        onvif_no_rate_control: bool = ...,
        perfect_rtptime: bool = ...,
        pt: int = ...,
        ptime_multiple: int = ...,
        scale_rtptime: bool = ...,
        seqnum_offset: int = ...,
        source_info: bool = ...,
        ssrc: int = ...,
        timestamp_offset: int = ...,
        name: Optional[str] = ...,
        parent: Gst.Object = ...,
    ): ...
    def allocate_output_buffer(
        self, payload_len: int, pad_len: int, csrc_count: int
    ) -> Gst.Buffer: ...
    def do_get_caps(self, pad: Gst.Pad, filter: Gst.Caps) -> Gst.Caps: ...
    def do_handle_buffer(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def do_set_caps(self, caps: Gst.Caps) -> bool: ...
    def do_sink_event(self, event: Gst.Event) -> bool: ...
    def do_src_event(self, event: Gst.Event) -> bool: ...
    def get_source_count(self, buffer: Gst.Buffer) -> int: ...
    def is_filled(self, size: int, duration: int) -> bool: ...
    def is_source_info_enabled(self) -> bool: ...
    def push(self, buffer: Gst.Buffer) -> Gst.FlowReturn: ...
    def push_list(self, list: Gst.BufferList) -> Gst.FlowReturn: ...
    def set_options(
        self, media: str, dynamic: bool, encoding_name: str, clock_rate: int
    ) -> None: ...
    def set_outcaps_structure(self, s: Optional[Gst.Structure] = None) -> bool: ...
    def set_source_info_enabled(self, enable: bool) -> None: ...

class RTPBasePayloadClass(GObject.GPointer):
    """
    :Constructors:

    ::

        RTPBasePayloadClass()
    """

    parent_class: Gst.ElementClass = ...
    get_caps: Callable[[RTPBasePayload, Gst.Pad, Gst.Caps], Gst.Caps] = ...
    set_caps: Callable[[RTPBasePayload, Gst.Caps], bool] = ...
    handle_buffer: Callable[[RTPBasePayload, Gst.Buffer], Gst.FlowReturn] = ...
    sink_event: Callable[[RTPBasePayload, Gst.Event], bool] = ...
    src_event: Callable[[RTPBasePayload, Gst.Event], bool] = ...
    query: Callable[[RTPBasePayload, Gst.Pad, Gst.Query], bool] = ...
    _gst_reserved: list[None] = ...

class RTPBasePayloadPrivate(GObject.GPointer): ...

class RTPBuffer(GObject.GPointer):
    """
    :Constructors:

    ::

        RTPBuffer()
    """

    buffer: Gst.Buffer = ...
    state: int = ...
    data: list[None] = ...
    size: list[int] = ...
    map: list[Gst.MapInfo] = ...
    def add_extension_onebyte_header(self, id: int, data: Sequence[int]) -> bool: ...
    def add_extension_twobytes_header(
        self, appbits: int, id: int, data: Sequence[int]
    ) -> bool: ...
    @staticmethod
    def allocate_data(
        buffer: Gst.Buffer, payload_len: int, pad_len: int, csrc_count: int
    ) -> None: ...
    @staticmethod
    def calc_header_len(csrc_count: int) -> int: ...
    @staticmethod
    def calc_packet_len(payload_len: int, pad_len: int, csrc_count: int) -> int: ...
    @staticmethod
    def calc_payload_len(packet_len: int, pad_len: int, csrc_count: int) -> int: ...
    @staticmethod
    def compare_seqnum(seqnum1: int, seqnum2: int) -> int: ...
    @staticmethod
    def default_clock_rate(payload_type: int) -> int: ...
    @staticmethod
    def ext_timestamp(timestamp: int) -> Tuple[int, int]: ...
    def get_csrc(self, idx: int) -> int: ...
    def get_csrc_count(self) -> int: ...
    def get_extension(self) -> bool: ...
    def get_extension_data(self) -> Tuple[Optional[GLib.Bytes], int]: ...
    def get_extension_onebyte_header(self, id: int, nth: int) -> Tuple[bool, bytes]: ...
    @staticmethod
    def get_extension_onebyte_header_from_bytes(
        bytes: GLib.Bytes, bit_pattern: int, id: int, nth: int
    ) -> Tuple[bool, bytes]: ...
    def get_extension_twobytes_header(
        self, id: int, nth: int
    ) -> Tuple[bool, int, bytes]: ...
    def get_header_len(self) -> int: ...
    def get_marker(self) -> bool: ...
    def get_packet_len(self) -> int: ...
    def get_padding(self) -> bool: ...
    def get_payload(self) -> Optional[GLib.Bytes]: ...
    def get_payload_buffer(self) -> Gst.Buffer: ...
    def get_payload_len(self) -> int: ...
    def get_payload_subbuffer(self, offset: int, len: int) -> Gst.Buffer: ...
    def get_payload_type(self) -> int: ...
    def get_seq(self) -> int: ...
    def get_ssrc(self) -> int: ...
    def get_timestamp(self) -> int: ...
    def get_version(self) -> int: ...
    @staticmethod
    def map(buffer: Gst.Buffer, flags: Gst.MapFlags) -> Tuple[bool, RTPBuffer]: ...
    @staticmethod
    def new_allocate(payload_len: int, pad_len: int, csrc_count: int) -> Gst.Buffer: ...
    @staticmethod
    def new_allocate_len(
        packet_len: int, pad_len: int, csrc_count: int
    ) -> Gst.Buffer: ...
    @staticmethod
    def new_copy_data(data: Sequence[int]) -> Gst.Buffer: ...
    @staticmethod
    def new_take_data(data: Sequence[int]) -> Gst.Buffer: ...
    def pad_to(self, len: int) -> None: ...
    def remove_extension_data(self) -> None: ...
    def set_csrc(self, idx: int, csrc: int) -> None: ...
    def set_extension(self, extension: bool) -> None: ...
    def set_extension_data(self, bits: int, length: int) -> bool: ...
    def set_marker(self, marker: bool) -> None: ...
    def set_packet_len(self, len: int) -> None: ...
    def set_padding(self, padding: bool) -> None: ...
    def set_payload_type(self, payload_type: int) -> None: ...
    def set_seq(self, seq: int) -> None: ...
    def set_ssrc(self, ssrc: int) -> None: ...
    def set_timestamp(self, timestamp: int) -> None: ...
    def set_version(self, version: int) -> None: ...
    def unmap(self) -> None: ...

class RTPHeaderExtension(Gst.Element):
    """
    :Constructors:

    ::

        RTPHeaderExtension(**properties)

    Object GstRTPHeaderExtension

    Signals from GstElement:
      pad-added (GstPad)
      pad-removed (GstPad)
      no-more-pads ()

    Signals from GstObject:
      deep-notify (GstObject, GParam)

    Properties from GstObject:
      name -> gchararray: Name
        The name of the object
      parent -> GstObject: Parent
        The parent of the object

    Signals from GObject:
      notify (GParam)
    """

    class Props:
        name: Optional[str]
        parent: Optional[Gst.Object]

    props: Props = ...
    parent: Gst.Element = ...
    _gst_reserved: list[None] = ...
    def __init__(self, name: Optional[str] = ..., parent: Gst.Object = ...): ...
    @staticmethod
    def create_from_uri(uri: str) -> Optional[RTPHeaderExtension]: ...
    def do_get_max_size(self, input_meta: Gst.Buffer) -> int: ...
    def do_get_supported_flags(self) -> RTPHeaderExtensionFlags: ...
    def do_read(
        self,
        read_flags: RTPHeaderExtensionFlags,
        data: Sequence[int],
        buffer: Gst.Buffer,
    ) -> bool: ...
    def do_set_attributes(
        self, direction: RTPHeaderExtensionDirection, attributes: str
    ) -> bool: ...
    def do_set_caps_from_attributes(self, caps: Gst.Caps) -> bool: ...
    def do_set_non_rtp_sink_caps(self, caps: Gst.Caps) -> bool: ...
    def do_update_non_rtp_src_caps(self, caps: Gst.Caps) -> bool: ...
    def do_write(
        self,
        input_meta: Gst.Buffer,
        write_flags: RTPHeaderExtensionFlags,
        output: Gst.Buffer,
        data: Sequence[int],
    ) -> int: ...
    def get_direction(self) -> RTPHeaderExtensionDirection: ...
    def get_id(self) -> int: ...
    def get_max_size(self, input_meta: Gst.Buffer) -> int: ...
    def get_sdp_caps_field_name(self) -> str: ...
    def get_supported_flags(self) -> RTPHeaderExtensionFlags: ...
    def get_uri(self) -> Optional[str]: ...
    def read(
        self,
        read_flags: RTPHeaderExtensionFlags,
        data: Sequence[int],
        buffer: Gst.Buffer,
    ) -> bool: ...
    def set_attributes_from_caps(self, caps: Gst.Caps) -> bool: ...
    def set_caps_from_attributes(self, caps: Gst.Caps) -> bool: ...
    def set_caps_from_attributes_helper(
        self, caps: Gst.Caps, attributes: str
    ) -> bool: ...
    def set_direction(self, direction: RTPHeaderExtensionDirection) -> None: ...
    def set_id(self, ext_id: int) -> None: ...
    def set_non_rtp_sink_caps(self, caps: Gst.Caps) -> bool: ...
    def set_uri(self, uri: str) -> None: ...
    def set_wants_update_non_rtp_src_caps(self, state: bool) -> None: ...
    def update_non_rtp_src_caps(self, caps: Gst.Caps) -> bool: ...
    def wants_update_non_rtp_src_caps(self) -> bool: ...
    def write(
        self,
        input_meta: Gst.Buffer,
        write_flags: RTPHeaderExtensionFlags,
        output: Gst.Buffer,
        data: Sequence[int],
    ) -> int: ...

class RTPHeaderExtensionClass(GObject.GPointer):
    """
    :Constructors:

    ::

        RTPHeaderExtensionClass()
    """

    parent_class: Gst.ElementClass = ...
    get_supported_flags: Callable[[RTPHeaderExtension], RTPHeaderExtensionFlags] = ...
    get_max_size: Callable[[RTPHeaderExtension, Gst.Buffer], int] = ...
    write: Callable[
        [
            RTPHeaderExtension,
            Gst.Buffer,
            RTPHeaderExtensionFlags,
            Gst.Buffer,
            Sequence[int],
        ],
        int,
    ] = ...
    read: Callable[
        [RTPHeaderExtension, RTPHeaderExtensionFlags, Sequence[int], Gst.Buffer], bool
    ] = ...
    set_non_rtp_sink_caps: Callable[[RTPHeaderExtension, Gst.Caps], bool] = ...
    update_non_rtp_src_caps: Callable[[RTPHeaderExtension, Gst.Caps], bool] = ...
    set_attributes: Callable[
        [RTPHeaderExtension, RTPHeaderExtensionDirection, str], bool
    ] = ...
    set_caps_from_attributes: Callable[[RTPHeaderExtension, Gst.Caps], bool] = ...
    _gst_reserved: list[None] = ...
    def set_uri(self, uri: str) -> None: ...

class RTPPayloadInfo(GObject.GPointer):
    """
    :Constructors:

    ::

        RTPPayloadInfo()
    """

    payload_type: int = ...
    media: str = ...
    encoding_name: str = ...
    clock_rate: int = ...
    encoding_parameters: str = ...
    bitrate: int = ...
    _gst_reserved: list[None] = ...
    @staticmethod
    def for_name(media: str, encoding_name: str) -> Optional[RTPPayloadInfo]: ...
    @staticmethod
    def for_pt(payload_type: int) -> Optional[RTPPayloadInfo]: ...

class RTPSourceMeta(GObject.GPointer):
    """
    :Constructors:

    ::

        RTPSourceMeta()
    """

    meta: Gst.Meta = ...
    ssrc: int = ...
    ssrc_valid: bool = ...
    csrc: list[int] = ...
    csrc_count: int = ...
    def append_csrc(self, csrc: Sequence[int]) -> bool: ...
    @staticmethod
    def get_info() -> Gst.MetaInfo: ...
    def get_source_count(self) -> int: ...
    def set_ssrc(self, ssrc: Optional[int] = None) -> bool: ...

class RTPBufferFlags(GObject.GFlags):
    LAST = 268435456
    REDUNDANT = 2097152
    RETRANSMISSION = 1048576

class RTPBufferMapFlags(GObject.GFlags):
    LAST = 16777216
    SKIP_PADDING = 65536

class RTPHeaderExtensionDirection(GObject.GFlags):
    INACTIVE = 0
    INHERITED = 4
    RECVONLY = 2
    SENDONLY = 1
    SENDRECV = 3

class RTPHeaderExtensionFlags(GObject.GFlags):
    ONE_BYTE = 1
    TWO_BYTE = 2

class RTCPFBType(GObject.GEnum):
    FB_TYPE_INVALID = 0
    PSFB_TYPE_AFB = 15
    PSFB_TYPE_FIR = 4
    PSFB_TYPE_PLI = 1
    PSFB_TYPE_RPSI = 3
    PSFB_TYPE_SLI = 2
    PSFB_TYPE_TSTN = 6
    PSFB_TYPE_TSTR = 5
    PSFB_TYPE_VBCN = 7
    RTPFB_TYPE_NACK = 1
    RTPFB_TYPE_RTCP_SR_REQ = 5
    RTPFB_TYPE_TMMBN = 4
    RTPFB_TYPE_TMMBR = 3
    RTPFB_TYPE_TWCC = 15

class RTCPSDESType(GObject.GEnum):
    APSI = 10
    CCID = 14
    CNAME = 1
    EMAIL = 3
    END = 0
    H323_CADDR = 9
    INVALID = -1
    LOC = 5
    MID = 15
    NAME = 2
    NOTE = 7
    PHONE = 4
    PRIV = 8
    REPAIRED_RTP_STREAM_ID = 13
    RGRP = 11
    RTP_STREAM_ID = 12
    TOOL = 6

class RTCPType(GObject.GEnum):
    APP = 204
    BYE = 203
    INVALID = 0
    PSFB = 206
    RR = 201
    RTPFB = 205
    SDES = 202
    SR = 200
    XR = 207

class RTCPXRType(GObject.GEnum):
    DLRR = 5
    DRLE = 2
    INVALID = -1
    LRLE = 1
    PRT = 3
    RRT = 4
    SSUMM = 6
    VOIP_METRICS = 7

class RTPPayload(GObject.GEnum):
    CELLB = 25
    CN = 13
    DVI4_11025 = 16
    DVI4_16000 = 6
    DVI4_22050 = 17
    DVI4_8000 = 5
    G721 = 2
    G722 = 9
    G723 = 4
    G728 = 15
    G729 = 18
    GSM = 3
    H261 = 31
    H263 = 34
    JPEG = 26
    L16_MONO = 11
    L16_STEREO = 10
    LPC = 7
    MP2T = 33
    MPA = 14
    MPV = 32
    NV = 28
    PCMA = 8
    PCMU = 0
    QCELP = 12

class RTPProfile(GObject.GEnum):
    AVP = 1
    AVPF = 3
    SAVP = 2
    SAVPF = 4
    UNKNOWN = 0
